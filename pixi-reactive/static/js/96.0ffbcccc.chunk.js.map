{"version":3,"sources":["../../src/components/PixiSpine.tsx","../../src/loaders.ts","../../src/core/Animation.ts","../../src/core/AnimationState.ts","../../src/core/AnimationStateData.ts","../../src/core/AtlasAttachmentLoader.ts","../../src/core/BlendMode.ts","../../src/core/Bone.ts","../../src/core/BoneData.ts","../../src/core/Constraint.ts","../../src/core/Event.ts","../../src/core/EventData.ts","../../src/core/IkConstraint.ts","../../src/core/IkConstraintData.ts","../../src/core/PathConstraint.ts","../../src/core/PathConstraintData.ts","../../src/core/Skeleton.ts","../../src/core/SkeletonBinary.ts","../../src/core/SkeletonBounds.ts","../../src/core/SkeletonClipping.ts","../../src/core/SkeletonData.ts","../../src/core/SkeletonJson.ts","../../src/core/Skin.ts","../../src/core/Slot.ts","../../src/core/SlotData.ts","../../src/core/Texture.ts","../../src/core/TextureAtlas.ts","../../src/core/TransformConstraint.ts","../../src/core/TransformConstraintData.ts","../../src/core/Triangulator.ts","../../src/core/Utils.ts","../../src/core/attachments/Attachment.ts","../../src/core/attachments/AttachmentType.ts","../../src/core/attachments/BoundingBoxAttachment.ts","../../src/core/attachments/ClippingAttachment.ts","../../src/core/attachments/MeshAttachment.ts","../../src/core/attachments/PathAttachment.ts","../../src/core/attachments/PointAttachment.ts","../../src/core/attachments/RegionAttachment.ts","../../src/core/vertexeffects/JitterEffect.ts","../../src/core/vertexeffects/SwirlEffect.ts","../../src/polyfills.ts","../../src/Spine.ts","../../src/exporter.ts"],"names":["PixiSpine","props","element","useElement","resources","useContext","frameId","elapsed","update","useState","playing","setPlaying","useReducer","previousElement","spine","setSpineElement","resource","loop","animation","trackIndex","skin","speed","useEffect","component","window","React","item","pixi_spine","core","MixBlend","MixDirection","TimelineType","name","timelines","duration","Error","this","timelineIds","i","length","getPropertyId","hasTimeline","id","apply","skeleton","lastTime","time","events","alpha","blend","direction","n","binarySearch","values","target","step","low","high","current","linearSearch","last","Animation","frameCount","curves","Utils","newFloatArray","CurveTimeline","BEZIER_SIZE","getFrameCount","setLinear","frameIndex","LINEAR","setStepped","STEPPED","getCurveType","index","type","BEZIER","setCurve","cx1","cy1","cx2","cy2","tmpx","tmpy","dddfx","dddfy","ddfx","ddfy","dfx","dfy","x","y","getCurvePercent","percent","MathUtils","clamp","start","prevX","prevY","frames","rotate","boneIndex","setFrame","degrees","RotateTimeline","ROTATION","bone","bones","active","setup","rotation","data","first","ENTRIES","PREV_ROTATION","replace","add","frame","prevRotation","frameTime","PREV_TIME","r","TranslateTimeline","translate","X","Y","PREV_X","PREV_Y","scale","scaleX","scaleY","ScaleTimeline","bx","by","mixOut","Math","abs","signum","shear","shearX","shearY","ShearTimeline","ColorTimeline","color","slotIndex","g","b","a","R","G","B","A","slot","slots","setFromColor","PREV_R","PREV_G","PREV_B","PREV_A","set","TwoColorTimeline","twoColor","r2","g2","b2","R2","G2","B2","darkColor","light","dark","setupLight","setupDark","PREV_R2","PREV_G2","PREV_B2","attachmentNames","Array","attachment","attachmentName","setAttachment","getAttachment","AttachmentTimeline","zeros","frameVertices","deform","vertices","firedEvents","slotAttachment","VertexAttachment","deformAttachment","deformArray","vertexCount","vertexAttachment","setArraySize","setupVertices","lastVertices","arrayCopy","prevVertices","nextVertices","prev","DeformTimeline","event","Number","MAX_VALUE","push","EventTimeline","drawOrders","drawOrder","drawOrderToSetupIndex","DrawOrderTimeline","IkConstraintTimeline","ikConstraint","ikConstraintIndex","mix","softness","bendDirection","compress","stretch","MIX","SOFTNESS","BEND_DIRECTION","COMPRESS","STRETCH","constraint","ikConstraints","PREV_MIX","PREV_SOFTNESS","PREV_BEND_DIRECTION","PREV_COMPRESS","PREV_STRETCH","mixIn","TransformConstraintTimeline","transformConstraint","transformConstraintIndex","rotateMix","translateMix","scaleMix","shearMix","ROTATE","TRANSLATE","SCALE","SHEAR","transformConstraints","PREV_ROTATE","PREV_TRANSLATE","PREV_SCALE","PREV_SHEAR","PathConstraintPositionTimeline","pathConstraintPosition","pathConstraintIndex","value","VALUE","pathConstraints","position","PREV_VALUE","pathConstraintSpacing","spacing","PathConstraintSpacingTimeline","PathConstraintMixTimeline","pathConstraintMix","tracks","timeScale","unkeyedState","listeners","queue","EventQueue","propertyIDs","IntSet","animationsChanged","trackEntryPool","Pool","delta","animationLast","nextAnimationLast","trackLast","nextTrackLast","currentDelta","delay","next","nextTime","trackTime","setCurrent","mixingFrom","mixTime","trackEnd","end","disposeNext","updateMixingFrom","from","mixingTo","drain","to","finished","mixDuration","totalAlpha","interruptAlpha","_animationsChanged","applied","mixBlend","applyMixingFrom","animationTime","getAnimationTime","timelineCount","ii","webkit602BugfixHelper","timeline","applyAttachmentTimeline","timelineMode","firstFrame","timelinesRotation","timelineBlend","AnimationState","SUBSEQUENT","applyRotateTimeline","queueEvents","setupState","SETUP","attachmentState","eventThreshold","attachments","attachmentThreshold","drawOrderThreshold","alphaHold","alphaMix","timelineHoldMix","FIRST","HOLD_SUBSEQUENT","HOLD_FIRST","holdMix","max","CURRENT","rotateTimeline","r1","total","diff","lastTotal","lastDiff","dir","entry","animationStart","animationEnd","trackLastWrapped","complete","clearTracks","oldDrainDisabled","drainDisabled","clearTrack","interrupt","expandToIndex","min","setAnimation","animationName","skeletonData","findAnimation","setAnimationWith","trackEntry","addAnimation","addAnimationWith","getMix","setEmptyAnimation","emptyAnimation","addEmptyAnimation","setEmptyAnimations","ensureArrayCapacity","obtain","holdPrevious","dispose","clear","computeHold","timelinesCount","timelineDipMix","outer","HOLD_MIX","getCurrent","addListener","listener","removeListener","indexOf","splice","clearListeners","clearListenerNotifications","setAnimationByName","deprecatedWarning1","console","warn","addAnimationByName","deprecatedWarning2","hasAnimation","hasAnimationByName","deprecatedWarning3","reset","setAnimationLast","isComplete","resetRotationDirections","TrackEntry","loopsCount","floor","EventType","animState","objects","deprecateStuff","onStart","onEnd","free","count","toInt","onComplete","onEvent","AnimationStateAdapter","animationToMixTime","defaultMix","setMix","fromName","toName","setMixWith","setMixByName","AnimationStateData","key","undefined","atlas","newRegionAttachment","path","region","findRegion","RegionAttachment","newMeshAttachment","MeshAttachment","newBoundingBoxAttachment","BoundingBoxAttachment","newPathAttachment","PathAttachment","newPointAttachment","PointAttachment","newClippingAttachment","ClippingAttachment","AtlasAttachmentLoader","BlendMode","parent","matrix","PIXI","Matrix","children","ax","ay","arotation","ascaleX","ascaleY","ashearX","ashearY","appliedValid","sorted","setToSetupPose","tx","ty","isActive","updateWorldTransformWith","updateWorldTransform","m","sx","sy","Bone","yDown","rotationY","cosDeg","c","sinDeg","d","pa","pb","pc","pd","transformMode","TransformMode","Normal","la","lb","lc","ld","OnlyTranslation","NoRotationOrReflection","prx","s","atan2","radDeg","rx","ry","NoScale","NoScaleOrReflection","cos","sin","za","zc","sqrt","PI","zb","zd","getWorldRotationX","getWorldRotationY","getWorldScaleX","getWorldScaleY","updateAppliedTransform","pm","pid","dx","dy","ia","ib","ic","ra","rb","rc","rd","det","worldToLocal","world","invDet","localToWorld","local","worldToLocalRotation","worldRotation","mat","localToWorldRotation","localRotation","rotateWorld","skinRequired","Color","BoneData","order","ConstraintData","Event","EventData","findBone","apply1","worldX","worldY","uniform","apply2","targetX","targetY","p","rotationIK","sa","sc","dd","child","bendDir","px","py","psx","psy","csx","pmat","os1","os2","s2","cx","cy","cwx","cwy","u","pp","a1","a2","l1","l2","td","sd","acos","aa","bb","ta","c1","c2","q","r0","minAngle","minX","minDist","minY","maxAngle","maxX","maxDist","maxY","os","IkConstraint","IkConstraintData","spaces","positions","lengths","segments","findSlot","spacingMode","lengthSpacing","SpacingMode","Length","rotateMode","tangents","RotateMode","Tangent","ChainScale","boneCount","spacesCount","setupLength","PathConstraint","epsilon","computeWorldPositions","positionMode","PositionMode","Percent","boneX","boneY","offsetRotation","tip","Chain","degRad","PI2","percentPosition","percentSpacing","out","closed","verticesLength","worldVerticesLength","curveCount","prevCurve","NONE","constantSpeed","o","curve","space","BEFORE","computeWorldVertices","addBeforePosition","AFTER","addAfterPosition","addCurvePosition","pathLength","x1","y1","x2","y2","w","curveLength","segment","temp","isNaN","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraintData","_updateCache","updateCacheReset","boneData","slotData","Slot","ikConstraintData","transformConstraintData","TransformConstraint","pathConstraintData","updateCache","skinBones","ikCount","transformCount","pathCount","constraintCount","sortIkConstraint","sortTransformConstraint","sortPathConstraint","sortBone","contains","constraints","constrained","sortReset","slotBone","sortPathConstraintAttachment","defaultSkin","skins","sortPathConstraintAttachmentWith","pathBones","setBonesToSetupPose","setSlotsToSetupPose","getRootBone","boneName","findBoneIndex","slotName","findSlotIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","attachAll","getAttachmentByName","findIkConstraint","constraintName","findTransformConstraint","findPathConstraint","getBounds","offset","size","POSITIVE_INFINITY","NEGATIVE_INFINITY","mesh","nn","Skeleton","attachmentLoader","linkedMeshes","readSkeletonData","binary","SkeletonData","input","BinaryInput","hash","readString","version","error","readFloat","width","height","nonessential","readBoolean","fps","imagesPath","audioPath","readInt","strings","SkeletonBinary","TransformModeValues","rgba8888ToColor","readInt32","SlotData","rgb888ToColor","readStringRef","blendMode","BlendModeValues","readByte","TransformConstraintData","relative","offsetX","offsetY","offsetScaleX","offsetScaleY","offsetShearY","PositionModeValues","SpacingModeValues","RotateModeValues","Fixed","readSkin","linkedMesh","inheritDeform","setParentMesh","intValue","floatValue","stringValue","volume","balance","animations","readAnimation","slotCount","Skin","readAttachment","typeIndex","AttachmentTypeValues","AttachmentType","Region","BoundingBox","readVertices","box","Mesh","uvs","readFloatArray","triangles","readShortArray","hullLength","edges","regionUVs","Float32Array","LinkedMesh","Path","newArray","Point","point","Clipping","endSlotIndex","clip","endSlot","Vertices","weights","bonesArray","toFloatArray","array","readShort","tempColor1","tempColor2","timelineType","SLOT_ATTACHMENT","SLOT_COLOR","readCurve","SLOT_TWO_COLOR","BONE_ROTATE","BONE_TRANSLATE","BONE_SCALE","BONE_SHEAR","timelineScale","PATH_POSITION","PATH_SPACING","PATH_MIX","iii","nnn","weighted","deformLength","v","vn","drawOrderCount","offsetCount","unchanged","originalIndex","unchangedIndex","eventCount","eventData","CURVE_STEPPED","CURVE_BEZIER","Additive","Multiply","Screen","CURVE_LINEAR","buffer","DataView","getInt8","getInt16","getInt32","optimizePositive","result","byteCount","chars","String","fromCharCode","getFloat32","boundingBoxes","polygons","polygonPool","updateAabb","freeAll","boundingBox","polygon","aabbCompute","aabbContainsPoint","aabbIntersectsSegment","aabbIntersectsSkeleton","bounds","containsPoint","containsPointPolygon","prevIndex","inside","vertexY","vertexX","intersectsSegment","intersectsSegmentPolygon","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","getPolygon","getWidth","getHeight","SkeletonBounds","triangulator","Triangulator","clippingPolygon","clipOutput","clippedVertices","clippedTriangles","scratch","clipStart","clipAttachment","SkeletonClipping","makeClockwise","clippingPolygons","decompose","triangulate","clipEndWithSlot","clipEnd","isClipping","clipTriangles","trianglesLength","polygonsCount","vertexSize","vertexOffset","u1","v1","u2","v2","u3","v3","clippedVerticesItems","clippedTrianglesItems","clipOutputLength","d0","d1","d2","d4","clipOutputCount","clipOutputItems","c0","clippingArea","output","originalOutput","clipped","clippingVertices","clippingVerticesLast","edgeX","edgeY","edgeX2","edgeY2","deltaX","deltaY","inputVertices","inputVerticesLength","outputStart","inputX","inputY","inputX2","inputY2","side2","ua","verticeslength","area","p1x","p1y","p2x","lastX","other","findEvent","eventDataName","findPathConstraintIndex","pathConstraintName","FAIL_ON_NON_EXISTING_SKIN","json","root","JSON","parse","skeletonMap","substr","images","boneMap","parentName","getValue","SkeletonJson","transformModeFromString","slotMap","setFromString","blendModeFromString","ik","constraintMap","j","targetName","transform","positionModeFromString","spacingModeFromString","rotateModeFromString","skinMap","entryName","eventName","eventMap","animationMap","map","scaledVertices","timelineName","timelineMap","valueMap","defaultValue","deformName","deformMap","verticesValue","drawOrderNode","draworder","drawOrderMap","offsets","offsetMap","toSinglePrecision","hasOwnProperty","prop","str","toLowerCase","SkinEntry","addSkin","contained","getAttachments","copySkin","newLinkedMesh","copy","dictionary","removeAttachment","entries","slotAttachments","getAttachmentsForSlot","oldSkin","attachmentTime","setAttachmentTime","getAttachmentTime","TextureFilter","TextureWrap","image","_image","getImage","filterFromString","text","Nearest","Linear","MipMap","MipMapNearestNearest","MipMapLinearNearest","MipMapNearestLinear","MipMapLinearLinear","wrapFromString","MirroredRepeat","ClampToEdge","Repeat","Texture","tex","texture","VERSION","crop","trim","orig","_uvs","x0","y0","spineOffsetY","originalHeight","TextureRegion","atlasText","textureLoader","callback","pages","regions","addSpineAtlas","addTexture","page","baseTexture","TextureAtlasPage","realWidth","realHeight","minFilter","magFilter","uWrap","vWrap","TextureAtlasRegion","addTextureHash","textures","stripExtension","lastIndexOf","load","reader","TextureAtlasReader","tuple","iterateParser","line","readLine","readTuple","parseInt","readValue","valid","setSize","setFilters","log","rotateValue","toLocaleLowerCase","parseFloat","resolution","swapWH","Rectangle","originalWidth","frame2","clone","updateUvs","TextureAtlas","lines","split","colon","substring","lastMatch","comma","filter","scaleMode","SCALE_MODES","NEAREST","mipmap","MIPMAP_MODES","POW2","Vector2","applyRelativeLocal","applyAbsoluteLocal","applyRelativeWorld","applyAbsoluteWorld","targetMat","tb","tc","degRadReflect","modified","ts","convexPolygons","convexPolygonsIndices","indicesArray","isConcaveArray","polygonIndicesPool","verticesArray","indices","isConcave","previous","p1","p2","p3","p2y","p3x","p3y","vx","vy","positiveArea","previousIndex","nextIndex","polygonIndices","fanBaseIndex","lastWinding","t1","t2","t3","merged","winding1","winding","winding2","firstIndex","lastIndex","prevPrevX","prevPrevY","firstX","firstY","secondX","secondY","otherIndices","otherFirstIndex","otherSecondIndex","otherLastIndex","otherPoly","remove","hex","charAt","WHITE","RED","GREEN","BLUE","MAGENTA","ceil","cbrt","pow","randomTriangular","randomTriangularWith","mode","random","radiansToDegrees","degreesToRadians","applyInternal","Interpolation","power","Pow","PowOut","source","sourceStart","dest","destStart","numElements","oldSize","SUPPORTS_TYPED_ARRAYS","newShortArray","Int16Array","fround","identity","logBones","DebugUtils","instantiator","items","pop","normalize","len","maxDelta","framesPerSecond","totalTime","Date","now","TimeKeeper","windowSize","addedValues","lastValue","mean","dirty","hasEnoughData","addValue","getMean","WindowedMean","Attachment","nextID","computeWorldVerticesOld","worldVertices","stride","skip","skeletonBones","wx","wy","weight","f","copyTo","tempColor","getParentMesh","parentMesh","computeWorldPosition","computeWorldRotation","updateOffset","regionScaleX","regionScaleY","localX","localY","localX2","localY2","radians","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","OX1","OY1","OX2","OY2","OX3","OY3","OX4","OY4","setRegion","rendererObject","X1","Y1","C1R","C1G","C1B","C1A","U1","V1","X2","Y2","C2R","C2G","C2B","C2A","U2","V2","X3","Y3","C3R","C3G","C3B","C3A","U3","V3","X4","Y4","C4R","C4G","C4B","C4A","U4","V4","jitterX","jitterY","begin","uv","JitterEffect","radius","centerX","centerY","angle","radAngle","dist","theta","SwirlEffect","interpolation","tempRgb","Sprite","SpineSprite","gp","GraphicsGeometry","prototype","invalidate","t","graphicsData","drawMode","SimpleMesh","SpineMesh","spineData","stateData","state","slotContainers","tempClipContainers","slotContainer","newContainer","addChild","spriteName","sprite","createSprite","currentSprite","currentSpriteName","createMesh","currentMesh","currentMeshName","createGraphics","clippingContainer","currentGraphics","tintRgb","autoUpdate","visible","_autoUpdate","updateTransform","Spine","autoUpdateTransform","Container","_visible","utils","rgb2hex","hex2rgb","localDelayLimit","globalDelayLimit","dt","delayLimit","globalClr","spriteColor","attColor","ar","hackRegion","setSpriteRegion","sprites","setFromMatrix","tint","Transform","_parentID","_worldID","meshName","meshes","updateGraphics","g0","b0","setLight","setDark","clippingAttachment","removeChild","renderable","setMeshRegion","uvBuffer","globalAutoUpdate","timeDelta","call","defName","hackAttachment","newSprite","anchor","strip","newMesh","Uint16Array","DRAW_MODES","TRIANGLES","_canvasPadding","graphics","newGraphics","poly","Polygon","beginFill","drawPolygon","mask","geom","geometry","shape","points","hackTextureBySlotIndex","hackTextureBySlotName","hackTextureAttachment","currentAttachment","Graphics","transformHack","hackAttachmentGroups","nameSuffix","group","outGroup","list_d","list_n","endsWith","parentGroup","destroy","options","TextureProto","_updateUvs","LoaderResource","setExtensionXhrType","XHR_RESPONSE_TYPE","BUFFER","use","isJsonSpineModel","TYPE","isJson","isBinarySpineModel","xhrType","isBuffer","extension","metadata","spineMetadata","parser","dataToParse","ArrayBuffer","Uint8Array","metadataSkeletonScale","spineSkeletonScale","metadataAtlas","spineAtlas","metadataAtlasSuffix","spineAtlasSuffix","atlasPath","url","queryStringPos","spineAtlasFile","baseUrl","atlasOptions","crossOrigin","TEXT","parentResource","imageOptions","imageMetadata","namePrefix","imageNamePrefix","adapter","staticImageLoader","imageLoader","imageLoaderAdapter","createSkeletonWithRawAtlas","rawData","atlasRawData","atlasResource","loader","cachedResource","done","onAfterMiddleware","AtlasParser","syncImageLoaderAdapter","BaseTexture","Loader","registerPlugin"],"mappings":"yMAMMA,G,OAAsC,SAACC,GAC3C,IAAMC,EAAUC,aAAW,IAA3B,aACQC,EAAcC,qBAAW,EAAD,IAAxBD,U,EACqBC,qBAAW,EAAD,GAA/BC,YAASC,YACTC,EAAWH,qBAAW,EAAD,IAArBG,O,EACsBC,oBAAS,GAAhCC,OAASC,O,EACiBC,sBAC/B,cAIE,OAHA,GACEC,YAEF,SALuC,GAApCC,OAAOC,OASNC,EAAuEf,EAAvEe,S,EAAuEf,EAA7DgB,gBAAOA,GAAA,EAAOC,EAA+CjB,EAA/CiB,U,EAA+CjB,EAApCkB,sBAAaA,EAAA,IAAGC,EAAoBnB,EAApBmB,K,EAAoBnB,EAAdoB,iBAAQA,EAAA,IAoDzE,OAlDAC,qBAAU,WACR,IACER,yBACA,GACEA,+BAGH,CAACM,EAPJE,IASAA,qBAAU,WACR,GACER,iBAED,CAACZ,EAJJoB,IAMAA,qBAAU,WACR,GAAIN,GAAYZ,EAAZY,IAAmCZ,KAAvC,UAAsE,CACpE,IAAMmB,EAAY,IAAIC,kBAAJ,MAA4BpB,KAA9C,WACAmB,gBAEAR,QAED,CAACC,EAPJM,IASAA,qBAAU,WACR,IACMJ,GAAaJ,qBAAjB,IACEA,4BACAH,QAEAG,sBACAA,4BACAH,OAEFH,OAED,CAACM,EAAOK,EAAYD,EAAWD,EAZlCK,IAcAA,qBAAU,WACR,IACER,uBAED,CAACA,EAJJQ,IAMAA,qBAAU,WACJZ,GAAJ,GACEI,cAED,CAACJ,EAASJ,EAASC,EAASO,EAJ/BQ,IAMOG,qCAAmBC,KAAMxB,GAAhC,O,sBCzDQyB,E,kWCaV,SAAUA,IAAW,SAAAC,GAGjB,IA+FYC,EA4BAC,EAIAC,EA/HZ,aASI,WAAaC,EAAcC,EAA4BC,GACnD,GAAY,MAARF,EAAc,MAAM,IAAIG,MAAM,wBAClC,GAAiB,MAAbF,EAAmB,MAAM,IAAIE,MAAM,6BACvCC,KAAKJ,KAAOA,EACZI,KAAKH,UAAYA,EACjBG,KAAKC,YAAc,GACnB,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAUM,OAAQD,IAClCF,KAAKC,YAAYJ,EAAUK,GAAGE,kBAAmB,EACrDJ,KAAKF,SAAWA,EA+CxB,OA5CI,YAAAO,YAAA,SAAaC,GACT,OAA+B,GAAxBN,KAAKC,YAAYK,IAQ5B,YAAAC,MAAA,SAAOC,EAAoBC,EAAkBC,EAAc7B,EAAe8B,EAAsBC,EAAeC,EAAiBC,GAC5H,GAAgB,MAAZN,EAAkB,MAAM,IAAIT,MAAM,4BAElClB,GAAyB,GAAjBmB,KAAKF,WACbY,GAAQV,KAAKF,SACTW,EAAW,IAAGA,GAAYT,KAAKF,WAIvC,IADA,IAAID,EAAYG,KAAKH,UACZK,EAAI,EAAGa,EAAIlB,EAAUM,OAAQD,EAAIa,EAAGb,IACzCL,EAAUK,GAAGK,MAAMC,EAAUC,EAAUC,EAAMC,EAAQC,EAAOC,EAAOC,IAKpE,EAAAE,aAAP,SAAqBC,EAA2BC,EAAgBC,QAAA,IAAAA,MAAA,GAC5D,IAAIC,EAAM,EACNC,EAAOJ,EAAOd,OAASgB,EAAO,EAClC,GAAY,GAARE,EAAW,OAAOF,EAEtB,IADA,IAAIG,EAAUD,IAAS,IACV,CAKT,GAJIJ,GAAQK,EAAU,GAAKH,IAASD,EAChCE,EAAME,EAAU,EAEhBD,EAAOC,EACPF,GAAOC,EAAM,OAAQD,EAAM,GAAKD,EACpCG,EAAWF,EAAMC,IAAU,IAI5B,EAAAE,aAAP,SAAqBN,EAA2BC,EAAgBC,GAC5D,IAAK,IAAIjB,EAAI,EAAGsB,EAAOP,EAAOd,OAASgB,EAAMjB,GAAKsB,EAAMtB,GAAKiB,EACzD,GAAIF,EAAOf,GAAKgB,EAAQ,OAAOhB,EACnC,OAAQ,GAEhB,EAhEA,GAAa,EAAAuB,UAAS,EA+FtB,SAAYhC,GAGR,qBAMA,qBAKA,yBAOA,iBArBJ,CAAYA,EAAA,EAAAA,WAAA,EAAAA,SAAQ,KA4BpB,SAAYC,GACR,qBAAO,uBADX,CAAYA,EAAA,EAAAA,eAAA,EAAAA,aAAY,KAIxB,SAAYC,GACR,uBAAQ,6BAAW,qBAAO,qBAC1B,+BAAY,qBAAO,uBACnB,qBAAO,6BACP,mCAAc,kDACd,wDAAwB,sDAAuB,8CAC/C,4BANJ,CAAYA,EAAA,EAAAA,eAAA,EAAAA,aAAY,KAUxB,iBAQI,WAAa+B,GACT,GAAIA,GAAc,EAAG,MAAM,IAAI3B,MAAM,2BAA6B2B,GAClE1B,KAAK2B,OAAS,EAAAC,MAAMC,eAAeH,EAAa,GAAKI,EAAcC,aAoF3E,OAhFI,YAAAC,cAAA,WACI,OAAOhC,KAAK2B,OAAOxB,OAAS2B,EAAcC,YAAc,GAI5D,YAAAE,UAAA,SAAWC,GACPlC,KAAK2B,OAAOO,EAAaJ,EAAcC,aAAeD,EAAcK,QAIxE,YAAAC,WAAA,SAAYF,GACRlC,KAAK2B,OAAOO,EAAaJ,EAAcC,aAAeD,EAAcO,SAKxE,YAAAC,aAAA,SAAcJ,GACV,IAAIK,EAAQL,EAAaJ,EAAcC,YACvC,GAAIQ,GAASvC,KAAK2B,OAAOxB,OAAQ,OAAO2B,EAAcK,OACtD,IAAIK,EAAOxC,KAAK2B,OAAOY,GACvB,OAAIC,GAAQV,EAAcK,OAAeL,EAAcK,OACnDK,GAAQV,EAAcO,QAAgBP,EAAcO,QACjDP,EAAcW,QAMzB,YAAAC,SAAA,SAAUR,EAAoBS,EAAaC,EAAaC,EAAaC,GACjE,IAAIC,EAA0B,KAAX,GAANJ,EAAUE,GAAaG,EAA0B,KAAX,GAANJ,EAAUE,GACnDG,EAAgC,MAAT,GAAbN,EAAME,GAAW,GAAYK,EAAgC,MAAT,GAAbN,EAAME,GAAW,GAClEK,EAAc,EAAPJ,EAAWE,EAAOG,EAAc,EAAPJ,EAAWE,EAC3CG,EAAY,GAANV,EAAYI,EAAe,UAARE,EAAoBK,EAAY,GAANV,EAAYI,EAAe,UAARE,EAEtEhD,EAAIgC,EAAaJ,EAAcC,YAC/BJ,EAAS3B,KAAK2B,OAClBA,EAAOzB,KAAO4B,EAAcW,OAG5B,IADA,IAAIc,EAAIF,EAAKG,EAAIF,EACRvC,EAAIb,EAAI4B,EAAcC,YAAc,EAAG7B,EAAIa,EAAGb,GAAK,EACxDyB,EAAOzB,GAAKqD,EACZ5B,EAAOzB,EAAI,GAAKsD,EAChBH,GAAOF,EACPG,GAAOF,EACPD,GAAQF,EACRG,GAAQF,EACRK,GAAKF,EACLG,GAAKF,GAKb,YAAAG,gBAAA,SAAiBvB,EAAoBwB,GACjCA,EAAU,EAAAC,UAAUC,MAAMF,EAAS,EAAG,GACtC,IAAI/B,EAAS3B,KAAK2B,OACdzB,EAAIgC,EAAaJ,EAAcC,YAC/BS,EAAOb,EAAOzB,GAClB,GAAIsC,GAAQV,EAAcK,OAAQ,OAAOuB,EACzC,GAAIlB,GAAQV,EAAcO,QAAS,OAAO,EAG1C,IADA,IAAIkB,EAAI,EACCM,IAFT3D,EAEoBa,EAAIb,EAAI4B,EAAcC,YAAc,EAAG7B,EAAIa,EAAGb,GAAK,EAEnE,IADAqD,EAAI5B,EAAOzB,KACFwD,EAAS,CACd,IAAII,OAAK,EAAUC,OAAK,EAQxB,OAPI7D,GAAK2D,GACLC,EAAQ,EACRC,EAAQ,IAERD,EAAQnC,EAAOzB,EAAI,GACnB6D,EAAQpC,EAAOzB,EAAI,IAEhB6D,GAASpC,EAAOzB,EAAI,GAAK6D,IAAUL,EAAUI,IAAUP,EAAIO,GAG1E,IAAIN,EAAI7B,EAAOzB,EAAI,GACnB,OAAOsD,GAAK,EAAIA,IAAME,EAAUH,IAAM,EAAIA,IAzFvC,EAAApB,OAAS,EAAU,EAAAE,QAAU,EAAU,EAAAI,OAAS,EAChD,EAAAV,YAAc,GA4FzB,EA9FA,GAAsB,EAAAD,cAAa,EAiGnC,kBAWI,WAAaJ,GAAb,MACI,YAAMA,IAAW,K,OACjB,EAAKsC,OAAS,EAAApC,MAAMC,cAAcH,GAAc,G,EAmExD,OAhFoC,OAgBhC,YAAAtB,cAAA,WACI,OAAQT,EAAasE,QAAU,IAAMjE,KAAKkE,WAI9C,YAAAC,SAAA,SAAUjC,EAAoBxB,EAAc0D,GACxClC,IAAe,EACflC,KAAKgE,OAAO9B,GAAcxB,EAC1BV,KAAKgE,OAAO9B,EAAamC,EAAeC,UAAYF,GAGxD,YAAA7D,MAAA,SAAOC,EAAoBC,EAAkBC,EAAcC,EAAsBC,EAAeC,EAAiBC,GAC7G,IAAIkD,EAAShE,KAAKgE,OAEdO,EAAO/D,EAASgE,MAAMxE,KAAKkE,WAC/B,GAAKK,EAAKE,OACV,GAAI/D,EAAOsD,EAAO,GACd,OAAQnD,GACJ,KAAKpB,EAASiF,MAEV,YADAH,EAAKI,SAAWJ,EAAKK,KAAKD,UAE9B,KAAKlF,EAASoF,MACV,IAAI,EAAIN,EAAKK,KAAKD,SAAWJ,EAAKI,SAClCJ,EAAKI,WAAa,EAAqD,KAAhD,OAAU,mBAAqB,EAAI,IAAO,KAAa/D,OAK1F,GAAIF,GAAQsD,EAAOA,EAAO7D,OAASkE,EAAeS,SAAlD,CACI,IAAI,EAAId,EAAOA,EAAO7D,OAASkE,EAAeU,eAC9C,OAAQlE,GACJ,KAAKpB,EAASiF,MACVH,EAAKI,SAAWJ,EAAKK,KAAKD,SAAW,EAAI/D,EACzC,MACJ,KAAKnB,EAASoF,MACd,KAAKpF,EAASuF,QACV,GAAKT,EAAKK,KAAKD,SAAWJ,EAAKI,SAC/B,GAAsD,KAAhD,OAAU,mBAAqB,EAAI,IAAO,IACpD,KAAKlF,EAASwF,IACVV,EAAKI,UAAY,EAAI/D,OAXjC,CAiBA,IAAIsE,EAAQzD,EAAUT,aAAagD,EAAQtD,EAAM2D,EAAeS,SAC5DK,EAAenB,EAAOkB,EAAQb,EAAeU,eAC7CK,EAAYpB,EAAOkB,GACnBxB,EAAU1D,KAAKyD,iBAAiByB,GAAS,GAAK,EAC9C,GAAKxE,EAAO0E,IAAcpB,EAAOkB,EAAQb,EAAegB,WAAaD,IAErEE,EAAItB,EAAOkB,EAAQb,EAAeC,UAAYa,EAElD,OADAG,EAAIH,GAAgBG,EAAqD,KAAhD,OAAU,mBAAqBA,EAAI,IAAO,KAAa5B,EACxE7C,GACJ,KAAKpB,EAASiF,MACVH,EAAKI,SAAWJ,EAAKK,KAAKD,UAAYW,EAAqD,KAAhD,OAAU,mBAAqBA,EAAI,IAAO,KAAa1E,EAClG,MACJ,KAAKnB,EAASoF,MACd,KAAKpF,EAASuF,QACVM,GAAKf,EAAKK,KAAKD,SAAWJ,EAAKI,SACnC,KAAKlF,EAASwF,IACVV,EAAKI,WAAaW,EAAqD,KAAhD,OAAU,mBAAqBA,EAAI,IAAO,KAAa1E,KA5EnF,EAAAkE,QAAU,EACV,EAAAO,WAAa,EAAU,EAAAN,eAAiB,EACxC,EAAAT,SAAW,EA6EtB,EAhFA,CAAoCxC,GAAvB,EAAAuC,eAAc,EAmF3B,kBAWI,WAAa3C,GAAb,MACI,YAAMA,IAAW,K,OACjB,EAAKsC,OAAS,EAAApC,MAAMC,cAAcH,EAAa6D,EAAkBT,S,EAgEzE,OA7EuC,OAgBnC,YAAA1E,cAAA,WACI,OAAQT,EAAa6F,WAAa,IAAMxF,KAAKkE,WAIjD,YAAAC,SAAA,SAAUjC,EAAoBxB,EAAc6C,EAAWC,GACnDtB,GAAcqD,EAAkBT,QAChC9E,KAAKgE,OAAO9B,GAAcxB,EAC1BV,KAAKgE,OAAO9B,EAAaqD,EAAkBE,GAAKlC,EAChDvD,KAAKgE,OAAO9B,EAAaqD,EAAkBG,GAAKlC,GAGpD,YAAAjD,MAAA,SAAOC,EAAoBC,EAAkBC,EAAcC,EAAsBC,EAAeC,EAAiBC,GAC7G,IAAIkD,EAAShE,KAAKgE,OAEdO,EAAO/D,EAASgE,MAAMxE,KAAKkE,WAC/B,GAAKK,EAAKE,OACV,GAAI/D,EAAOsD,EAAO,GACd,OAAQnD,GACJ,KAAKpB,EAASiF,MAGV,OAFAH,EAAKhB,EAAIgB,EAAKK,KAAKrB,OACnBgB,EAAKf,EAAIe,EAAKK,KAAKpB,GAEvB,KAAK/D,EAASoF,MACVN,EAAKhB,IAAMgB,EAAKK,KAAKrB,EAAIgB,EAAKhB,GAAK3C,EACnC2D,EAAKf,IAAMe,EAAKK,KAAKpB,EAAIe,EAAKf,GAAK5C,MAR/C,CAaA,IAAI2C,EAAI,EAAGC,EAAI,EACf,GAAI9C,GAAQsD,EAAOA,EAAO7D,OAASoF,EAAkBT,SACjDvB,EAAIS,EAAOA,EAAO7D,OAASoF,EAAkBI,QAC7CnC,EAAIQ,EAAOA,EAAO7D,OAASoF,EAAkBK,YAC1C,CAEH,IAAIV,EAAQzD,EAAUT,aAAagD,EAAQtD,EAAM6E,EAAkBT,SACnEvB,EAAIS,EAAOkB,EAAQK,EAAkBI,QACrCnC,EAAIQ,EAAOkB,EAAQK,EAAkBK,QACrC,IAAIR,EAAYpB,EAAOkB,GACnBxB,EAAU1D,KAAKyD,gBAAgByB,EAAQK,EAAkBT,QAAU,EACnE,GAAKpE,EAAO0E,IAAcpB,EAAOkB,EAAQK,EAAkBF,WAAaD,IAE5E7B,IAAMS,EAAOkB,EAAQK,EAAkBE,GAAKlC,GAAKG,EACjDF,IAAMQ,EAAOkB,EAAQK,EAAkBG,GAAKlC,GAAKE,EAErD,OAAQ7C,GACJ,KAAKpB,EAASiF,MACVH,EAAKhB,EAAIgB,EAAKK,KAAKrB,EAAIA,EAAI3C,EAC3B2D,EAAKf,EAAIe,EAAKK,KAAKpB,EAAIA,EAAI5C,EAC3B,MACJ,KAAKnB,EAASoF,MACd,KAAKpF,EAASuF,QACVT,EAAKhB,IAAMgB,EAAKK,KAAKrB,EAAIA,EAAIgB,EAAKhB,GAAK3C,EACvC2D,EAAKf,IAAMe,EAAKK,KAAKpB,EAAIA,EAAIe,EAAKf,GAAK5C,EACvC,MACJ,KAAKnB,EAASwF,IACVV,EAAKhB,GAAKA,EAAI3C,EACd2D,EAAKf,GAAKA,EAAI5C,KAzEnB,EAAAkE,QAAU,EACV,EAAAO,WAAa,EAAU,EAAAM,QAAU,EAAU,EAAAC,QAAU,EACrD,EAAAH,EAAI,EAAU,EAAAC,EAAI,EA0E7B,EA7EA,CAAuC5D,GAA1B,EAAAyD,kBAAiB,EAgF9B,kBACI,WAAa7D,G,OACT,YAAMA,IAAW,KAgGzB,OAlGmC,OAK/B,YAAAtB,cAAA,WACI,OAAQT,EAAakG,OAAS,IAAM7F,KAAKkE,WAG7C,YAAA3D,MAAA,SAAOC,EAAoBC,EAAkBC,EAAcC,EAAsBC,EAAeC,EAAiBC,GAC7G,IAAIkD,EAAShE,KAAKgE,OAEdO,EAAO/D,EAASgE,MAAMxE,KAAKkE,WAC/B,GAAKK,EAAKE,OACV,GAAI/D,EAAOsD,EAAO,GACd,OAAQnD,GACJ,KAAKpB,EAASiF,MAGV,OAFAH,EAAKuB,OAASvB,EAAKK,KAAKkB,YACxBvB,EAAKwB,OAASxB,EAAKK,KAAKmB,QAE5B,KAAKtG,EAASoF,MACVN,EAAKuB,SAAWvB,EAAKK,KAAKkB,OAASvB,EAAKuB,QAAUlF,EAClD2D,EAAKwB,SAAWxB,EAAKK,KAAKmB,OAASxB,EAAKwB,QAAUnF,MAR9D,CAaA,IAAI2C,EAAI,EAAGC,EAAI,EACf,GAAI9C,GAAQsD,EAAOA,EAAO7D,OAAS6F,EAAclB,SAC7CvB,EAAIS,EAAOA,EAAO7D,OAAS6F,EAAcL,QAAUpB,EAAKK,KAAKkB,OAC7DtC,EAAIQ,EAAOA,EAAO7D,OAAS6F,EAAcJ,QAAUrB,EAAKK,KAAKmB,WAC1D,CAEH,IAAIb,EAAQzD,EAAUT,aAAagD,EAAQtD,EAAMsF,EAAclB,SAC/DvB,EAAIS,EAAOkB,EAAQc,EAAcL,QACjCnC,EAAIQ,EAAOkB,EAAQc,EAAcJ,QACjC,IAAIR,EAAYpB,EAAOkB,GACnBxB,EAAU1D,KAAKyD,gBAAgByB,EAAQc,EAAclB,QAAU,EAC/D,GAAKpE,EAAO0E,IAAcpB,EAAOkB,EAAQc,EAAcX,WAAaD,IAExE7B,GAAKA,GAAKS,EAAOkB,EAAQc,EAAcP,GAAKlC,GAAKG,GAAWa,EAAKK,KAAKkB,OACtEtC,GAAKA,GAAKQ,EAAOkB,EAAQc,EAAcN,GAAKlC,GAAKE,GAAWa,EAAKK,KAAKmB,OAE1E,GAAa,GAATnF,EACIC,GAASpB,EAASwF,KAClBV,EAAKuB,QAAUvC,EAAIgB,EAAKK,KAAKkB,OAC7BvB,EAAKwB,QAAUvC,EAAIe,EAAKK,KAAKmB,SAE7BxB,EAAKuB,OAASvC,EACdgB,EAAKwB,OAASvC,OAEf,CACH,IAAIyC,EAAK,EAAGC,EAAK,EACjB,GAAIpF,GAAapB,EAAayG,OAC1B,OAAQtF,GACJ,KAAKpB,EAASiF,MACVuB,EAAK1B,EAAKK,KAAKkB,OACfI,EAAK3B,EAAKK,KAAKmB,OACfxB,EAAKuB,OAASG,GAAMG,KAAKC,IAAI9C,GAAK,EAAAI,UAAU2C,OAAOL,GAAMA,GAAMrF,EAC/D2D,EAAKwB,OAASG,GAAME,KAAKC,IAAI7C,GAAK,EAAAG,UAAU2C,OAAOJ,GAAMA,GAAMtF,EAC/D,MACJ,KAAKnB,EAASoF,MACd,KAAKpF,EAASuF,QACViB,EAAK1B,EAAKuB,OACVI,EAAK3B,EAAKwB,OACVxB,EAAKuB,OAASG,GAAMG,KAAKC,IAAI9C,GAAK,EAAAI,UAAU2C,OAAOL,GAAMA,GAAMrF,EAC/D2D,EAAKwB,OAASG,GAAME,KAAKC,IAAI7C,GAAK,EAAAG,UAAU2C,OAAOJ,GAAMA,GAAMtF,EAC/D,MACJ,KAAKnB,EAASwF,IACVgB,EAAK1B,EAAKuB,OACVI,EAAK3B,EAAKwB,OACVxB,EAAKuB,OAASG,GAAMG,KAAKC,IAAI9C,GAAK,EAAAI,UAAU2C,OAAOL,GAAM1B,EAAKK,KAAKkB,QAAUlF,EAC7E2D,EAAKwB,OAASG,GAAME,KAAKC,IAAI7C,GAAK,EAAAG,UAAU2C,OAAOJ,GAAM3B,EAAKK,KAAKmB,QAAUnF,OAGrF,OAAQC,GACJ,KAAKpB,EAASiF,MACVuB,EAAKG,KAAKC,IAAI9B,EAAKK,KAAKkB,QAAU,EAAAnC,UAAU2C,OAAO/C,GACnD2C,EAAKE,KAAKC,IAAI9B,EAAKK,KAAKmB,QAAU,EAAApC,UAAU2C,OAAO9C,GACnDe,EAAKuB,OAASG,GAAM1C,EAAI0C,GAAMrF,EAC9B2D,EAAKwB,OAASG,GAAM1C,EAAI0C,GAAMtF,EAC9B,MACJ,KAAKnB,EAASoF,MACd,KAAKpF,EAASuF,QACViB,EAAKG,KAAKC,IAAI9B,EAAKuB,QAAU,EAAAnC,UAAU2C,OAAO/C,GAC9C2C,EAAKE,KAAKC,IAAI9B,EAAKwB,QAAU,EAAApC,UAAU2C,OAAO9C,GAC9Ce,EAAKuB,OAASG,GAAM1C,EAAI0C,GAAMrF,EAC9B2D,EAAKwB,OAASG,GAAM1C,EAAI0C,GAAMtF,EAC9B,MACJ,KAAKnB,EAASwF,IACVgB,EAAK,EAAAtC,UAAU2C,OAAO/C,GACtB2C,EAAK,EAAAvC,UAAU2C,OAAO9C,GACtBe,EAAKuB,OAASM,KAAKC,IAAI9B,EAAKuB,QAAUG,GAAM1C,EAAI6C,KAAKC,IAAI9B,EAAKK,KAAKkB,QAAUG,GAAMrF,EACnF2D,EAAKwB,OAASK,KAAKC,IAAI9B,EAAKwB,QAAUG,GAAM1C,EAAI4C,KAAKC,IAAI9B,EAAKK,KAAKmB,QAAUG,GAAMtF,MAK3G,EAlGA,CAAmC2E,GAAtB,EAAAS,cAAa,EAqG1B,kBACI,WAAatE,G,OACT,YAAMA,IAAW,KAwDzB,OA1DmC,OAK/B,YAAAtB,cAAA,WACI,OAAQT,EAAa4G,OAAS,IAAMvG,KAAKkE,WAG7C,YAAA3D,MAAA,SAAOC,EAAoBC,EAAkBC,EAAcC,EAAsBC,EAAeC,EAAiBC,GAC7G,IAAIkD,EAAShE,KAAKgE,OAEdO,EAAO/D,EAASgE,MAAMxE,KAAKkE,WAC/B,GAAKK,EAAKE,OACV,GAAI/D,EAAOsD,EAAO,GACd,OAAQnD,GACJ,KAAKpB,EAASiF,MAGV,OAFAH,EAAKiC,OAASjC,EAAKK,KAAK4B,YACxBjC,EAAKkC,OAASlC,EAAKK,KAAK6B,QAE5B,KAAKhH,EAASoF,MACVN,EAAKiC,SAAWjC,EAAKK,KAAK4B,OAASjC,EAAKiC,QAAU5F,EAClD2D,EAAKkC,SAAWlC,EAAKK,KAAK6B,OAASlC,EAAKkC,QAAU7F,MAR9D,CAaA,IAAI2C,EAAI,EAAGC,EAAI,EACf,GAAI9C,GAAQsD,EAAOA,EAAO7D,OAASuG,EAAc5B,SAC7CvB,EAAIS,EAAOA,EAAO7D,OAASuG,EAAcf,QACzCnC,EAAIQ,EAAOA,EAAO7D,OAASuG,EAAcd,YACtC,CAEH,IAAIV,EAAQzD,EAAUT,aAAagD,EAAQtD,EAAMgG,EAAc5B,SAC/DvB,EAAIS,EAAOkB,EAAQwB,EAAcf,QACjCnC,EAAIQ,EAAOkB,EAAQwB,EAAcd,QACjC,IAAIR,EAAYpB,EAAOkB,GACnBxB,EAAU1D,KAAKyD,gBAAgByB,EAAQwB,EAAc5B,QAAU,EAC/D,GAAKpE,EAAO0E,IAAcpB,EAAOkB,EAAQwB,EAAcrB,WAAaD,IAExE7B,IAASS,EAAOkB,EAAQwB,EAAcjB,GAAKlC,GAAKG,EAChDF,IAASQ,EAAOkB,EAAQwB,EAAchB,GAAKlC,GAAKE,EAEpD,OAAQ7C,GACJ,KAAKpB,EAASiF,MACVH,EAAKiC,OAASjC,EAAKK,KAAK4B,OAASjD,EAAI3C,EACrC2D,EAAKkC,OAASlC,EAAKK,KAAK6B,OAASjD,EAAI5C,EACrC,MACJ,KAAKnB,EAASoF,MACd,KAAKpF,EAASuF,QACVT,EAAKiC,SAAWjC,EAAKK,KAAK4B,OAASjD,EAAIgB,EAAKiC,QAAU5F,EACtD2D,EAAKkC,SAAWlC,EAAKK,KAAK6B,OAASjD,EAAIe,EAAKkC,QAAU7F,EACtD,MACJ,KAAKnB,EAASwF,IACVV,EAAKiC,QAAUjD,EAAI3C,EACnB2D,EAAKkC,QAAUjD,EAAI5C,KAGnC,EA1DA,CAAmC2E,GAAtB,EAAAmB,cAAa,EA6D1B,kBAWI,WAAahF,GAAb,MACI,YAAMA,IAAW,K,OACjB,EAAKsC,OAAS,EAAApC,MAAMC,cAAcH,EAAaiF,EAAc7B,S,EAiErE,OA9EmC,OAgB/B,YAAA1E,cAAA,WACI,OAAQT,EAAaiH,OAAS,IAAM5G,KAAK6G,WAI7C,YAAA1C,SAAA,SAAUjC,EAAoBxB,EAAc4E,EAAWwB,EAAWC,EAAWC,GACzE9E,GAAcyE,EAAc7B,QAC5B9E,KAAKgE,OAAO9B,GAAcxB,EAC1BV,KAAKgE,OAAO9B,EAAayE,EAAcM,GAAK3B,EAC5CtF,KAAKgE,OAAO9B,EAAayE,EAAcO,GAAKJ,EAC5C9G,KAAKgE,OAAO9B,EAAayE,EAAcQ,GAAKJ,EAC5C/G,KAAKgE,OAAO9B,EAAayE,EAAcS,GAAKJ,GAGhD,YAAAzG,MAAA,SAAOC,EAAoBC,EAAkBC,EAAcC,EAAsBC,EAAeC,EAAiBC,GAC7G,IAAIuG,EAAO7G,EAAS8G,MAAMtH,KAAK6G,WAC/B,GAAKQ,EAAK9C,KAAKE,OAAf,CACA,IAAIT,EAAShE,KAAKgE,OAClB,GAAItD,EAAOsD,EAAO,GACd,OAAQnD,GACJ,KAAKpB,EAASiF,MAEV,YADA2C,EAAKT,MAAMW,aAAaF,EAAKzC,KAAKgC,OAEtC,KAAKnH,EAASoF,MACV,IAAI+B,EAAQS,EAAKT,MAAOlC,EAAQ2C,EAAKzC,KAAKgC,MAC1CA,EAAM3B,KAAKP,EAAMY,EAAIsB,EAAMtB,GAAK1E,GAAQ8D,EAAMoC,EAAIF,EAAME,GAAKlG,GAAQ8D,EAAMqC,EAAIH,EAAMG,GAAKnG,GACrF8D,EAAMsC,EAAIJ,EAAMI,GAAKpG,OARtC,CAaA,IAAI0E,EAAI,EAAGwB,EAAI,EAAGC,EAAI,EAAGC,EAAI,EAC7B,GAAItG,GAAQsD,EAAOA,EAAO7D,OAASwG,EAAc7B,SAAU,CACvD,IAAI5E,EAAI8D,EAAO7D,OACfmF,EAAItB,EAAO9D,EAAIyG,EAAca,QAC7BV,EAAI9C,EAAO9D,EAAIyG,EAAcc,QAC7BV,EAAI/C,EAAO9D,EAAIyG,EAAce,QAC7BV,EAAIhD,EAAO9D,EAAIyG,EAAcgB,YAC1B,CAEH,IAAIzC,EAAQzD,EAAUT,aAAagD,EAAQtD,EAAMiG,EAAc7B,SAC/DQ,EAAItB,EAAOkB,EAAQyB,EAAca,QACjCV,EAAI9C,EAAOkB,EAAQyB,EAAcc,QACjCV,EAAI/C,EAAOkB,EAAQyB,EAAce,QACjCV,EAAIhD,EAAOkB,EAAQyB,EAAcgB,QACjC,IAAIvC,EAAYpB,EAAOkB,GACnBxB,EAAU1D,KAAKyD,gBAAgByB,EAAQyB,EAAc7B,QAAU,EAC/D,GAAKpE,EAAO0E,IAAcpB,EAAOkB,EAAQyB,EAActB,WAAaD,IAExEE,IAAMtB,EAAOkB,EAAQyB,EAAcM,GAAK3B,GAAK5B,EAC7CoD,IAAM9C,EAAOkB,EAAQyB,EAAcO,GAAKJ,GAAKpD,EAC7CqD,IAAM/C,EAAOkB,EAAQyB,EAAcQ,GAAKJ,GAAKrD,EAC7CsD,IAAMhD,EAAOkB,EAAQyB,EAAcS,GAAKJ,GAAKtD,EAEjD,GAAa,GAAT9C,EACAyG,EAAKT,MAAMgB,IAAItC,EAAGwB,EAAGC,EAAGC,OACvB,CACGJ,EAAQS,EAAKT,MACb/F,GAASpB,EAASiF,OAAOkC,EAAMW,aAAaF,EAAKzC,KAAKgC,OAC1DA,EAAM3B,KAAKK,EAAIsB,EAAMtB,GAAK1E,GAAQkG,EAAIF,EAAME,GAAKlG,GAAQmG,EAAIH,EAAMG,GAAKnG,GAAQoG,EAAIJ,EAAMI,GAAKpG,OA1EhG,EAAAkE,QAAU,EACV,EAAAO,WAAa,EAAU,EAAAmC,QAAU,EAAU,EAAAC,QAAU,EAAU,EAAAC,QAAU,EAAU,EAAAC,QAAU,EAC7F,EAAAV,EAAI,EAAU,EAAAC,EAAI,EAAU,EAAAC,EAAI,EAAU,EAAAC,EAAI,EA2EzD,EA9EA,CAAmCtF,GAAtB,EAAA6E,cAAa,EAiF1B,kBAaI,WAAajF,GAAb,MACI,YAAMA,IAAW,K,OACjB,EAAKsC,OAAS,EAAApC,MAAMC,cAAcH,EAAamG,EAAiB/C,S,EAoFxE,OAnGsC,OAkBlC,YAAA1E,cAAA,WACI,OAAQT,EAAamI,UAAY,IAAM9H,KAAK6G,WAIhD,YAAA1C,SAAA,SAAUjC,EAAoBxB,EAAc4E,EAAWwB,EAAWC,EAAWC,EAAWe,EAAYC,EAAYC,GAC5G/F,GAAc2F,EAAiB/C,QAC/B9E,KAAKgE,OAAO9B,GAAcxB,EAC1BV,KAAKgE,OAAO9B,EAAa2F,EAAiBZ,GAAK3B,EAC/CtF,KAAKgE,OAAO9B,EAAa2F,EAAiBX,GAAKJ,EAC/C9G,KAAKgE,OAAO9B,EAAa2F,EAAiBV,GAAKJ,EAC/C/G,KAAKgE,OAAO9B,EAAa2F,EAAiBT,GAAKJ,EAC/ChH,KAAKgE,OAAO9B,EAAa2F,EAAiBK,IAAMH,EAChD/H,KAAKgE,OAAO9B,EAAa2F,EAAiBM,IAAMH,EAChDhI,KAAKgE,OAAO9B,EAAa2F,EAAiBO,IAAMH,GAGpD,YAAA1H,MAAA,SAAOC,EAAoBC,EAAkBC,EAAcC,EAAsBC,EAAeC,EAAiBC,GAC7G,IAAIuG,EAAO7G,EAAS8G,MAAMtH,KAAK6G,WAC/B,GAAKQ,EAAK9C,KAAKE,OAAf,CACA,IAAIT,EAAShE,KAAKgE,OAClB,GAAItD,EAAOsD,EAAO,GACd,OAAQnD,GACJ,KAAKpB,EAASiF,MAGV,OAFA2C,EAAKT,MAAMW,aAAaF,EAAKzC,KAAKgC,YAClCS,EAAKgB,UAAUd,aAAaF,EAAKzC,KAAKyD,WAE1C,KAAK5I,EAASoF,MACV,IAAIyD,EAAQjB,EAAKT,MAAO2B,EAAOlB,EAAKgB,UAAWG,EAAanB,EAAKzC,KAAKgC,MAAO6B,EAAYpB,EAAKzC,KAAKyD,UACnGC,EAAMrD,KAAKuD,EAAWlD,EAAIgD,EAAMhD,GAAK1E,GAAQ4H,EAAW1B,EAAIwB,EAAMxB,GAAKlG,GAAQ4H,EAAWzB,EAAIuB,EAAMvB,GAAKnG,GACpG4H,EAAWxB,EAAIsB,EAAMtB,GAAKpG,GAC/B2H,EAAKtD,KAAKwD,EAAUnD,EAAIiD,EAAKjD,GAAK1E,GAAQ6H,EAAU3B,EAAIyB,EAAKzB,GAAKlG,GAAQ6H,EAAU1B,EAAIwB,EAAKxB,GAAKnG,EAAO,OAVrH,CAeA,IAAI0E,EAAI,EAAGwB,EAAI,EAAGC,EAAI,EAAGC,EAAI,EAAGe,EAAK,EAAGC,EAAK,EAAGC,EAAK,EACrD,GAAIvH,GAAQsD,EAAOA,EAAO7D,OAAS0H,EAAiB/C,SAAU,CAC1D,IAAI5E,EAAI8D,EAAO7D,OACfmF,EAAItB,EAAO9D,EAAI2H,EAAiBL,QAChCV,EAAI9C,EAAO9D,EAAI2H,EAAiBJ,QAChCV,EAAI/C,EAAO9D,EAAI2H,EAAiBH,QAChCV,EAAIhD,EAAO9D,EAAI2H,EAAiBF,QAChCI,EAAK/D,EAAO9D,EAAI2H,EAAiBa,SACjCV,EAAKhE,EAAO9D,EAAI2H,EAAiBc,SACjCV,EAAKjE,EAAO9D,EAAI2H,EAAiBe,aAC9B,CAEH,IAAI1D,EAAQzD,EAAUT,aAAagD,EAAQtD,EAAMmH,EAAiB/C,SAClEQ,EAAItB,EAAOkB,EAAQ2C,EAAiBL,QACpCV,EAAI9C,EAAOkB,EAAQ2C,EAAiBJ,QACpCV,EAAI/C,EAAOkB,EAAQ2C,EAAiBH,QACpCV,EAAIhD,EAAOkB,EAAQ2C,EAAiBF,QACpCI,EAAK/D,EAAOkB,EAAQ2C,EAAiBa,SACrCV,EAAKhE,EAAOkB,EAAQ2C,EAAiBc,SACrCV,EAAKjE,EAAOkB,EAAQ2C,EAAiBe,SACrC,IAAIxD,EAAYpB,EAAOkB,GACnBxB,EAAU1D,KAAKyD,gBAAgByB,EAAQ2C,EAAiB/C,QAAU,EAClE,GAAKpE,EAAO0E,IAAcpB,EAAOkB,EAAQ2C,EAAiBxC,WAAaD,IAE3EE,IAAMtB,EAAOkB,EAAQ2C,EAAiBZ,GAAK3B,GAAK5B,EAChDoD,IAAM9C,EAAOkB,EAAQ2C,EAAiBX,GAAKJ,GAAKpD,EAChDqD,IAAM/C,EAAOkB,EAAQ2C,EAAiBV,GAAKJ,GAAKrD,EAChDsD,IAAMhD,EAAOkB,EAAQ2C,EAAiBT,GAAKJ,GAAKtD,EAChDqE,IAAO/D,EAAOkB,EAAQ2C,EAAiBK,IAAMH,GAAMrE,EACnDsE,IAAOhE,EAAOkB,EAAQ2C,EAAiBM,IAAMH,GAAMtE,EACnDuE,IAAOjE,EAAOkB,EAAQ2C,EAAiBO,IAAMH,GAAMvE,EAEvD,GAAa,GAAT9C,EACAyG,EAAKT,MAAMgB,IAAItC,EAAGwB,EAAGC,EAAGC,GACxBK,EAAKgB,UAAUT,IAAIG,EAAIC,EAAIC,EAAI,OAC5B,CACCK,EAAQjB,EAAKT,MAAO2B,EAAOlB,EAAKgB,UAChCxH,GAASpB,EAASiF,QAClB4D,EAAMf,aAAaF,EAAKzC,KAAKgC,OAC7B2B,EAAKhB,aAAaF,EAAKzC,KAAKyD,YAEhCC,EAAMrD,KAAKK,EAAIgD,EAAMhD,GAAK1E,GAAQkG,EAAIwB,EAAMxB,GAAKlG,GAAQmG,EAAIuB,EAAMvB,GAAKnG,GAAQoG,EAAIsB,EAAMtB,GAAKpG,GAC/F2H,EAAKtD,KAAK8C,EAAKQ,EAAKjD,GAAK1E,GAAQoH,EAAKO,EAAKzB,GAAKlG,GAAQqH,EAAKM,EAAKxB,GAAKnG,EAAO,OA/F/E,EAAAkE,QAAU,EACV,EAAAO,WAAa,EAAU,EAAAmC,QAAU,EAAU,EAAAC,QAAU,EAAU,EAAAC,QAAU,EAAU,EAAAC,QAAU,EAC7F,EAAAe,SAAW,EAAU,EAAAC,SAAW,EAAU,EAAAC,SAAW,EACrD,EAAA3B,EAAI,EAAU,EAAAC,EAAI,EAAU,EAAAC,EAAI,EAAU,EAAAC,EAAI,EAAU,EAAAc,GAAK,EAAU,EAAAC,GAAK,EAAU,EAAAC,GAAK,EA+FtG,EAnGA,CAAsCtG,GAAzB,EAAA+F,iBAAgB,EAsG7B,iBAUI,WAAanG,GACT1B,KAAKgE,OAAS,EAAApC,MAAMC,cAAcH,GAClC1B,KAAK6I,gBAAkB,IAAIC,MAAcpH,GA+CjD,OA5CI,YAAAtB,cAAA,WACI,OAAQT,EAAaoJ,YAAc,IAAM/I,KAAK6G,WAIlD,YAAA7E,cAAA,WACI,OAAOhC,KAAKgE,OAAO7D,QAIvB,YAAAgE,SAAA,SAAUjC,EAAoBxB,EAAcsI,GACxChJ,KAAKgE,OAAO9B,GAAcxB,EAC1BV,KAAK6I,gBAAgB3G,GAAc8G,GAGvC,YAAAzI,MAAA,SAAOC,EAAoBC,EAAkBC,EAAcC,EAAsBC,EAAeC,EAAiBC,GAC7G,IAAIuG,EAAO7G,EAAS8G,MAAMtH,KAAK6G,WAC/B,GAAKQ,EAAK9C,KAAKE,OACf,GAAI3D,GAAapB,EAAayG,OAA9B,CAMA,IAAInC,EAAShE,KAAKgE,OAClB,GAAItD,EAAOsD,EAAO,GACVnD,GAASpB,EAASiF,OAAS7D,GAASpB,EAASoF,OAAO7E,KAAKiJ,cAAczI,EAAU6G,EAAMA,EAAKzC,KAAKoE,oBADzG,CAKA,IAAI9G,EAAa,EAEbA,EADAxB,GAAQsD,EAAOA,EAAO7D,OAAS,GAClB6D,EAAO7D,OAAS,EAEhBsB,EAAUT,aAAagD,EAAQtD,EAAM,GAAK,EAE3D,IAAIsI,EAAiBhJ,KAAK6I,gBAAgB3G,GAC1C1B,EAAS8G,MAAMtH,KAAK6G,WACfoC,cAAgC,MAAlBD,EAAyB,KAAOxI,EAAS0I,cAAclJ,KAAK6G,UAAWmC,UAnBlFnI,GAASpB,EAASiF,OAClB1E,KAAKiJ,cAAczI,EAAU6G,EAAMA,EAAKzC,KAAKoE,iBAqBzD,YAAAC,cAAA,SAAczI,EAAoB6G,EAAY2B,GAC1C3B,EAAK0B,WAA+B,MAAlBC,EAAyB,KAAOxI,EAAS0I,cAAclJ,KAAK6G,UAAWmC,IAEjG,EA3DA,GAAa,EAAAG,mBAAkB,EA6D/B,IAAIC,EAA4B,KAGhC,cAaI,WAAa1H,GAAb,MACI,YAAMA,IAAW,K,OACjB,EAAKsC,OAAS,EAAApC,MAAMC,cAAcH,GAClC,EAAK2H,cAAgB,IAAIP,MAAyBpH,GACrC,MAAT0H,IAAeA,EAAQ,EAAAxH,MAAMC,cAAc,K,EA+LvD,OAhNoC,OAoBhC,YAAAzB,cAAA,WACI,OAAQT,EAAa2J,QAAU,MAAQtJ,KAAK+I,WAAWzI,GAAKN,KAAK6G,WAKrE,YAAA1C,SAAA,SAAUjC,EAAoBxB,EAAc6I,GACxCvJ,KAAKgE,OAAO9B,GAAcxB,EAC1BV,KAAKqJ,cAAcnH,GAAcqH,GAGrC,YAAAhJ,MAAA,SAAOC,EAAoBC,EAAkBC,EAAc8I,EAA2B5I,EAAeC,EAAiBC,GAClH,IAAIuG,EAAa7G,EAAS8G,MAAMtH,KAAK6G,WACrC,GAAKQ,EAAK9C,KAAKE,OAAf,CACA,IAAIgF,EAA6BpC,EAAK6B,gBACtC,GAAMO,aAA0B,EAAAC,kBAA0CD,EAAgBE,kBAAoB3J,KAAK+I,WAAnH,CAEA,IAAIa,EAA6BvC,EAAKiC,OACZ,GAAtBM,EAAYzJ,SAAaU,EAAQpB,EAASiF,OAE9C,IAAI2E,EAAgBrJ,KAAKqJ,cACrBQ,EAAcR,EAAc,GAAGlJ,OAE/B6D,EAAShE,KAAKgE,OAClB,GAAItD,EAAOsD,EAAO,GAAlB,CACI,IAAI8F,EAAqCL,EACzC,OAAQ5I,GACJ,KAAKpB,EAASiF,MAEV,YADAkF,EAAYzJ,OAAS,GAEzB,KAAKV,EAASoF,MACV,GAAa,GAATjE,EAAY,CACZgJ,EAAYzJ,OAAS,EACrB,MAEJ,IAAI,EAAwB,EAAAyB,MAAMmI,aAAaH,EAAaC,GAC5D,GAA8B,MAA1BC,EAAiBtF,MAGjB,IADA,IAAIwF,EAAgBF,EAAiBP,SAC5BrJ,EAAI,EAAGA,EAAI2J,EAAa3J,IAC7B,EAAOA,KAAO8J,EAAc9J,GAAK,EAAOA,IAAMU,MAC/C,CAEHA,EAAQ,EAAIA,EACZ,IAASV,EAAI,EAAGA,EAAI2J,EAAa3J,IAC7B,EAAOA,IAAMU,QArBjC,CA2BA,IAAI0I,EAAwB,EAAA1H,MAAMmI,aAAaH,EAAaC,GAC5D,GAAInJ,GAAQsD,EAAOA,EAAO7D,OAAS,GAAnC,CACI,IAAI8J,EAAeZ,EAAcrF,EAAO7D,OAAS,GACjD,GAAa,GAATS,EACA,GAAIC,GAASpB,EAASwF,IAElB,GAA8B,OAD1B6E,EAAmBL,GACFjF,MAEjB,CAAIwF,EAAgBF,EAAiBP,SACrC,IADA,IACS,EAAI,EAAG,EAAIM,EAAa,IAC7BP,EAAO,IAAMW,EAAa,GAAKD,EAAc,QAIjD,IAAK,IAAI,EAAI,EAAG,EAAIH,EAAa,IAC7BP,EAAO,IAAMW,EAAa,QAGlC,EAAArI,MAAMsI,UAAUD,EAAc,EAAGX,EAAQ,EAAGO,QAGhD,OAAQhJ,GACJ,KAAKpB,EAASiF,MACV,IAAI,EAAmB+E,EACvB,GAA8B,MAA1B,EAAiBjF,MAEjB,CAAIwF,EAAgB,EAAiBT,SACrC,IADA,IACS,EAAI,EAAG,EAAIM,EAAa,IAAK,CAClC,IAAInF,EAAQsF,EAAc,GAC1BV,EAAO,GAAK5E,GAASuF,EAAa,GAAKvF,GAAS9D,QAIpD,IAAK,IAAI,EAAI,EAAG,EAAIiJ,EAAa,IAC7BP,EAAO,GAAKW,EAAa,GAAKrJ,EAEtC,MAEJ,KAAKnB,EAASoF,MACd,KAAKpF,EAASuF,QACV,IAAK,IAAI,EAAI,EAAG,EAAI6E,EAAa,IAC7BP,EAAO,KAAOW,EAAa,GAAKX,EAAO,IAAM1I,EACjD,MACJ,KAAKnB,EAASwF,IAEV,GAA8B,OAD1B6E,EAAmBL,GACFjF,MAEjB,CAAIwF,EAAgBF,EAAiBP,SACrC,IADA,IACS,EAAI,EAAG,EAAIM,EAAa,IAC7BP,EAAO,KAAOW,EAAa,GAAKD,EAAc,IAAMpJ,OAIxD,IAAK,IAAI,EAAI,EAAG,EAAIiJ,EAAa,IAC7BP,EAAO,IAAMW,EAAa,GAAKrJ,OArDvD,CA6DA,IAAIsE,EAAQzD,EAAUT,aAAagD,EAAQtD,GACvCyJ,EAAed,EAAcnE,EAAQ,GACrCkF,EAAef,EAAcnE,GAC7BE,EAAYpB,EAAOkB,GACnBxB,EAAU1D,KAAKyD,gBAAgByB,EAAQ,EAAG,GAAKxE,EAAO0E,IAAcpB,EAAOkB,EAAQ,GAAKE,IAE5F,GAAa,GAATxE,EACA,GAAIC,GAASpB,EAASwF,IAElB,GAA8B,OAD1B6E,EAAmBL,GACFjF,MAEjB,CAAIwF,EAAgBF,EAAiBP,SACrC,IADA,IACS,EAAI,EAAG,EAAIM,EAAa,IAAK,CAClC,IAAIQ,EAAOF,EAAa,GACxBb,EAAO,IAAMe,GAAQD,EAAa,GAAKC,GAAQ3G,EAAUsG,EAAc,SAI3E,IAAK,IAAI,EAAI,EAAG,EAAIH,EAAa,IAAK,CAC9BQ,EAAOF,EAAa,GACxBb,EAAO,IAAMe,GAAQD,EAAa,GAAKC,GAAQ3G,OAIvD,IAAK,IAAI,EAAI,EAAG,EAAImG,EAAa,IAAK,CAC9BQ,EAAOF,EAAa,GACxBb,EAAO,GAAKe,GAAQD,EAAa,GAAKC,GAAQ3G,OAItD,OAAQ7C,GACJ,KAAKpB,EAASiF,MACV,IAAI,EAAmB+E,EACvB,GAA8B,MAA1B,EAAiBjF,MAEjB,CAAIwF,EAAgB,EAAiBT,SACrC,IADA,IACS,EAAI,EAAG,EAAIM,EAAa,IAAK,CAC9BQ,EAAOF,EAAa,GAAIzF,EAAQsF,EAAc,GAClDV,EAAO,GAAK5E,GAAS2F,GAAQD,EAAa,GAAKC,GAAQ3G,EAAUgB,GAAS9D,QAI9E,IAAK,IAAI,EAAI,EAAG,EAAIiJ,EAAa,IAAK,CAC9BQ,EAAOF,EAAa,GACxBb,EAAO,IAAMe,GAAQD,EAAa,GAAKC,GAAQ3G,GAAW9C,EAGlE,MAEJ,KAAKnB,EAASoF,MACd,KAAKpF,EAASuF,QACV,IAAK,IAAI,EAAI,EAAG,EAAI6E,EAAa,IAAK,CAC9BQ,EAAOF,EAAa,GACxBb,EAAO,KAAOe,GAAQD,EAAa,GAAKC,GAAQ3G,EAAU4F,EAAO,IAAM1I,EAE3E,MACJ,KAAKnB,EAASwF,IAEV,GAA8B,OAD1B6E,EAAmBL,GACFjF,MAEjB,CAAIwF,EAAgBF,EAAiBP,SACrC,IADA,IACS,EAAI,EAAG,EAAIM,EAAa,IAAK,CAC9BQ,EAAOF,EAAa,GACxBb,EAAO,KAAOe,GAAQD,EAAa,GAAKC,GAAQ3G,EAAUsG,EAAc,IAAMpJ,QAIlF,IAAK,IAAI,EAAI,EAAG,EAAIiJ,EAAa,IAAK,CAC9BQ,EAAOF,EAAa,GACxBb,EAAO,KAAOe,GAAQD,EAAa,GAAKC,GAAQ3G,GAAW9C,SAMvF,EAhNA,CAAoCkB,GAAvB,EAAAwI,eAAc,EAmN3B,iBAOI,WAAa5I,GACT1B,KAAKgE,OAAS,EAAApC,MAAMC,cAAcH,GAClC1B,KAAKW,OAAS,IAAImI,MAAapH,GA6CvC,OA1CI,YAAAtB,cAAA,WACI,OAAOT,EAAa4K,OAAS,IAIjC,YAAAvI,cAAA,WACI,OAAOhC,KAAKgE,OAAO7D,QAIvB,YAAAgE,SAAA,SAAUjC,EAAoBqI,GAC1BvK,KAAKgE,OAAO9B,GAAcqI,EAAM7J,KAChCV,KAAKW,OAAOuB,GAAcqI,GAI9B,YAAAhK,MAAA,SAAOC,EAAoBC,EAAkBC,EAAc8I,EAA2B5I,EAAeC,EAAiBC,GAClH,GAAmB,MAAf0I,EAAJ,CACA,IAAIxF,EAAShE,KAAKgE,OACdtC,EAAa1B,KAAKgE,OAAO7D,OAE7B,GAAIM,EAAWC,EACXV,KAAKO,MAAMC,EAAUC,EAAU+J,OAAOC,UAAWjB,EAAa5I,EAAOC,EAAOC,GAC5EL,GAAY,OACT,GAAIA,GAAYuD,EAAOtC,EAAa,GACvC,OACJ,KAAIhB,EAAOsD,EAAO,IAAlB,CAEA,IAAIkB,EAAQ,EACZ,GAAIzE,EAAWuD,EAAO,GAClBkB,EAAQ,OAIR,IADA,IAAIE,EAAYpB,EADhBkB,EAAQzD,EAAUT,aAAagD,EAAQvD,IAEhCyE,EAAQ,GACPlB,EAAOkB,EAAQ,IAAME,GACzBF,IAGR,KAAOA,EAAQxD,GAAchB,GAAQsD,EAAOkB,GAAQA,IAChDsE,EAAYkB,KAAK1K,KAAKW,OAAOuE,OAEzC,EAtDA,GAAa,EAAAyF,cAAa,EAyD1B,iBAOI,WAAajJ,GACT1B,KAAKgE,OAAS,EAAApC,MAAMC,cAAcH,GAClC1B,KAAK4K,WAAa,IAAI9B,MAAqBpH,GAgDnD,OA7CI,YAAAtB,cAAA,WACI,OAAOT,EAAakL,WAAa,IAIrC,YAAA7I,cAAA,WACI,OAAOhC,KAAKgE,OAAO7D,QAMvB,YAAAgE,SAAA,SAAUjC,EAAoBxB,EAAcmK,GACxC7K,KAAKgE,OAAO9B,GAAcxB,EAC1BV,KAAK4K,WAAW1I,GAAc2I,GAGlC,YAAAtK,MAAA,SAAOC,EAAoBC,EAAkBC,EAAc8I,EAA2B5I,EAAeC,EAAiBC,GAClH,IAAI+J,EAAyBrK,EAASqK,UAClCvD,EAAqB9G,EAAS8G,MAClC,GAAIxG,GAAapB,EAAayG,QAAUtF,GAASpB,EAASiF,MAA1D,CAKA,IAAIV,EAAShE,KAAKgE,OAClB,GAAItD,EAAOsD,EAAO,GACVnD,GAASpB,EAASiF,OAAS7D,GAASpB,EAASoF,OAAO,EAAAjD,MAAMsI,UAAU1J,EAAS8G,MAAO,EAAG9G,EAASqK,UAAW,EAAGrK,EAAS8G,MAAMnH,YADrI,CAKA,IAAI+E,EAAQ,EAERA,EADAxE,GAAQsD,EAAOA,EAAO7D,OAAS,GACvB6D,EAAO7D,OAAS,EAEhBsB,EAAUT,aAAagD,EAAQtD,GAAQ,EAEnD,IAAIoK,EAAwB9K,KAAK4K,WAAW1F,GAC5C,GAA6B,MAAzB4F,EACA,EAAAlJ,MAAMsI,UAAU5C,EAAO,EAAGuD,EAAW,EAAGvD,EAAMnH,aAE9C,IAAK,IAAID,EAAI,EAAGa,EAAI+J,EAAsB3K,OAAQD,EAAIa,EAAGb,IACrD2K,EAAU3K,GAAKoH,EAAMwD,EAAsB5K,UArB/C,EAAA0B,MAAMsI,UAAU1J,EAAS8G,MAAO,EAAG9G,EAASqK,UAAW,EAAGrK,EAAS8G,MAAMnH,SAwBrF,EAzDA,GAAa,EAAA4K,kBAAiB,EA6D9B,kBAWI,WAAarJ,GAAb,MACI,YAAMA,IAAW,K,OACjB,EAAKsC,OAAS,EAAApC,MAAMC,cAAcH,EAAasJ,EAAqBlG,S,EAkG5E,OA/G0C,OAgBtC,YAAA1E,cAAA,WACI,OAAQT,EAAasL,cAAgB,IAAMjL,KAAKkL,mBAIpD,YAAA/G,SAAA,SAAUjC,EAAoBxB,EAAcyK,EAAaC,EAAkBC,EAAuBC,EAAmBC,GACjHrJ,GAAc8I,EAAqBlG,QACnC9E,KAAKgE,OAAO9B,GAAcxB,EAC1BV,KAAKgE,OAAO9B,EAAa8I,EAAqBQ,KAAOL,EACrDnL,KAAKgE,OAAO9B,EAAa8I,EAAqBS,UAAYL,EAC1DpL,KAAKgE,OAAO9B,EAAa8I,EAAqBU,gBAAkBL,EAChErL,KAAKgE,OAAO9B,EAAa8I,EAAqBW,UAAYL,EAAW,EAAI,EACzEtL,KAAKgE,OAAO9B,EAAa8I,EAAqBY,SAAWL,EAAU,EAAI,GAG3E,YAAAhL,MAAA,SAAOC,EAAoBC,EAAkBC,EAAc8I,EAA2B5I,EAAeC,EAAiBC,GAClH,IAAIkD,EAAShE,KAAKgE,OACd6H,EAA2BrL,EAASsL,cAAc9L,KAAKkL,mBAC3D,GAAKW,EAAWpH,OAChB,GAAI/D,EAAOsD,EAAO,GACd,OAAQnD,GACJ,KAAKpB,EAASiF,MAMV,OALAmH,EAAWV,IAAMU,EAAWjH,KAAKuG,IACjCU,EAAWT,SAAWS,EAAWjH,KAAKwG,SACtCS,EAAWR,cAAgBQ,EAAWjH,KAAKyG,cAC3CQ,EAAWP,SAAWO,EAAWjH,KAAK0G,cACtCO,EAAWN,QAAUM,EAAWjH,KAAK2G,SAEzC,KAAK9L,EAASoF,MACVgH,EAAWV,MAAQU,EAAWjH,KAAKuG,IAAMU,EAAWV,KAAOvK,EAC3DiL,EAAWT,WAAaS,EAAWjH,KAAKwG,SAAWS,EAAWT,UAAYxK,EAC1EiL,EAAWR,cAAgBQ,EAAWjH,KAAKyG,cAC3CQ,EAAWP,SAAWO,EAAWjH,KAAK0G,SACtCO,EAAWN,QAAUM,EAAWjH,KAAK2G,aAKjD,GAAI7K,GAAQsD,EAAOA,EAAO7D,OAAS6K,EAAqBlG,SAChDjE,GAASpB,EAASiF,OAClBmH,EAAWV,IAAMU,EAAWjH,KAAKuG,KAAOnH,EAAOA,EAAO7D,OAAS6K,EAAqBe,UAAYF,EAAWjH,KAAKuG,KAAOvK,EACvHiL,EAAWT,SAAWS,EAAWjH,KAAKwG,UAC/BpH,EAAOA,EAAO7D,OAAS6K,EAAqBgB,eAAiBH,EAAWjH,KAAKwG,UAAYxK,EAC5FE,GAAapB,EAAayG,QAC1B0F,EAAWR,cAAgBQ,EAAWjH,KAAKyG,cAC3CQ,EAAWP,SAAWO,EAAWjH,KAAK0G,SACtCO,EAAWN,QAAUM,EAAWjH,KAAK2G,UAErCM,EAAWR,cAAgBrH,EAAOA,EAAO7D,OAAS6K,EAAqBiB,qBACvEJ,EAAWP,SAAyE,GAA9DtH,EAAOA,EAAO7D,OAAS6K,EAAqBkB,eAClEL,EAAWN,QAAuE,GAA7DvH,EAAOA,EAAO7D,OAAS6K,EAAqBmB,iBAGrEN,EAAWV,MAAQnH,EAAOA,EAAO7D,OAAS6K,EAAqBe,UAAYF,EAAWV,KAAOvK,EAC7FiL,EAAWT,WAAapH,EAAOA,EAAO7D,OAAS6K,EAAqBgB,eAAiBH,EAAWT,UAAYxK,EACxGE,GAAapB,EAAa0M,QAC1BP,EAAWR,cAAgBrH,EAAOA,EAAO7D,OAAS6K,EAAqBiB,qBACvEJ,EAAWP,SAAyE,GAA9DtH,EAAOA,EAAO7D,OAAS6K,EAAqBkB,eAClEL,EAAWN,QAAuE,GAA7DvH,EAAOA,EAAO7D,OAAS6K,EAAqBmB,oBApB7E,CA2BA,IAAIjH,EAAQzD,EAAUT,aAAagD,EAAQtD,EAAMsK,EAAqBlG,SAClEqG,EAAMnH,EAAOkB,EAAQ8F,EAAqBe,UAC1CX,EAAWpH,EAAOkB,EAAQ8F,EAAqBgB,eAC/C5G,EAAYpB,EAAOkB,GACnBxB,EAAU1D,KAAKyD,gBAAgByB,EAAQ8F,EAAqBlG,QAAU,EACtE,GAAKpE,EAAO0E,IAAcpB,EAAOkB,EAAQ8F,EAAqB3F,WAAaD,IAE3EvE,GAASpB,EAASiF,OAClBmH,EAAWV,IAAMU,EAAWjH,KAAKuG,KAAOA,GAAOnH,EAAOkB,EAAQ8F,EAAqBQ,KAAOL,GAAOzH,EAAUmI,EAAWjH,KAAKuG,KAAOvK,EAClIiL,EAAWT,SAAWS,EAAWjH,KAAKwG,UAC/BA,GAAYpH,EAAOkB,EAAQ8F,EAAqBS,UAAYL,GAAY1H,EAAUmI,EAAWjH,KAAKwG,UAAYxK,EACjHE,GAAapB,EAAayG,QAC1B0F,EAAWR,cAAgBQ,EAAWjH,KAAKyG,cAC3CQ,EAAWP,SAAWO,EAAWjH,KAAK0G,SACtCO,EAAWN,QAAUM,EAAWjH,KAAK2G,UAErCM,EAAWR,cAAgBrH,EAAOkB,EAAQ8F,EAAqBiB,qBAC/DJ,EAAWP,SAAiE,GAAtDtH,EAAOkB,EAAQ8F,EAAqBkB,eAC1DL,EAAWN,QAA+D,GAArDvH,EAAOkB,EAAQ8F,EAAqBmB,iBAG7DN,EAAWV,MAAQA,GAAOnH,EAAOkB,EAAQ8F,EAAqBQ,KAAOL,GAAOzH,EAAUmI,EAAWV,KAAOvK,EACxGiL,EAAWT,WAAaA,GAAYpH,EAAOkB,EAAQ8F,EAAqBS,UAAYL,GAAY1H,EAAUmI,EAAWT,UAAYxK,EAC7HE,GAAapB,EAAa0M,QAC1BP,EAAWR,cAAgBrH,EAAOkB,EAAQ8F,EAAqBiB,qBAC/DJ,EAAWP,SAAiE,GAAtDtH,EAAOkB,EAAQ8F,EAAqBkB,eAC1DL,EAAWN,QAA+D,GAArDvH,EAAOkB,EAAQ8F,EAAqBmB,kBA1G9D,EAAArH,QAAU,EACV,EAAAO,WAAa,EAAU,EAAA0G,UAAY,EAAU,EAAAC,eAAiB,EAAU,EAAAC,qBAAuB,EAAU,EAAAC,eAAiB,EAAU,EAAAC,cAAgB,EACpJ,EAAAX,IAAM,EAAU,EAAAC,SAAW,EAAU,EAAAC,eAAiB,EAAU,EAAAC,SAAW,EAAU,EAAAC,QAAU,EA4G1G,EA/GA,CAA0C9J,GAA7B,EAAAkJ,qBAAoB,EAmHjC,kBAWI,WAAatJ,GAAb,MACI,YAAMA,IAAW,K,OACjB,EAAKsC,OAAS,EAAApC,MAAMC,cAAcH,EAAa2K,EAA4BvH,S,EA4EnF,OAzFiD,OAgB7C,YAAA1E,cAAA,WACI,OAAQT,EAAa2M,qBAAuB,IAAMtM,KAAKuM,0BAI3D,YAAApI,SAAA,SAAUjC,EAAoBxB,EAAc8L,EAAmBC,EAAsBC,EAAkBC,GACnGzK,GAAcmK,EAA4BvH,QAC1C9E,KAAKgE,OAAO9B,GAAcxB,EAC1BV,KAAKgE,OAAO9B,EAAamK,EAA4BO,QAAUJ,EAC/DxM,KAAKgE,OAAO9B,EAAamK,EAA4BQ,WAAaJ,EAClEzM,KAAKgE,OAAO9B,EAAamK,EAA4BS,OAASJ,EAC9D1M,KAAKgE,OAAO9B,EAAamK,EAA4BU,OAASJ,GAGlE,YAAApM,MAAA,SAAOC,EAAoBC,EAAkBC,EAAc8I,EAA2B5I,EAAeC,EAAiBC,GAClH,IAAIkD,EAAShE,KAAKgE,OAEd6H,EAAkCrL,EAASwM,qBAAqBhN,KAAKuM,0BACzE,GAAKV,EAAWpH,OAChB,GAAI/D,EAAOsD,EAAO,GAAlB,CACI,IAAIY,EAAOiH,EAAWjH,KACtB,OAAQ/D,GACJ,KAAKpB,EAASiF,MAKV,OAJAmH,EAAWW,UAAY5H,EAAK4H,UAC5BX,EAAWY,aAAe7H,EAAK6H,aAC/BZ,EAAWa,SAAW9H,EAAK8H,cAC3Bb,EAAWc,SAAW/H,EAAK+H,UAE/B,KAAKlN,EAASoF,MACVgH,EAAWW,YAAc5H,EAAK4H,UAAYX,EAAWW,WAAa5L,EAClEiL,EAAWY,eAAiB7H,EAAK6H,aAAeZ,EAAWY,cAAgB7L,EAC3EiL,EAAWa,WAAa9H,EAAK8H,SAAWb,EAAWa,UAAY9L,EAC/DiL,EAAWc,WAAa/H,EAAK+H,SAAWd,EAAWc,UAAY/L,OAb3E,CAkBA,IAAIqD,EAAS,EAAGuB,EAAY,EAAGK,EAAQ,EAAGU,EAAQ,EAClD,GAAI7F,GAAQsD,EAAOA,EAAO7D,OAASkM,EAA4BvH,SAAU,CACrE,IAAI5E,EAAI8D,EAAO7D,OACf8D,EAASD,EAAO9D,EAAImM,EAA4BY,aAChDzH,EAAYxB,EAAO9D,EAAImM,EAA4Ba,gBACnDrH,EAAQ7B,EAAO9D,EAAImM,EAA4Bc,YAC/C5G,EAAQvC,EAAO9D,EAAImM,EAA4Be,gBAC5C,CAEH,IAAIlI,EAAQzD,EAAUT,aAAagD,EAAQtD,EAAM2L,EAA4BvH,SAC7Eb,EAASD,EAAOkB,EAAQmH,EAA4BY,aACpDzH,EAAYxB,EAAOkB,EAAQmH,EAA4Ba,gBACvDrH,EAAQ7B,EAAOkB,EAAQmH,EAA4Bc,YACnD5G,EAAQvC,EAAOkB,EAAQmH,EAA4Be,YACnD,IAAIhI,EAAYpB,EAAOkB,GACnBxB,EAAU1D,KAAKyD,gBAAgByB,EAAQmH,EAA4BvH,QAAU,EAC7E,GAAKpE,EAAO0E,IAAcpB,EAAOkB,EAAQmH,EAA4BhH,WAAaD,IAEtFnB,IAAWD,EAAOkB,EAAQmH,EAA4BO,QAAU3I,GAAUP,EAC1E8B,IAAcxB,EAAOkB,EAAQmH,EAA4BQ,WAAarH,GAAa9B,EACnFmC,IAAU7B,EAAOkB,EAAQmH,EAA4BS,OAASjH,GAASnC,EACvE6C,IAAUvC,EAAOkB,EAAQmH,EAA4BU,OAASxG,GAAS7C,EAE3E,GAAI7C,GAASpB,EAASiF,MAAO,CACrBE,EAAOiH,EAAWjH,KACtBiH,EAAWW,UAAY5H,EAAK4H,WAAavI,EAASW,EAAK4H,WAAa5L,EACpEiL,EAAWY,aAAe7H,EAAK6H,cAAgBjH,EAAYZ,EAAK6H,cAAgB7L,EAChFiL,EAAWa,SAAW9H,EAAK8H,UAAY7G,EAAQjB,EAAK8H,UAAY9L,EAChEiL,EAAWc,SAAW/H,EAAK+H,UAAYpG,EAAQ3B,EAAK+H,UAAY/L,OAEhEiL,EAAWW,YAAcvI,EAAS4H,EAAWW,WAAa5L,EAC1DiL,EAAWY,eAAiBjH,EAAYqG,EAAWY,cAAgB7L,EACnEiL,EAAWa,WAAa7G,EAAQgG,EAAWa,UAAY9L,EACvDiL,EAAWc,WAAapG,EAAQsF,EAAWc,UAAY/L,IArFxD,EAAAkE,QAAU,EACV,EAAAO,WAAa,EAAU,EAAA4H,aAAe,EAAU,EAAAC,gBAAkB,EAAU,EAAAC,YAAc,EAAU,EAAAC,YAAc,EAClH,EAAAR,OAAS,EAAU,EAAAC,UAAY,EAAU,EAAAC,MAAQ,EAAU,EAAAC,MAAQ,EAsF9E,EAzFA,CAAiDjL,GAApC,EAAAuK,4BAA2B,EA4FxC,kBAWI,WAAa3K,GAAb,MACI,YAAMA,IAAW,K,OACjB,EAAKsC,OAAS,EAAApC,MAAMC,cAAcH,EAAa2L,EAA+BvI,S,EA+CtF,OA5DoD,OAgBhD,YAAA1E,cAAA,WACI,OAAQT,EAAa2N,wBAA0B,IAAMtN,KAAKuN,qBAI9D,YAAApJ,SAAA,SAAUjC,EAAoBxB,EAAc8M,GACxCtL,GAAcmL,EAA+BvI,QAC7C9E,KAAKgE,OAAO9B,GAAcxB,EAC1BV,KAAKgE,OAAO9B,EAAamL,EAA+BI,OAASD,GAGrE,YAAAjN,MAAA,SAAOC,EAAoBC,EAAkBC,EAAc8I,EAA2B5I,EAAeC,EAAiBC,GAClH,IAAIkD,EAAShE,KAAKgE,OACd6H,EAA6BrL,EAASkN,gBAAgB1N,KAAKuN,qBAC/D,GAAK1B,EAAWpH,OAChB,GAAI/D,EAAOsD,EAAO,GACd,OAAQnD,GACJ,KAAKpB,EAASiF,MAEV,YADAmH,EAAW8B,SAAW9B,EAAWjH,KAAK+I,UAE1C,KAAKlO,EAASoF,MACVgH,EAAW8B,WAAa9B,EAAWjH,KAAK+I,SAAW9B,EAAW8B,UAAY/M,MANtF,CAWA,IAAI+M,EAAW,EACf,GAAIjN,GAAQsD,EAAOA,EAAO7D,OAASkN,EAA+BvI,SAC9D6I,EAAW3J,EAAOA,EAAO7D,OAASkN,EAA+BO,gBAChE,CAED,IAAI1I,EAAQzD,EAAUT,aAAagD,EAAQtD,EAAM2M,EAA+BvI,SAChF6I,EAAW3J,EAAOkB,EAAQmI,EAA+BO,YACzD,IAAIxI,EAAYpB,EAAOkB,GACnBxB,EAAU1D,KAAKyD,gBAAgByB,EAAQmI,EAA+BvI,QAAU,EAChF,GAAKpE,EAAO0E,IAAcpB,EAAOkB,EAAQmI,EAA+BhI,WAAaD,IAEzFuI,IAAa3J,EAAOkB,EAAQmI,EAA+BI,OAASE,GAAYjK,EAEhF7C,GAASpB,EAASiF,MAClBmH,EAAW8B,SAAW9B,EAAWjH,KAAK+I,UAAYA,EAAW9B,EAAWjH,KAAK+I,UAAY/M,EAEzFiL,EAAW8B,WAAaA,EAAW9B,EAAW8B,UAAY/M,IAzD3D,EAAAkE,QAAU,EACV,EAAAO,WAAa,EAAU,EAAAuI,YAAc,EACrC,EAAAH,MAAQ,EAyDnB,EA5DA,CAAoD3L,GAAvC,EAAAuL,+BAA8B,EA+D3C,kBACI,WAAa3L,G,OACT,YAAMA,IAAW,KAyCzB,OA3CmD,OAK/C,YAAAtB,cAAA,WACI,OAAQT,EAAakO,uBAAyB,IAAM7N,KAAKuN,qBAG7D,YAAAhN,MAAA,SAAOC,EAAoBC,EAAkBC,EAAc8I,EAA2B5I,EAAeC,EAAiBC,GAClH,IAAIkD,EAAShE,KAAKgE,OACd6H,EAA6BrL,EAASkN,gBAAgB1N,KAAKuN,qBAC/D,GAAK1B,EAAWpH,OAChB,GAAI/D,EAAOsD,EAAO,GACd,OAAQnD,GACJ,KAAKpB,EAASiF,MAEV,YADAmH,EAAWiC,QAAUjC,EAAWjH,KAAKkJ,SAEzC,KAAKrO,EAASoF,MACVgH,EAAWiC,UAAYjC,EAAWjH,KAAKkJ,QAAUjC,EAAWiC,SAAWlN,MANnF,CAWA,IAAIkN,EAAU,EACd,GAAIpN,GAAQsD,EAAOA,EAAO7D,OAAS4N,EAA8BjJ,SAC7DgJ,EAAU9J,EAAOA,EAAO7D,OAAS4N,EAA8BH,gBAC9D,CAED,IAAI1I,EAAQzD,EAAUT,aAAagD,EAAQtD,EAAMqN,EAA8BjJ,SAC/EgJ,EAAU9J,EAAOkB,EAAQ6I,EAA8BH,YACvD,IAAIxI,EAAYpB,EAAOkB,GACnBxB,EAAU1D,KAAKyD,gBAAgByB,EAAQ6I,EAA8BjJ,QAAU,EAC/E,GAAKpE,EAAO0E,IAAcpB,EAAOkB,EAAQ6I,EAA8B1I,WAAaD,IAExF0I,IAAY9J,EAAOkB,EAAQ6I,EAA8BN,OAASK,GAAWpK,EAG7E7C,GAASpB,EAASiF,MAClBmH,EAAWiC,QAAUjC,EAAWjH,KAAKkJ,SAAWA,EAAUjC,EAAWjH,KAAKkJ,SAAWlN,EAErFiL,EAAWiC,UAAYA,EAAUjC,EAAWiC,SAAWlN,IAEnE,EA3CA,CAAmDyM,GAAtC,EAAAU,8BAA6B,EA+C1C,kBAWI,WAAarM,GAAb,MACI,YAAMA,IAAW,K,OACjB,EAAKsC,OAAS,EAAApC,MAAMC,cAAcH,EAAasM,EAA0BlJ,S,EAyDjF,OAtE+C,OAgB3C,YAAA1E,cAAA,WACI,OAAQT,EAAasO,mBAAqB,IAAMjO,KAAKuN,qBAIzD,YAAApJ,SAAA,SAAUjC,EAAoBxB,EAAc8L,EAAmBC,GAC3DvK,GAAc8L,EAA0BlJ,QACxC9E,KAAKgE,OAAO9B,GAAcxB,EAC1BV,KAAKgE,OAAO9B,EAAa8L,EAA0BpB,QAAUJ,EAC7DxM,KAAKgE,OAAO9B,EAAa8L,EAA0BnB,WAAaJ,GAGpE,YAAAlM,MAAA,SAAOC,EAAoBC,EAAkBC,EAAc8I,EAA2B5I,EAAeC,EAAiBC,GAClH,IAAIkD,EAAShE,KAAKgE,OACd6H,EAA6BrL,EAASkN,gBAAgB1N,KAAKuN,qBAC/D,GAAK1B,EAAWpH,OAChB,GAAI/D,EAAOsD,EAAO,GACd,OAAQnD,GACJ,KAAKpB,EAASiF,MAGV,OAFAmH,EAAWW,UAAYX,EAAWjH,KAAK4H,eACvCX,EAAWY,aAAeZ,EAAWjH,KAAK6H,cAE9C,KAAKhN,EAASoF,MACVgH,EAAWW,YAAcX,EAAWjH,KAAK4H,UAAYX,EAAWW,WAAa5L,EAC7EiL,EAAWY,eAAiBZ,EAAWjH,KAAK6H,aAAeZ,EAAWY,cAAgB7L,MARlG,CAaA,IAAIqD,EAAS,EAAGuB,EAAY,EAC5B,GAAI9E,GAAQsD,EAAOA,EAAO7D,OAAS6N,EAA0BlJ,SACzDb,EAASD,EAAOA,EAAO7D,OAAS6N,EAA0Bf,aAC1DzH,EAAYxB,EAAOA,EAAO7D,OAAS6N,EAA0Bd,oBAC1D,CAEH,IAAIhI,EAAQzD,EAAUT,aAAagD,EAAQtD,EAAMsN,EAA0BlJ,SAC3Eb,EAASD,EAAOkB,EAAQ8I,EAA0Bf,aAClDzH,EAAYxB,EAAOkB,EAAQ8I,EAA0Bd,gBACrD,IAAI9H,EAAYpB,EAAOkB,GACnBxB,EAAU1D,KAAKyD,gBAAgByB,EAAQ8I,EAA0BlJ,QAAU,EAC3E,GAAKpE,EAAO0E,IAAcpB,EAAOkB,EAAQ8I,EAA0B3I,WAAaD,IAEpFnB,IAAWD,EAAOkB,EAAQ8I,EAA0BpB,QAAU3I,GAAUP,EACxE8B,IAAcxB,EAAOkB,EAAQ8I,EAA0BnB,WAAarH,GAAa9B,EAGjF7C,GAASpB,EAASiF,OAClBmH,EAAWW,UAAYX,EAAWjH,KAAK4H,WAAavI,EAAS4H,EAAWjH,KAAK4H,WAAa5L,EAC1FiL,EAAWY,aAAeZ,EAAWjH,KAAK6H,cAAgBjH,EAAYqG,EAAWjH,KAAK6H,cAAgB7L,IAEtGiL,EAAWW,YAAcvI,EAAS4H,EAAWW,WAAa5L,EAC1DiL,EAAWY,eAAiBjH,EAAYqG,EAAWY,cAAgB7L,KAlEpE,EAAAkE,QAAU,EACV,EAAAO,WAAa,EAAU,EAAA4H,aAAe,EAAU,EAAAC,gBAAkB,EAClE,EAAAN,OAAS,EAAU,EAAAC,UAAY,EAmE1C,EAtEA,CAA+C/K,GAAlC,EAAAkM,0BAAyB,EA/6CrB,GAAAxO,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCCpB,SAAUA,IAAW,SAAAC,GAKjB,iBA8DI,WAAaoF,GAjBb,KAAAsJ,OAAS,IAAIpF,MAMb,KAAAqF,UAAY,EACZ,KAAAC,aAAe,EAEf,KAAAzN,OAAS,IAAImI,MACb,KAAAuF,UAAY,IAAIvF,MAChB,KAAAwF,MAAQ,IAAIC,EAAWvO,MACvB,KAAAwO,YAAc,IAAI,EAAAC,OAClB,KAAAC,mBAAoB,EAEpB,KAAAC,eAAiB,IAAI,EAAAC,MAAiB,WAAM,gBAGxC5O,KAAK4E,KAAOA,EAkwBpB,OA9vBI,YAAAxG,OAAA,SAAQyQ,GACJA,GAAS7O,KAAKmO,UAEd,IADA,IAAID,EAASlO,KAAKkO,OACThO,EAAI,EAAGa,EAAImN,EAAO/N,OAAQD,EAAIa,EAAGb,IAAK,CAC3C,IAAIoB,EAAU4M,EAAOhO,GACrB,GAAe,MAAXoB,EAAJ,CAEAA,EAAQwN,cAAgBxN,EAAQyN,kBAChCzN,EAAQ0N,UAAY1N,EAAQ2N,cAE5B,IAAIC,EAAeL,EAAQvN,EAAQ6M,UAEnC,GAAI7M,EAAQ6N,MAAQ,EAAG,CAEnB,GADA7N,EAAQ6N,OAASD,EACb5N,EAAQ6N,MAAQ,EAAG,SACvBD,GAAgB5N,EAAQ6N,MACxB7N,EAAQ6N,MAAQ,EAGpB,IAAIC,EAAO9N,EAAQ8N,KACnB,GAAY,MAARA,EAAc,CAEd,IAAIC,EAAW/N,EAAQ0N,UAAYI,EAAKD,MACxC,GAAIE,GAAY,EAAG,CAKf,IAJAD,EAAKD,MAAQ,EACbC,EAAKE,WAAkC,GAArBhO,EAAQ6M,UAAiB,GAAKkB,EAAW/N,EAAQ6M,UAAYU,GAASO,EAAKjB,UAC7F7M,EAAQgO,WAAaJ,EACrBlP,KAAKuP,WAAWrP,EAAGkP,GAAM,GACC,MAAnBA,EAAKI,YACRJ,EAAKK,SAAWZ,EAChBO,EAAOA,EAAKI,WAEhB,eAED,GAAIlO,EAAQ0N,WAAa1N,EAAQoO,UAAkC,MAAtBpO,EAAQkO,WAAoB,CAC5EtB,EAAOhO,GAAK,KACZF,KAAKsO,MAAMqB,IAAIrO,GACftB,KAAK4P,YAAYtO,GACjB,SAEJ,GAA0B,MAAtBA,EAAQkO,YAAsBxP,KAAK6P,iBAAiBvO,EAASuN,GAAQ,CAErE,IAAIiB,EAAOxO,EAAQkO,WAGnB,IAFAlO,EAAQkO,WAAa,KACT,MAARM,IAAcA,EAAKC,SAAW,MACnB,MAARD,GACH9P,KAAKsO,MAAMqB,IAAIG,GACfA,EAAOA,EAAKN,WAIpBlO,EAAQgO,WAAaJ,GAGzBlP,KAAKsO,MAAM0B,SAIf,YAAAH,iBAAA,SAAkBI,EAAgBpB,GAC9B,IAAIiB,EAAOG,EAAGT,WACd,GAAY,MAARM,EAAc,OAAO,EAEzB,IAAII,EAAWlQ,KAAK6P,iBAAiBC,EAAMjB,GAM3C,OAJAiB,EAAKhB,cAAgBgB,EAAKf,kBAC1Be,EAAKd,UAAYc,EAAKb,cAGlBgB,EAAGR,QAAU,GAAKQ,EAAGR,SAAWQ,EAAGE,aAEZ,GAAnBL,EAAKM,YAAqC,GAAlBH,EAAGE,cAC3BF,EAAGT,WAAaM,EAAKN,WACE,MAAnBM,EAAKN,aAAoBM,EAAKN,WAAWO,SAAWE,GACxDA,EAAGI,eAAiBP,EAAKO,eACzBrQ,KAAKsO,MAAMqB,IAAIG,IAEZI,IAGXJ,EAAKR,WAAaT,EAAQiB,EAAK3B,UAC/B8B,EAAGR,SAAWZ,GACP,IAMX,YAAAtO,MAAA,SAAOC,GACH,GAAgB,MAAZA,EAAkB,MAAM,IAAIT,MAAM,4BAClCC,KAAK0O,mBAAmB1O,KAAKsQ,qBAMjC,IAJA,IAAI3P,EAASX,KAAKW,OACduN,EAASlO,KAAKkO,OACdqC,GAAU,EAEL,EAAI,EAAG,EAAIrC,EAAO/N,OAAQ,EAAI,EAAG,IAAK,CAC3C,IAAImB,EAAU4M,EAAO,GACrB,KAAe,MAAX5M,GAAmBA,EAAQ6N,MAAQ,GAAvC,CACAoB,GAAU,EACV,IAAI1P,EAAuB,GAAL,EAAS,EAAApB,SAASoF,MAAQvD,EAAQkP,SAGpDrF,EAAM7J,EAAQV,MACQ,MAAtBU,EAAQkO,WACRrE,GAAOnL,KAAKyQ,gBAAgBnP,EAASd,EAAUK,GAC1CS,EAAQgO,WAAahO,EAAQoO,UAA4B,MAAhBpO,EAAQ8N,OACtDjE,EAAM,GAGV,IAAI2D,EAAgBxN,EAAQwN,cAAe4B,EAAgBpP,EAAQqP,mBAC/DC,EAAgBtP,EAAQxC,UAAUe,UAAUM,OAC5CN,EAAYyB,EAAQxC,UAAUe,UAClC,GAAU,GAAL,GAAiB,GAAPsL,GAAatK,GAAS,EAAApB,SAASwF,IAC1C,IAAK,IAAI4L,EAAK,EAAGA,EAAKD,EAAeC,IAAM,CAIvC,EAAAjP,MAAMkP,sBAAsB3F,EAAKtK,GACjC,IAAIkQ,EAAWlR,EAAUgR,GACrBE,aAAoB,EAAA5H,mBACpBnJ,KAAKgR,wBAAwBD,EAAUvQ,EAAUkQ,EAAe7P,GAAO,GAEvEkQ,EAASxQ,MAAMC,EAAUsO,EAAe4B,EAAe/P,EAAQwK,EAAKtK,EAAO,EAAAnB,aAAa0M,WAE7F,CACH,IAAI6E,EAAe3P,EAAQ2P,aAEvBC,EAAiD,GAApC5P,EAAQ6P,kBAAkBhR,OACvC+Q,GAAY,EAAAtP,MAAMmI,aAAazI,EAAQ6P,kBAAmBP,GAAiB,EAAG,MAClF,IAAIO,EAAoB7P,EAAQ6P,kBAEhC,IAASN,EAAK,EAAGA,EAAKD,EAAeC,IAAM,CACvC,IAAI,EAAWhR,EAAUgR,GACrBO,EAAgBH,EAAaJ,IAAQQ,EAAeC,WAAazQ,EAAQ,EAAApB,SAASiF,MAClF,aAAoB,EAAAL,eACpBrE,KAAKuR,oBAAoB,EAAU/Q,EAAUkQ,EAAevF,EAAKiG,EAAeD,EAAmBN,GAAM,EAAGK,GACrG,aAAoB,EAAA/H,mBAC3BnJ,KAAKgR,wBAAwB,EAAUxQ,EAAUkQ,EAAe7P,GAAO,IAGvE,EAAAe,MAAMkP,sBAAsB3F,EAAKtK,GACjC,EAASN,MAAMC,EAAUsO,EAAe4B,EAAe/P,EAAQwK,EAAKiG,EAAe,EAAA1R,aAAa0M,SAI5GpM,KAAKwR,YAAYlQ,EAASoP,GAC1B/P,EAAOR,OAAS,EAChBmB,EAAQyN,kBAAoB2B,EAC5BpP,EAAQ2N,cAAgB3N,EAAQgO,WAQpC,IAFA,IAAImC,EAAazR,KAAKoO,aAAeiD,EAAeK,MAChDpK,EAAQ9G,EAAS8G,MACZpH,EAAI,EAAGa,EAAIP,EAAS8G,MAAMnH,OAAQD,EAAIa,EAAGb,IAAK,CACnD,IAAImH,EAAOC,EAAMpH,GACjB,GAAImH,EAAKsK,iBAAmBF,EAAY,CACpC,IAAIzI,EAAiB3B,EAAKzC,KAAKoE,eAC/B3B,EAAK0B,WAAgC,MAAlBC,EAAyB,KAAOxI,EAAS0I,cAAc7B,EAAKzC,KAAKrC,MAAOyG,IAMnG,OAHAhJ,KAAKoO,cAAgB,EAErBpO,KAAKsO,MAAM0B,QACJO,GAGX,YAAAE,gBAAA,SAAiBR,EAAgBzP,EAAoBK,GACjD,IAAIiP,EAAOG,EAAGT,WACS,MAAnBM,EAAKN,YAAoBxP,KAAKyQ,gBAAgBX,EAAMtP,EAAUK,GAElE,IAAIsK,EAAM,EACY,GAAlB8E,EAAGE,aACHhF,EAAM,EACFtK,GAAS,EAAApB,SAASoF,QAAOhE,EAAQ,EAAApB,SAASiF,UAE9CyG,EAAM8E,EAAGR,QAAUQ,EAAGE,aACZ,IAAGhF,EAAM,GACftK,GAAS,EAAApB,SAASoF,QAAOhE,EAAQiP,EAAKU,WAG9C,IAAI7P,EAASwK,EAAM2E,EAAK8B,eAAiB5R,KAAKW,OAAS,KACnDkR,EAAc1G,EAAM2E,EAAKgC,oBAAqBjH,EAAYM,EAAM2E,EAAKiC,mBACrEjD,EAAgBgB,EAAKhB,cAAe4B,EAAgBZ,EAAKa,mBACzDC,EAAgBd,EAAKhR,UAAUe,UAAUM,OACzCN,EAAYiQ,EAAKhR,UAAUe,UAC3BmS,EAAYlC,EAAKlP,MAAQqP,EAAGI,eAAgB4B,EAAWD,GAAa,EAAI7G,GAC5E,GAAItK,GAAS,EAAApB,SAASwF,IAClB,IAAK,IAAI/E,EAAI,EAAGA,EAAI0Q,EAAe1Q,IAC/BL,EAAUK,GAAGK,MAAMC,EAAUsO,EAAe4B,EAAe/P,EAAQsR,EAAUpR,EAAO,EAAAnB,aAAayG,YAClG,CACH,IAAI8K,EAAenB,EAAKmB,aACpBiB,EAAkBpC,EAAKoC,gBAEvBhB,EAA8C,GAAjCpB,EAAKqB,kBAAkBhR,OACpC+Q,GAAY,EAAAtP,MAAMmI,aAAa+F,EAAKqB,kBAAmBP,GAAiB,EAAG,MAC/E,IAAIO,EAAoBrB,EAAKqB,kBAE7BrB,EAAKM,WAAa,EAClB,IAASlQ,EAAI,EAAGA,EAAI0Q,EAAe1Q,IAAK,CACpC,IAAI6Q,EAAWlR,EAAUK,GACrBY,EAAY,EAAApB,aAAayG,OACzBiL,OAAa,EACbxQ,EAAQ,EACZ,OAAQqQ,EAAa/Q,IACjB,KAAKmR,EAAeC,WAChB,IAAKzG,GAAakG,aAAoB,EAAAhG,kBAAmB,SACzDqG,EAAgBvQ,EAChBD,EAAQqR,EACR,MACJ,KAAKZ,EAAec,MAChBf,EAAgB,EAAA3R,SAASiF,MACzB9D,EAAQqR,EACR,MACJ,KAAKZ,EAAee,gBAChBhB,EAAgBvQ,EAChBD,EAAQoR,EACR,MACJ,KAAKX,EAAegB,WAChBjB,EAAgB,EAAA3R,SAASiF,MACzB9D,EAAQoR,EACR,MACJ,QACIZ,EAAgB,EAAA3R,SAASiF,MACzB,IAAI4N,EAAUJ,EAAgBhS,GAC9BU,EAAQoR,EAAY5L,KAAKmM,IAAI,EAAG,EAAID,EAAQ7C,QAAU6C,EAAQnC,aAGtEL,EAAKM,YAAcxP,EAEfmQ,aAAoB,EAAA1M,eACpBrE,KAAKuR,oBAAoBR,EAAUvQ,EAAUkQ,EAAe9P,EAAOwQ,EAAeD,EAAmBjR,GAAK,EAAGgR,GACxGH,aAAoB,EAAA5H,mBACzBnJ,KAAKgR,wBAAwBD,EAAUvQ,EAAUkQ,EAAeU,EAAeS,IAG/E,EAAAjQ,MAAMkP,sBAAsBlQ,EAAOC,GAC/BgK,GAAakG,aAAoB,EAAAhG,mBAAqBqG,GAAiB,EAAA3R,SAASiF,QAChF5D,EAAY,EAAApB,aAAa0M,OAC7B2E,EAASxQ,MAAMC,EAAUsO,EAAe4B,EAAe/P,EAAQC,EAAOwQ,EAAetQ,KAUjG,OALImP,EAAGE,YAAc,GAAGnQ,KAAKwR,YAAY1B,EAAMY,GAC/C1Q,KAAKW,OAAOR,OAAS,EACrB2P,EAAKf,kBAAoB2B,EACzBZ,EAAKb,cAAgBa,EAAKR,UAEnBnE,GAGX,YAAA6F,wBAAA,SAAyBD,EAA8BvQ,EAAoBE,EAAcG,EAAiBgR,GAEtG,IAAIxK,EAAO7G,EAAS8G,MAAMyJ,EAASlK,WACnC,GAAKQ,EAAK9C,KAAKE,OAAf,CAEA,IAMQvC,EANJ8B,EAAS+M,EAAS/M,OACtB,GAAItD,EAAOsD,EAAO,GACVnD,GAAS,EAAApB,SAASiF,OAAS7D,GAAS,EAAApB,SAASoF,OAC7C7E,KAAKiJ,cAAczI,EAAU6G,EAAMA,EAAKzC,KAAKoE,eAAgB6I,QAK7D3P,EADAxB,GAAQsD,EAAOA,EAAO7D,OAAS,GAClB6D,EAAO7D,OAAS,EAEhB,EAAAsB,UAAUT,aAAagD,EAAQtD,GAAQ,EACxDV,KAAKiJ,cAAczI,EAAU6G,EAAM0J,EAASlI,gBAAgB3G,GAAa2P,GAIzExK,EAAKsK,iBAAmB3R,KAAKoO,eAAc/G,EAAKsK,gBAAkB3R,KAAKoO,aAAeiD,EAAeK,SAG7G,YAAAzI,cAAA,SAAezI,EAAoB6G,EAAY2B,EAAwB6I,GACnExK,EAAK0B,WAA+B,MAAlBC,EAAyB,KAAOxI,EAAS0I,cAAc7B,EAAKzC,KAAKrC,MAAOyG,GACtF6I,IAAaxK,EAAKsK,gBAAkB3R,KAAKoO,aAAeiD,EAAemB,UAI/E,YAAAjB,oBAAA,SAAqBR,EAAoBvQ,EAAoBE,EAAcE,EAAeC,EACrEsQ,EAAkCjR,EAAWgR,GAI9D,GAFIA,IAAYC,EAAkBjR,GAAK,GAE1B,GAATU,EAAJ,CAKA,IAAI6R,EAAiB1B,EACjB/M,EAASyO,EAAezO,OACxBO,EAAO/D,EAASgE,MAAMiO,EAAevO,WACzC,GAAKK,EAAKE,OAAV,CACA,IAAIiO,EAAK,EAAG3K,EAAK,EACjB,GAAIrH,EAAOsD,EAAO,GACd,OAAQnD,GACJ,KAAK,EAAApB,SAASiF,MACVH,EAAKI,SAAWJ,EAAKK,KAAKD,SAC9B,QACI,OACJ,KAAK,EAAAlF,SAASoF,MACV6N,EAAKnO,EAAKI,SACVoD,EAAKxD,EAAKK,KAAKD,cAIvB,GADA+N,EAAK7R,GAAS,EAAApB,SAASiF,MAAQH,EAAKK,KAAKD,SAAWJ,EAAKI,SACrDjE,GAAQsD,EAAOA,EAAO7D,OAAS,EAAAkE,eAAeS,SAC9CiD,EAAKxD,EAAKK,KAAKD,SAAWX,EAAOA,EAAO7D,OAAS,EAAAkE,eAAeU,mBAC/D,CAED,IAAIG,EAAQ,EAAAzD,UAAUT,aAAagD,EAAQtD,EAAM,EAAA2D,eAAeS,SAC5DK,EAAenB,EAAOkB,EAAQ,EAAAb,eAAeU,eAC7CK,EAAYpB,EAAOkB,GACnBxB,EAAU+O,EAAehP,iBAAiByB,GAAS,GAAK,EACxD,GAAKxE,EAAO0E,IAAcpB,EAAOkB,EAAQ,EAAAb,eAAegB,WAAaD,IAEzE2C,EAAK/D,EAAOkB,EAAQ,EAAAb,eAAeC,UAAYa,EAE/C4C,EAAK5C,GADL4C,GAAwD,KAAjD,OAAU,mBAAqBA,EAAK,IAAO,KACzBrE,EAAUa,EAAKK,KAAKD,SAC7CoD,GAAwD,KAAjD,OAAU,mBAAqBA,EAAK,IAAO,IAK1D,IAAI4K,EAAQ,EAAGC,EAAO7K,EAAK2K,EAE3B,GAAY,IADZE,GAA4D,KAAnD,OAAU,mBAAqBA,EAAO,IAAO,KAElDD,EAAQxB,EAAkBjR,OACvB,CACH,IAAI2S,EAAY,EAAGC,EAAW,EAC1B5B,GACA2B,EAAY,EACZC,EAAWF,IAEXC,EAAY1B,EAAkBjR,GAC9B4S,EAAW3B,EAAkBjR,EAAI,IAErC,IAAIoB,EAAUsR,EAAO,EAAGG,EAAMF,GAAa,EAEvC,EAAAlP,UAAU2C,OAAOwM,IAAa,EAAAnP,UAAU2C,OAAOsM,IAASxM,KAAKC,IAAIyM,IAAa,KAE1E1M,KAAKC,IAAIwM,GAAa,MAAKA,GAAa,IAAM,EAAAlP,UAAU2C,OAAOuM,IACnEE,EAAMzR,GAEVqR,EAAQC,EAAOC,EAAYA,EAAY,IACnCE,GAAOzR,IAASqR,GAAS,IAAM,EAAAhP,UAAU2C,OAAOuM,IACpD1B,EAAkBjR,GAAKyS,EAE3BxB,EAAkBjR,EAAI,GAAK0S,EAC3BF,GAAMC,EAAQ/R,EACd2D,EAAKI,SAAW+N,EAAuD,KAAjD,OAAU,mBAAqBA,EAAK,IAAO,UAjE7D3B,EAASxQ,MAAMC,EAAU,EAAGE,EAAM,KAAM,EAAGG,EAAO,EAAAnB,aAAa0M,QAoEvE,YAAAoF,YAAA,SAAawB,EAAmBtC,GAQ5B,IAPA,IAAIuC,EAAiBD,EAAMC,eAAgBC,EAAeF,EAAME,aAC5DpT,EAAWoT,EAAeD,EAC1BE,EAAmBH,EAAMhE,UAAYlP,EAGrCa,EAASX,KAAKW,OACdT,EAAI,EAAGa,EAAIJ,EAAOR,OACfD,EAAIa,EAAGb,IAAK,CACf,IAAI,EAAQS,EAAOT,GACnB,GAAI,EAAMQ,KAAOyS,EAAkB,MAC/B,EAAMzS,KAAOwS,GACjBlT,KAAKsO,MAAM/D,MAAMyI,EAAO,GAY5B,KAPIA,EAAMnU,KACiB,GAAZiB,GAAiBqT,EAAmBH,EAAM1D,UAAYxP,EAEtD4Q,GAAiBwC,GAAgBF,EAAMlE,cAAgBoE,IACxDlT,KAAKsO,MAAM8E,SAASJ,GAG3B9S,EAAIa,EAAGb,IAAK,CACHS,EAAOT,GACTQ,KAAOuS,GACjBjT,KAAKsO,MAAM/D,MAAMyI,EAAOrS,EAAOT,MAQvC,YAAAmT,YAAA,WACI,IAAIC,EAAmBtT,KAAKsO,MAAMiF,cAClCvT,KAAKsO,MAAMiF,eAAgB,EAC3B,IAAK,IAAIrT,EAAI,EAAGa,EAAIf,KAAKkO,OAAO/N,OAAQD,EAAIa,EAAGb,IAC3CF,KAAKwT,WAAWtT,GACpBF,KAAKkO,OAAO/N,OAAS,EACrBH,KAAKsO,MAAMiF,cAAgBD,EAC3BtT,KAAKsO,MAAM0B,SAOf,YAAAwD,WAAA,SAAYzU,GACR,KAAIA,GAAciB,KAAKkO,OAAO/N,QAA9B,CACA,IAAImB,EAAUtB,KAAKkO,OAAOnP,GAC1B,GAAe,MAAXuC,EAAJ,CAEAtB,KAAKsO,MAAMqB,IAAIrO,GAEftB,KAAK4P,YAAYtO,GAGjB,IADA,IAAI0R,EAAQ1R,IACC,CACT,IAAIwO,EAAOkD,EAAMxD,WACjB,GAAY,MAARM,EAAc,MAClB9P,KAAKsO,MAAMqB,IAAIG,GACfkD,EAAMxD,WAAa,KACnBwD,EAAMjD,SAAW,KACjBiD,EAAQlD,EAGZ9P,KAAKkO,OAAO5M,EAAQvC,YAAc,KAElCiB,KAAKsO,MAAM0B,WAGf,YAAAT,WAAA,SAAYhN,EAAejB,EAAqBmS,GAC5C,IAAI3D,EAAO9P,KAAK0T,cAAcnR,GAC9BvC,KAAKkO,OAAO3L,GAASjB,EAET,MAARwO,IACI2D,GAAWzT,KAAKsO,MAAMmF,UAAU3D,GACpCxO,EAAQkO,WAAaM,EACrBA,EAAKC,SAAWzO,EAChBA,EAAQmO,QAAU,EAGK,MAAnBK,EAAKN,YAAsBM,EAAKK,YAAc,IAC9C7O,EAAQ+O,gBAAkBjK,KAAKuN,IAAI,EAAG7D,EAAKL,QAAUK,EAAKK,cAE9DL,EAAKqB,kBAAkBhR,OAAS,GAGpCH,KAAKsO,MAAMzK,MAAMvC,IAMrB,YAAAsS,aAAA,SAAc7U,EAAoB8U,EAAuBhV,GACrD,IAAIC,EAAYkB,KAAK4E,KAAKkP,aAAaC,cAAcF,GACrD,GAAiB,MAAb/U,EAAmB,MAAM,IAAIiB,MAAM,wBAA0B8T,GACjE,OAAO7T,KAAKgU,iBAAiBjV,EAAYD,EAAWD,IASxD,YAAAmV,iBAAA,SAAkBjV,EAAoBD,EAAsBD,GACxD,GAAiB,MAAbC,EAAmB,MAAM,IAAIiB,MAAM,6BACvC,IAAI0T,GAAY,EACZnS,EAAUtB,KAAK0T,cAAc3U,GAClB,MAAXuC,KAC8B,GAA1BA,EAAQ2N,eAERjP,KAAKkO,OAAOnP,GAAcuC,EAAQkO,WAClCxP,KAAKsO,MAAMmF,UAAUnS,GACrBtB,KAAKsO,MAAMqB,IAAIrO,GACftB,KAAK4P,YAAYtO,GACjBA,EAAUA,EAAQkO,WAClBiE,GAAY,GAEZzT,KAAK4P,YAAYtO,IAEzB,IAAI0R,EAAQhT,KAAKiU,WAAWlV,EAAYD,EAAWD,EAAMyC,GAGzD,OAFAtB,KAAKuP,WAAWxQ,EAAYiU,EAAOS,GACnCzT,KAAKsO,MAAM0B,QACJgD,GAMX,YAAAkB,aAAA,SAAcnV,EAAoB8U,EAAuBhV,EAAesQ,GACpE,IAAIrQ,EAAYkB,KAAK4E,KAAKkP,aAAaC,cAAcF,GACrD,GAAiB,MAAb/U,EAAmB,MAAM,IAAIiB,MAAM,wBAA0B8T,GACjE,OAAO7T,KAAKmU,iBAAiBpV,EAAYD,EAAWD,EAAMsQ,IAW9D,YAAAgF,iBAAA,SAAkBpV,EAAoBD,EAAsBD,EAAesQ,GACvE,GAAiB,MAAbrQ,EAAmB,MAAM,IAAIiB,MAAM,6BAEvC,IAAIyB,EAAOxB,KAAK0T,cAAc3U,GAC9B,GAAY,MAARyC,EACA,KAAoB,MAAbA,EAAK4N,MACR5N,EAAOA,EAAK4N,KAGpB,IAAI4D,EAAQhT,KAAKiU,WAAWlV,EAAYD,EAAWD,EAAM2C,GAEzD,GAAY,MAARA,EACAxB,KAAKuP,WAAWxQ,EAAYiU,GAAO,GACnChT,KAAKsO,MAAM0B,aAGX,GADAxO,EAAK4N,KAAO4D,EACR7D,GAAS,EAAG,CACZ,IAAIrP,EAAW0B,EAAK0R,aAAe1R,EAAKyR,eACxB,GAAZnT,GACI0B,EAAK3C,KACLsQ,GAASrP,GAAY,GAAM0B,EAAK8N,UAAYxP,EAAY,IAExDqP,GAAS/I,KAAKmM,IAAIzS,EAAU0B,EAAK8N,WACrCH,GAASnP,KAAK4E,KAAKwP,OAAO5S,EAAK1C,UAAWA,IAE1CqQ,EAAQ3N,EAAK8N,UAKzB,OADA0D,EAAM7D,MAAQA,EACP6D,GAiBX,YAAAqB,kBAAA,SAAmBtV,EAAoBoR,GACnC,IAAI6C,EAAQhT,KAAKgU,iBAAiBjV,EAAYsS,EAAeiD,gBAAgB,GAG7E,OAFAtB,EAAM7C,YAAcA,EACpB6C,EAAMtD,SAAWS,EACV6C,GAcX,YAAAuB,kBAAA,SAAmBxV,EAAoBoR,EAAqBhB,GACpDA,GAAS,IAAGA,GAASgB,GACzB,IAAI6C,EAAQhT,KAAKmU,iBAAiBpV,EAAYsS,EAAeiD,gBAAgB,EAAOnF,GAGpF,OAFA6D,EAAM7C,YAAcA,EACpB6C,EAAMtD,SAAWS,EACV6C,GAKX,YAAAwB,mBAAA,SAAoBrE,GAChB,IAAImD,EAAmBtT,KAAKsO,MAAMiF,cAClCvT,KAAKsO,MAAMiF,eAAgB,EAC3B,IAAK,IAAIrT,EAAI,EAAGa,EAAIf,KAAKkO,OAAO/N,OAAQD,EAAIa,EAAGb,IAAK,CAChD,IAAIoB,EAAUtB,KAAKkO,OAAOhO,GACX,MAAXoB,GAAiBtB,KAAKqU,kBAAkB/S,EAAQvC,WAAYoR,GAEpEnQ,KAAKsO,MAAMiF,cAAgBD,EAC3BtT,KAAKsO,MAAM0B,SAGf,YAAA0D,cAAA,SAAenR,GACX,OAAIA,EAAQvC,KAAKkO,OAAO/N,OAAeH,KAAKkO,OAAO3L,IACnD,EAAAX,MAAM6S,oBAAoBzU,KAAKkO,OAAQ3L,EAAQ,EAAG,MAClDvC,KAAKkO,OAAO/N,OAASoC,EAAQ,EACtB,OAIX,YAAA0R,WAAA,SAAYlV,EAAoBD,EAAsBD,EAAe2C,GACjE,IAAIwR,EAAQhT,KAAK2O,eAAe+F,SA2BhC,OA1BA1B,EAAMjU,WAAaA,EACnBiU,EAAMlU,UAAYA,EAClBkU,EAAMnU,KAAOA,EACbmU,EAAM2B,cAAe,EAErB3B,EAAMpB,eAAiB,EACvBoB,EAAMlB,oBAAsB,EAC5BkB,EAAMjB,mBAAqB,EAE3BiB,EAAMC,eAAiB,EACvBD,EAAME,aAAepU,EAAUgB,SAC/BkT,EAAMlE,eAAiB,EACvBkE,EAAMjE,mBAAqB,EAE3BiE,EAAM7D,MAAQ,EACd6D,EAAM1D,UAAY,EAClB0D,EAAMhE,WAAa,EACnBgE,EAAM/D,eAAiB,EACvB+D,EAAMtD,SAAWlF,OAAOC,UACxBuI,EAAM7E,UAAY,EAElB6E,EAAMpS,MAAQ,EACdoS,EAAM3C,eAAiB,EACvB2C,EAAMvD,QAAU,EAChBuD,EAAM7C,YAAsB,MAAR3O,EAAe,EAAIxB,KAAK4E,KAAKwP,OAAO5S,EAAK1C,UAAWA,GACxEkU,EAAMxC,SAAW,EAAA/Q,SAASuF,QACnBgO,GAGX,YAAApD,YAAA,SAAaoD,GAET,IADA,IAAI5D,EAAO4D,EAAM5D,KACF,MAARA,GACHpP,KAAKsO,MAAMsG,QAAQxF,GACnBA,EAAOA,EAAKA,KAEhB4D,EAAM5D,KAAO,MAGjB,YAAAkB,mBAAA,WACItQ,KAAK0O,mBAAoB,EAEzB1O,KAAKwO,YAAYqG,QAEjB,IAAK,IAAI3U,EAAI,EAAGa,EAAIf,KAAKkO,OAAO/N,OAAQD,EAAIa,EAAGb,IAAK,CAChD,IAAI8S,EAAQhT,KAAKkO,OAAOhO,GACxB,GAAa,MAAT8S,EAAJ,CACA,KAA2B,MAApBA,EAAMxD,YACTwD,EAAQA,EAAMxD,WAElB,GAC4B,MAApBwD,EAAMxD,YAAsBwD,EAAMxC,UAAY,EAAA/Q,SAASwF,KAAKjF,KAAK8U,YAAY9B,GACjFA,EAAQA,EAAMjD,eACA,MAATiD,MAIjB,YAAA8B,YAAA,SAAa9B,GACT,IAAI/C,EAAK+C,EAAMjD,SACXlQ,EAAYmT,EAAMlU,UAAUe,UAC5BkV,EAAiB/B,EAAMlU,UAAUe,UAAUM,OAC3C8Q,EAAe,EAAArP,MAAMmI,aAAaiJ,EAAM/B,aAAc8D,GAC1D/B,EAAMd,gBAAgB/R,OAAS,EAC/B,IAAI6U,EAAiB,EAAApT,MAAMmI,aAAaiJ,EAAMd,gBAAiB6C,GAC3DvG,EAAcxO,KAAKwO,YAEvB,GAAU,MAANyB,GAAcA,EAAG0E,aACjB,IAAK,IAAIzU,EAAI,EAAGA,EAAI6U,EAAgB7U,IAChC+Q,EAAa/Q,GAAKsO,EAAYvJ,IAAIpF,EAAUK,GAAGE,iBAAmBiR,EAAegB,WAAahB,EAAee,qBAKrH6C,EACI,IAAS/U,EAAI,EAAGA,EAAI6U,EAAgB7U,IAAK,CACrC,IAAI6Q,EAAWlR,EAAUK,GACrBI,EAAKyQ,EAAS3Q,gBAClB,GAAKoO,EAAYvJ,IAAI3E,GAEhB,GAAU,MAAN2P,GAAcc,aAAoB,EAAA5H,oBAAsB4H,aAAoB,EAAAhG,mBAC9EgG,aAAoB,EAAApG,gBAAkBsF,EAAGnR,UAAUuB,YAAYC,GAClE2Q,EAAa/Q,GAAKmR,EAAec,UAC9B,CACH,IAAK,IAAI/C,EAAOa,EAAGF,SAAkB,MAARX,EAAcA,EAAOA,EAAKW,SACnD,IAAIX,EAAKtQ,UAAUuB,YAAYC,GAA/B,CACA,GAAI0S,EAAM7C,YAAc,EAAG,CACvBc,EAAa/Q,GAAKmR,EAAe6D,SACjCF,EAAe9U,GAAKkP,EACpB,SAAS6F,EAEb,MAEJhE,EAAa/Q,GAAKmR,EAAegB,gBAdjCpB,EAAa/Q,GAAKmR,EAAeC,aAoBjD,YAAA6D,WAAA,SAAYpW,GACR,OAAIA,GAAciB,KAAKkO,OAAO/N,OAAe,KACtCH,KAAKkO,OAAOnP,IAIvB,YAAAqW,YAAA,SAAaC,GACT,GAAgB,MAAZA,EAAkB,MAAM,IAAItV,MAAM,4BACtCC,KAAKqO,UAAU3D,KAAK2K,IAIxB,YAAAC,eAAA,SAAgBD,GACZ,IAAI9S,EAAQvC,KAAKqO,UAAUkH,QAAQF,GAC/B9S,GAAS,GAAGvC,KAAKqO,UAAUmH,OAAOjT,EAAO,IAIjD,YAAAkT,eAAA,WACIzV,KAAKqO,UAAUlO,OAAS,GAM5B,YAAAuV,2BAAA,WACI1V,KAAKsO,MAAMuG,SAWf,YAAAc,mBAAA,SAAmB5W,EAAoB8U,EAAuBhV,GACrDwS,EAAeuE,qBAChBvE,EAAeuE,oBAAqB,EACpCC,QAAQC,KAAK,qHAEjB9V,KAAK4T,aAAa7U,EAAY8U,EAAehV,IAKjD,YAAAkX,mBAAA,SAAmBhX,EAAoB8U,EAAuBhV,EAAesQ,GACpEkC,EAAe2E,qBAChB3E,EAAe2E,oBAAqB,EACpCH,QAAQC,KAAK,qHAEjB9V,KAAKkU,aAAanV,EAAY8U,EAAehV,EAAMsQ,IAKvD,YAAA8G,aAAA,SAAapC,GAET,OAAqB,OADL7T,KAAK4E,KAAKkP,aAAaC,cAAcF,IAIzD,YAAAqC,mBAAA,SAAmBrC,GAKf,OAJKxC,EAAe8E,qBAChB9E,EAAe8E,oBAAqB,EACpCN,QAAQC,KAAK,qHAEV9V,KAAKiW,aAAapC,IA9zBtB,EAAAS,eAAiB,IAAI,EAAA7S,UAAU,UAAW,GAAI,GAK9C,EAAA6P,WAAa,EAKb,EAAAa,MAAQ,EAMR,EAAAC,gBAAkB,EAMlB,EAAAC,WAAa,EAab,EAAA6C,SAAW,EAEX,EAAAxD,MAAQ,EACR,EAAAc,QAAU,EAwvBF,EAAAoD,oBAA8B,EAU9B,EAAAI,oBAA8B,EAU9B,EAAAG,oBAA8B,EAcjD,EAj0BA,GAAa,EAAA9E,eAAc,EAs0B3B,8BAkJI,KAAAb,SAAW,EAAA/Q,SAASuF,QACpB,KAAAiM,aAAe,IAAInI,MACnB,KAAAoJ,gBAAkB,IAAIpJ,MACtB,KAAAqI,kBAAoB,IAAIrI,MA4F5B,OA1FI,YAAAsN,MAAA,WACIpW,KAAKoP,KAAO,KACZpP,KAAKwP,WAAa,KAClBxP,KAAK+P,SAAW,KAChB/P,KAAKlB,UAAY,KACjBkB,KAAKqV,SAAW,KAChBrV,KAAKiR,aAAa9Q,OAAS,EAC3BH,KAAKkS,gBAAgB/R,OAAS,EAC9BH,KAAKmR,kBAAkBhR,OAAS,GAMpC,YAAAwQ,iBAAA,WACI,GAAI3Q,KAAKnB,KAAM,CACX,IAAIiB,EAAWE,KAAKkT,aAAelT,KAAKiT,eACxC,OAAgB,GAAZnT,EAAsBE,KAAKiT,eACvBjT,KAAKsP,UAAYxP,EAAYE,KAAKiT,eAE9C,OAAO7M,KAAKuN,IAAI3T,KAAKsP,UAAYtP,KAAKiT,eAAgBjT,KAAKkT,eAG/D,YAAAmD,iBAAA,SAAiBvH,GACb9O,KAAK8O,cAAgBA,EACrB9O,KAAK+O,kBAAoBD,GAM7B,YAAAwH,WAAA,WACI,OAAOtW,KAAKsP,WAAatP,KAAKkT,aAAelT,KAAKiT,gBAUtD,YAAAsD,wBAAA,WACIvW,KAAKmR,kBAAkBhR,OAAS,GAYpC,sBAAI,mBAAI,C,IAAR,WAKI,OAJKqW,EAAWZ,qBACZY,EAAWZ,oBAAqB,EAChCC,QAAQC,KAAK,gGAEV9V,KAAKsP,W,IAGhB,SAAS9B,GACAgJ,EAAWZ,qBACZY,EAAWZ,oBAAqB,EAChCC,QAAQC,KAAK,gGAEjB9V,KAAKsP,UAAY9B,G,gCAGrB,sBAAI,sBAAO,C,IAAX,WAKI,OAJKgJ,EAAWR,qBACZQ,EAAWR,oBAAqB,EAChCH,QAAQC,KAAK,kGAEV9V,KAAKsP,W,IAGhB,SAAY9B,GACHgJ,EAAWR,qBACZQ,EAAWR,oBAAqB,EAChCH,QAAQC,KAAK,kGAEjB9V,KAAKsP,UAAY9B,G,gCAGrB,YAAAiJ,WAAA,WACI,OAAOrQ,KAAKsQ,MAAM1W,KAAKsP,UAAYtP,KAAK0P,WApC7B,EAAAkG,oBAA8B,EAC9B,EAAAI,oBAA8B,EAqCjD,EAjPA,GAAa,EAAAQ,WAAU,EAmPvB,IAyHYG,EAzHZ,aAKI,WAAYC,GAJZ,KAAAC,QAAsB,GACtB,KAAAtD,eAAgB,EAIZvT,KAAK4W,UAAYA,EAiHzB,OA9GI,YAAA/S,MAAA,SAAOmP,GACHhT,KAAK6W,QAAQnM,KAAKiM,EAAU9S,OAC5B7D,KAAK6W,QAAQnM,KAAKsI,GAClBhT,KAAK4W,UAAUlI,mBAAoB,GAGvC,YAAA+E,UAAA,SAAWT,GACPhT,KAAK6W,QAAQnM,KAAKiM,EAAUlD,WAC5BzT,KAAK6W,QAAQnM,KAAKsI,IAGtB,YAAArD,IAAA,SAAKqD,GACDhT,KAAK6W,QAAQnM,KAAKiM,EAAUhH,KAC5B3P,KAAK6W,QAAQnM,KAAKsI,GAClBhT,KAAK4W,UAAUlI,mBAAoB,GAGvC,YAAAkG,QAAA,SAAS5B,GACLhT,KAAK6W,QAAQnM,KAAKiM,EAAU/B,SAC5B5U,KAAK6W,QAAQnM,KAAKsI,IAGtB,YAAAI,SAAA,SAAUJ,GACNhT,KAAK6W,QAAQnM,KAAKiM,EAAUvD,UAC5BpT,KAAK6W,QAAQnM,KAAKsI,IAGtB,YAAAzI,MAAA,SAAOyI,EAAmBzI,GACtBvK,KAAK6W,QAAQnM,KAAKiM,EAAUpM,OAC5BvK,KAAK6W,QAAQnM,KAAKsI,GAClBhT,KAAK6W,QAAQnM,KAAKH,IAKtB,YAAAuM,eAAA,WAKI,OAJKvI,EAAWqH,qBACZrH,EAAWqH,oBAAqB,EAChCC,QAAQC,KAAK,oLAEV,GAGX,YAAA9F,MAAA,WACI,IAAIhQ,KAAKuT,cAAT,CACAvT,KAAKuT,eAAgB,EAKrB,IAHA,IAAIsD,EAAU7W,KAAK6W,QACfxI,EAAYrO,KAAK4W,UAAUvI,UAEtBnO,EAAI,EAAGA,EAAI2W,EAAQ1W,OAAQD,GAAK,EAAG,CACxC,IAAIsC,EAAOqU,EAAQ3W,GACf8S,EAAQ6D,EAAQ3W,EAAI,GACxB,OAAQsC,GACJ,KAAKmU,EAAU9S,MACW,MAAlBmP,EAAMqC,UAAoBrC,EAAMqC,SAASxR,OAAOmP,EAAMqC,SAASxR,MAAMmP,GACzE,IAAK,IAAInC,EAAK,EAAGA,EAAKxC,EAAUlO,OAAQ0Q,IAChCxC,EAAUwC,GAAIhN,OAAOwK,EAAUwC,GAAIhN,MAAMmP,GAEjDA,EAAM+D,SAAW/W,KAAK8W,kBAAoB9D,EAAM+D,QAAQ/D,EAAMjU,YAC9DiB,KAAK4W,UAAUG,SAAW/W,KAAK8W,kBAAoB9W,KAAK8W,gBAAkB9W,KAAK4W,UAAUG,QAAQ/D,EAAMjU,YACvG,MACJ,KAAK4X,EAAUlD,UACW,MAAlBT,EAAMqC,UAAoBrC,EAAMqC,SAAS5B,WAAWT,EAAMqC,SAAS5B,UAAUT,GACjF,IAASnC,EAAK,EAAGA,EAAKxC,EAAUlO,OAAQ0Q,IAChCxC,EAAUwC,GAAI4C,WAAWpF,EAAUwC,GAAI4C,UAAUT,GACzD,MACJ,KAAK2D,EAAUhH,IACW,MAAlBqD,EAAMqC,UAAoBrC,EAAMqC,SAAS1F,KAAKqD,EAAMqC,SAAS1F,IAAIqD,GACrE,IAASnC,EAAK,EAAGA,EAAKxC,EAAUlO,OAAQ0Q,IAChCxC,EAAUwC,GAAIlB,KAAKtB,EAAUwC,GAAIlB,IAAIqD,GAE7CA,EAAMgE,OAAShX,KAAK8W,kBAAoB9D,EAAMgE,MAAMhE,EAAMjU,YAC1DiB,KAAK4W,UAAUI,OAAShX,KAAK8W,kBAAoB9W,KAAK4W,UAAUI,MAAMhE,EAAMjU,YAEhF,KAAK4X,EAAU/B,QACW,MAAlB5B,EAAMqC,UAAoBrC,EAAMqC,SAAST,SAAS5B,EAAMqC,SAAST,QAAQ5B,GAC7E,IAASnC,EAAK,EAAGA,EAAKxC,EAAUlO,OAAQ0Q,IAChCxC,EAAUwC,GAAI+D,SAASvG,EAAUwC,GAAI+D,QAAQ5B,GACrDhT,KAAK4W,UAAUjI,eAAesI,KAAKjE,GACnC,MACJ,KAAK2D,EAAUvD,SACW,MAAlBJ,EAAMqC,UAAoBrC,EAAMqC,SAASjC,UAAUJ,EAAMqC,SAASjC,SAASJ,GAC/E,IAASnC,EAAK,EAAGA,EAAKxC,EAAUlO,OAAQ0Q,IAChCxC,EAAUwC,GAAIuC,UAAU/E,EAAUwC,GAAIuC,SAASJ,GAGvD,IAAIkE,EAAQ,EAAAvT,UAAUwT,MAAMnE,EAAMyD,cAClCzD,EAAMoE,YAAcpX,KAAK8W,kBAAoB9D,EAAMoE,WAAWpE,EAAMjU,WAAYmY,GAChFlX,KAAK4W,UAAUQ,YAAcpX,KAAK8W,kBAAoB9W,KAAK4W,UAAUQ,WAAWpE,EAAMjU,WAAYmY,GAClG,MACJ,KAAKP,EAAUpM,MACX,IAAI,EAAQsM,EAAc,EAAN3W,KACE,MAAlB8S,EAAMqC,UAAoBrC,EAAMqC,SAAS9K,OAAOyI,EAAMqC,SAAS9K,MAAMyI,EAAO,GAChF,IAASnC,EAAK,EAAGA,EAAKxC,EAAUlO,OAAQ0Q,IAChCxC,EAAUwC,GAAItG,OAAO8D,EAAUwC,GAAItG,MAAMyI,EAAO,GAExDA,EAAMqE,SAAWrX,KAAK8W,kBAAoB9D,EAAMqE,QAAQrE,EAAMjU,WAAY,GAC1EiB,KAAK4W,UAAUS,SAAWrX,KAAK8W,kBAAoB9W,KAAK4W,UAAUS,QAAQrE,EAAMjU,WAAY,IAIxGiB,KAAK6U,QAEL7U,KAAKuT,eAAgB,IAGzB,YAAAsB,MAAA,WACI7U,KAAK6W,QAAQ1W,OAAS,GA3EX,EAAAyV,oBAA8B,EA6EjD,EAvHA,GAAa,EAAArH,WAAU,EAyHvB,SAAYoI,GACR,qBAAO,6BAAW,iBAAK,yBAAS,2BAAU,qBAD9C,CAAYA,EAAA,EAAAA,YAAA,EAAAA,UAAS,KA0BrB,+BAkBA,OAjBI,YAAA9S,MAAA,SAAOmP,KAGP,YAAAS,UAAA,SAAWT,KAGX,YAAArD,IAAA,SAAKqD,KAGL,YAAA4B,QAAA,SAAS5B,KAGT,YAAAI,SAAA,SAAUJ,KAGV,YAAAzI,MAAA,SAAOyI,EAAmBzI,KAE9B,EAlBA,GAAsB,EAAA+M,sBAAqB,EAjtC1B,GAAA9X,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCCpB,SAAUA,IAAW,SAAAC,GACjB,iBAKI,WAAYsU,GACR,GAJJ,KAAAyD,mBAAkC,GAClC,KAAAC,WAAa,EAGW,MAAhB1D,EAAsB,MAAM,IAAI/T,MAAM,gCAC1CC,KAAK8T,aAAeA,EAiC5B,OA9BI,YAAA2D,OAAA,SAAOC,EAAkBC,EAAgB7X,GACrC,IAAIgQ,EAAO9P,KAAK8T,aAAaC,cAAc2D,GAC3C,GAAY,MAAR5H,EAAc,MAAM,IAAI/P,MAAM,wBAA0B2X,GAC5D,IAAIzH,EAAKjQ,KAAK8T,aAAaC,cAAc4D,GACzC,GAAU,MAAN1H,EAAY,MAAM,IAAIlQ,MAAM,wBAA0B4X,GAC1D3X,KAAK4X,WAAW9H,EAAMG,EAAInQ,IAK9B,YAAA+X,aAAA,SAAaH,EAAkBC,EAAgB7X,GACtCgY,EAAmBlC,qBACpBkC,EAAmBlC,oBAAqB,EACxCC,QAAQC,KAAK,uGAEjB9V,KAAKyX,OAAOC,EAAUC,EAAQ7X,IAGlC,YAAA8X,WAAA,SAAW9H,EAAiBG,EAAenQ,GACvC,GAAY,MAARgQ,EAAc,MAAM,IAAI/P,MAAM,wBAClC,GAAU,MAANkQ,EAAY,MAAM,IAAIlQ,MAAM,sBAChC,IAAIgY,EAAMjI,EAAKlQ,KAAO,IAAMqQ,EAAGrQ,KAC/BI,KAAKuX,mBAAmBQ,GAAOjY,GAGnC,YAAAsU,OAAA,SAAOtE,EAAiBG,GACpB,IAAI8H,EAAMjI,EAAKlQ,KAAO,IAAMqQ,EAAGrQ,KAC3B4N,EAAQxN,KAAKuX,mBAAmBQ,GACpC,YAAiBC,IAAVxK,EAAsBxN,KAAKwX,WAAahK,GApBpC,EAAAoI,oBAA8B,EAsBjD,EAxCA,GAAa,EAAAkC,mBAAkB,EADd,GAAAtY,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,iBAGI,WAAYyY,GACRjY,KAAKiY,MAAQA,EAsCrB,OAlCI,YAAAC,oBAAA,SAAoBlZ,EAAYY,EAAcuY,GAC1C,IAAIC,EAASpY,KAAKiY,MAAMI,WAAWF,GACnC,GAAc,MAAVC,EAAgB,MAAM,IAAIrY,MAAM,8BAAgCoY,EAAO,wBAA0BvY,EAAO,KAC5G,IAAImJ,EAAa,IAAI,EAAAuP,iBAAiB1Y,GAEtC,OADAmJ,EAAWqP,OAASA,EACbrP,GAIX,YAAAwP,kBAAA,SAAkBvZ,EAAYY,EAAcuY,GACxC,IAAIC,EAASpY,KAAKiY,MAAMI,WAAWF,GACnC,GAAc,MAAVC,EAAgB,MAAM,IAAIrY,MAAM,8BAAgCoY,EAAO,sBAAwBvY,EAAO,KAC1G,IAAImJ,EAAa,IAAI,EAAAyP,eAAe5Y,GAEpC,OADAmJ,EAAWqP,OAASA,EACbrP,GAIX,YAAA0P,yBAAA,SAAyBzZ,EAAYY,GACjC,OAAO,IAAI,EAAA8Y,sBAAsB9Y,IAIrC,YAAA+Y,kBAAA,SAAkB3Z,EAAYY,GAC1B,OAAO,IAAI,EAAAgZ,eAAehZ,IAG9B,YAAAiZ,mBAAA,SAAmB7Z,EAAYY,GAC3B,OAAO,IAAI,EAAAkZ,gBAAgBlZ,IAG/B,YAAAmZ,sBAAA,SAAsB/Z,EAAYY,GAC9B,OAAO,IAAI,EAAAoZ,mBAAmBpZ,IAEtC,EA1CA,GAAa,EAAAqZ,sBAAqB,EADjB,GAAAzZ,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,IACjB,SAAY0Z,GACR,uBACA,2BACA,2BACA,uBAJJ,CAAY,EAAAA,YAAA,EAAAA,UAAS,KADJ,GAAA1Z,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,iBAqCI,WAAYoF,EAAgBpE,EAAoB2Y,GAC5C,GAnCJ,KAAAC,OAAS,IAAIC,KAAKC,OAalB,KAAAC,SAAW,IAAIzQ,MACf,KAAAvF,EAAI,EACJ,KAAAC,EAAI,EACJ,KAAAmB,SAAW,EACX,KAAAmB,OAAS,EACT,KAAAC,OAAS,EACT,KAAAS,OAAS,EACT,KAAAC,OAAS,EACT,KAAA+S,GAAK,EACL,KAAAC,GAAK,EACL,KAAAC,UAAY,EACZ,KAAAC,QAAU,EACV,KAAAC,QAAU,EACV,KAAAC,QAAU,EACV,KAAAC,QAAU,EACV,KAAAC,cAAe,EAEf,KAAAC,QAAS,EACT,KAAAvV,QAAS,EAIO,MAARG,EAAc,MAAM,IAAI7E,MAAM,wBAClC,GAAgB,MAAZS,EAAkB,MAAM,IAAIT,MAAM,4BACtCC,KAAK4E,KAAOA,EACZ5E,KAAKQ,SAAWA,EAChBR,KAAKmZ,OAASA,EACdnZ,KAAKia,iBAyPb,OA/RI,sBAAI,qBAAM,C,IAAV,WACI,OAAOja,KAAKoZ,OAAOc,I,gCAGvB,sBAAI,qBAAM,C,IAAV,WACI,OAAOla,KAAKoZ,OAAOe,I,gCAoCvB,YAAAC,SAAA,WACI,OAAOpa,KAAKyE,QAIhB,YAAArG,OAAA,WACI4B,KAAKqa,yBAAyBra,KAAKuD,EAAGvD,KAAKwD,EAAGxD,KAAK2E,SAAU3E,KAAK8F,OAAQ9F,KAAK+F,OAAQ/F,KAAKwG,OAAQxG,KAAKyG,SAI7G,YAAA6T,qBAAA,WACIta,KAAKqa,yBAAyBra,KAAKuD,EAAGvD,KAAKwD,EAAGxD,KAAK2E,SAAU3E,KAAK8F,OAAQ9F,KAAK+F,OAAQ/F,KAAKwG,OAAQxG,KAAKyG,SAI7G,YAAA4T,yBAAA,SAAyB9W,EAAWC,EAAWmB,EAAkBmB,EAAgBC,EAAgBS,EAAgBC,GAC7GzG,KAAKwZ,GAAKjW,EACVvD,KAAKyZ,GAAKjW,EACVxD,KAAK0Z,UAAY/U,EACjB3E,KAAK2Z,QAAU7T,EACf9F,KAAK4Z,QAAU7T,EACf/F,KAAK6Z,QAAUrT,EACfxG,KAAK8Z,QAAUrT,EACfzG,KAAK+Z,cAAe,EAEpB,IAAIZ,EAASnZ,KAAKmZ,OACdoB,EAAIva,KAAKoZ,OAEToB,EAAKxa,KAAKQ,SAASsF,OACnB2U,EAAKC,EAAKC,OAAQ3a,KAAKQ,SAASuF,OAAS/F,KAAKQ,SAASuF,OAE3D,GAAc,MAAVoT,EAAgB,CAChB,IAAI3Y,EAAWR,KAAKQ,SAChBoa,EAAYjW,EAAW,GAAK8B,EAOhC,OANA8T,EAAEvT,EAAI,EAAArD,UAAUkX,OAAOlW,EAAW6B,GAAUV,EAAS0U,EACrDD,EAAEO,EAAI,EAAAnX,UAAUkX,OAAOD,GAAa7U,EAASyU,EAC7CD,EAAExT,EAAI,EAAApD,UAAUoX,OAAOpW,EAAW6B,GAAUV,EAAS2U,EACrDF,EAAES,EAAI,EAAArX,UAAUoX,OAAOH,GAAa7U,EAAS0U,EAC7CF,EAAEL,GAAK3W,EAAIiX,EAAKha,EAAS+C,OACzBgX,EAAEJ,GAAK3W,EAAIiX,EAAKja,EAASgD,GAI7B,IAAIyX,EAAK9B,EAAOC,OAAOpS,EAAGkU,EAAK/B,EAAOC,OAAO0B,EAAGK,EAAKhC,EAAOC,OAAOrS,EAAGqU,EAAKjC,EAAOC,OAAO4B,EAGzF,OAFAT,EAAEL,GAAKe,EAAK1X,EAAI2X,EAAK1X,EAAI2V,EAAOC,OAAOc,GACvCK,EAAEJ,GAAKgB,EAAK5X,EAAI6X,EAAK5X,EAAI2V,EAAOC,OAAOe,GAC/Bna,KAAK4E,KAAKyW,eACd,KAAK,EAAAC,cAAcC,OACXX,EAAYjW,EAAW,GAAK8B,EAAhC,IACI+U,EAAK,EAAA7X,UAAUkX,OAAOlW,EAAW6B,GAAUV,EAC3C2V,EAAK,EAAA9X,UAAUkX,OAAOD,GAAa7U,EACnC2V,EAAK,EAAA/X,UAAUoX,OAAOpW,EAAW6B,GAAUV,EAC3C6V,EAAK,EAAAhY,UAAUoX,OAAOH,GAAa7U,EAKvC,OAJAwU,EAAEvT,EAAIiU,EAAKO,EAAKN,EAAKQ,EACrBnB,EAAEO,EAAIG,EAAKQ,EAAKP,EAAKS,EACrBpB,EAAExT,EAAIoU,EAAKK,EAAKJ,EAAKM,OACrBnB,EAAES,EAAIG,EAAKM,EAAKL,EAAKO,GAGzB,KAAK,EAAAL,cAAcM,gBACXhB,EAAYjW,EAAW,GAAK8B,EAChC8T,EAAEvT,EAAI,EAAArD,UAAUkX,OAAOlW,EAAW6B,GAAUV,EAC5CyU,EAAEO,EAAI,EAAAnX,UAAUkX,OAAOD,GAAa7U,EACpCwU,EAAExT,EAAI,EAAApD,UAAUoX,OAAOpW,EAAW6B,GAAUV,EAC5CyU,EAAES,EAAI,EAAArX,UAAUoX,OAAOH,GAAa7U,EACpC,MAEJ,KAAK,EAAAuV,cAAcO,uBACf,IACIC,EAAM,GADNC,EAAId,EAAKA,EAAKE,EAAKA,GAEf,MACJF,GAAMjb,KAAKQ,SAASsF,OAGpBoV,GAFAC,GAAMnb,KAAKQ,SAASuF,SACpBgW,EAAI3V,KAAKC,IAAI4U,EAAKG,EAAKF,EAAKC,GAAMY,GAElCX,EAAKH,EAAKc,EACVD,EAAM1V,KAAK4V,MAAMb,EAAIF,GAAM,EAAAtX,UAAUsY,SAErChB,EAAK,EACLE,EAAK,EACLW,EAAM,GAAK1V,KAAK4V,MAAMZ,EAAIF,GAAM,EAAAvX,UAAUsY,QAE9C,IAAIC,EAAKvX,EAAW6B,EAASsV,EACzBK,EAAKxX,EAAW8B,EAASqV,EAAM,GAC/BN,EAAK,EAAA7X,UAAUkX,OAAOqB,GAAMpW,EAC5B2V,EAAK,EAAA9X,UAAUkX,OAAOsB,GAAMpW,EAC5B2V,EAAK,EAAA/X,UAAUoX,OAAOmB,GAAMpW,EAC5B6V,EAAK,EAAAhY,UAAUoX,OAAOoB,GAAMpW,EAChCwU,EAAEvT,EAAIiU,EAAKO,EAAKN,EAAKQ,EACrBnB,EAAEO,EAAIG,EAAKQ,EAAKP,EAAKS,EACrBpB,EAAExT,EAAIoU,EAAKK,EAAKJ,EAAKM,EACrBnB,EAAES,EAAIG,EAAKM,EAAKL,EAAKO,EACrB,MAEJ,KAAK,EAAAL,cAAcc,QACnB,KAAK,EAAAd,cAAce,oBACf,IAIIN,EAJAO,EAAM,EAAA3Y,UAAUkX,OAAOlW,GACvB4X,EAAM,EAAA5Y,UAAUoX,OAAOpW,GACvB6X,GAAMvB,EAAKqB,EAAMpB,EAAKqB,GAAO/B,EAC7BiC,GAAMtB,EAAKmB,EAAMlB,EAAKmB,GAAO9B,GAC7BsB,EAAI3V,KAAKsW,KAAKF,EAAKA,EAAKC,EAAKA,IACzB,OAASV,EAAI,EAAIA,GACzBS,GAAMT,EACNU,GAAMV,EACNA,EAAI3V,KAAKsW,KAAKF,EAAKA,EAAKC,EAAKA,GAEzBzc,KAAK4E,KAAKyW,eAAiB,EAAAC,cAAcc,SACrCnB,EAAKG,EAAKF,EAAKC,EAAK,IAAOT,EAAKC,MACnC3a,KAAKQ,SAASsF,OAAS,GAAK9F,KAAKQ,SAASuF,OAAS,EAC/C/F,KAAKQ,SAASsF,OAAS,GAAK9F,KAAKQ,SAASuF,OAAS,KAC1DgW,GAAKA,GACP,IAAIzW,EAAIc,KAAKuW,GAAK,EAAIvW,KAAK4V,MAAMS,EAAID,GACjCI,EAAKxW,KAAKkW,IAAIhX,GAAKyW,EACnBc,EAAKzW,KAAKmW,IAAIjX,GAAKyW,EACnBP,EAAK,EAAA7X,UAAUkX,OAAOrU,GAAUV,EAChC2V,EAAK,EAAA9X,UAAUkX,OAAO,GAAKpU,GAAUV,EACrC2V,EAAK,EAAA/X,UAAUoX,OAAOvU,GAAUV,EAChC6V,EAAK,EAAAhY,UAAUoX,OAAO,GAAKtU,GAAUV,EACzCwU,EAAEvT,EAAIwV,EAAKhB,EAAKoB,EAAKlB,EACrBnB,EAAEO,EAAI0B,EAAKf,EAAKmB,EAAKjB,EACrBpB,EAAExT,EAAI0V,EAAKjB,EAAKqB,EAAKnB,EACrBnB,EAAES,EAAIyB,EAAKhB,EAAKoB,EAAKlB,EAI7BpB,EAAEvT,GAAKwT,EACPD,EAAEO,GAAKN,EACPD,EAAExT,GAAK0T,EACPF,EAAES,GAAKP,GAGX,YAAAR,eAAA,WACI,IAAIrV,EAAO5E,KAAK4E,KAChB5E,KAAKuD,EAAIqB,EAAKrB,EACdvD,KAAKwD,EAAIoB,EAAKpB,EACdxD,KAAK2E,SAAWC,EAAKD,SACrB3E,KAAK8F,OAASlB,EAAKkB,OACnB9F,KAAK+F,OAASnB,EAAKmB,OACnB/F,KAAKwG,OAAS5B,EAAK4B,OACnBxG,KAAKyG,OAAS7B,EAAK6B,QAGvB,YAAAqW,kBAAA,WACI,OAAO1W,KAAK4V,MAAMhc,KAAKoZ,OAAOrS,EAAG/G,KAAKoZ,OAAOpS,GAAK,EAAArD,UAAUsY,QAGhE,YAAAc,kBAAA,WACI,OAAO3W,KAAK4V,MAAMhc,KAAKoZ,OAAO4B,EAAGhb,KAAKoZ,OAAO0B,GAAK,EAAAnX,UAAUsY,QAGhE,YAAAe,eAAA,WACI,IAAIzC,EAAIva,KAAKoZ,OACb,OAAOhT,KAAKsW,KAAKnC,EAAEvT,EAAIuT,EAAEvT,EAAIuT,EAAEO,EAAIP,EAAEO,IAGzC,YAAAmC,eAAA,WACI,IAAI1C,EAAIva,KAAKoZ,OACb,OAAOhT,KAAKsW,KAAKnC,EAAExT,EAAIwT,EAAExT,EAAIwT,EAAES,EAAIT,EAAES,IAOzC,YAAAkC,uBAAA,WACIld,KAAK+Z,cAAe,EACpB,IAAIZ,EAASnZ,KAAKmZ,OACdoB,EAAIva,KAAKoZ,OACb,GAAc,MAAVD,EAQA,OAPAnZ,KAAKwZ,GAAKe,EAAEL,GACZla,KAAKyZ,GAAKc,EAAEJ,GACZna,KAAK0Z,UAAYtT,KAAK4V,MAAMzB,EAAExT,EAAGwT,EAAEvT,GAAK,EAAArD,UAAUsY,OAClDjc,KAAK2Z,QAAUvT,KAAKsW,KAAKnC,EAAEvT,EAAIuT,EAAEvT,EAAIuT,EAAExT,EAAIwT,EAAExT,GAC7C/G,KAAK4Z,QAAUxT,KAAKsW,KAAKnC,EAAEO,EAAIP,EAAEO,EAAIP,EAAES,EAAIT,EAAES,GAC7Chb,KAAK6Z,QAAU,OACf7Z,KAAK8Z,QAAU1T,KAAK4V,MAAMzB,EAAEvT,EAAIuT,EAAEO,EAAIP,EAAExT,EAAIwT,EAAES,EAAGT,EAAEvT,EAAIuT,EAAES,EAAIT,EAAExT,EAAIwT,EAAEO,GAAK,EAAAnX,UAAUsY,QAGxF,IAAIkB,EAAKhE,EAAOC,OACZgE,EAAM,GAAKD,EAAGnW,EAAImW,EAAGnC,EAAImC,EAAGpW,EAAIoW,EAAGrC,GACnCuC,EAAK9C,EAAEL,GAAKiD,EAAGjD,GAAIoD,EAAK/C,EAAEJ,GAAKgD,EAAGhD,GACtCna,KAAKwZ,GAAM6D,EAAKF,EAAGnC,EAAIoC,EAAME,EAAKH,EAAGrC,EAAIsC,EACzCpd,KAAKyZ,GAAM6D,EAAKH,EAAGnW,EAAIoW,EAAMC,EAAKF,EAAGpW,EAAIqW,EACzC,IAAIG,EAAKH,EAAMD,EAAGnC,EACd1a,EAAK8c,EAAMD,EAAGnW,EACdwW,EAAKJ,EAAMD,EAAGrC,EACd2C,EAAKL,EAAMD,EAAGpW,EACd2W,EAAKH,EAAKhD,EAAEvT,EAAIwW,EAAKjD,EAAExT,EACvB4W,EAAKJ,EAAKhD,EAAEO,EAAI0C,EAAKjD,EAAES,EACvB4C,EAAKtd,EAAKia,EAAExT,EAAI0W,EAAKlD,EAAEvT,EACvB6W,EAAKvd,EAAKia,EAAES,EAAIyC,EAAKlD,EAAEO,EAG3B,GAFA9a,KAAK6Z,QAAU,EACf7Z,KAAK2Z,QAAUvT,KAAKsW,KAAKgB,EAAKA,EAAKE,EAAKA,GACpC5d,KAAK2Z,QAAU,KAAQ,CACvB,IAAImE,EAAMJ,EAAKG,EAAKF,EAAKC,EACzB5d,KAAK4Z,QAAUkE,EAAM9d,KAAK2Z,QAC1B3Z,KAAK8Z,QAAU1T,KAAK4V,MAAM0B,EAAKC,EAAKC,EAAKC,EAAIC,GAAO,EAAAna,UAAUsY,OAC9Djc,KAAK0Z,UAAYtT,KAAK4V,MAAM4B,EAAIF,GAAM,EAAA/Z,UAAUsY,YAEhDjc,KAAK2Z,QAAU,EACf3Z,KAAK4Z,QAAUxT,KAAKsW,KAAKiB,EAAKA,EAAKE,EAAKA,GACxC7d,KAAK8Z,QAAU,EACf9Z,KAAK0Z,UAAY,GAAKtT,KAAK4V,MAAM6B,EAAIF,GAAM,EAAAha,UAAUsY,QAI7D,YAAA8B,aAAA,SAAaC,GACT,IAAIzD,EAAIva,KAAKoZ,OACTpS,EAAIuT,EAAEvT,EAAGD,EAAIwT,EAAEO,EAAGA,EAAIP,EAAExT,EAAGiU,EAAIT,EAAES,EACjCiD,EAAS,GAAKjX,EAAIgU,EAAIjU,EAAI+T,GAC1BvX,EAAIya,EAAMza,EAAIgX,EAAEL,GAAI1W,EAAIwa,EAAMxa,EAAI+W,EAAEJ,GAGxC,OAFA6D,EAAMza,EAAKA,EAAIyX,EAAIiD,EAASza,EAAIuD,EAAIkX,EACpCD,EAAMxa,EAAKA,EAAIwD,EAAIiX,EAAS1a,EAAIuX,EAAImD,EAC7BD,GAGX,YAAAE,aAAA,SAAaC,GACT,IAAI5D,EAAIva,KAAKoZ,OACT7V,EAAI4a,EAAM5a,EAAGC,EAAI2a,EAAM3a,EAG3B,OAFA2a,EAAM5a,EAAIA,EAAIgX,EAAEvT,EAAIxD,EAAI+W,EAAEO,EAAIP,EAAEL,GAChCiE,EAAM3a,EAAID,EAAIgX,EAAExT,EAAIvD,EAAI+W,EAAES,EAAIT,EAAEJ,GACzBgE,GAGX,YAAAC,qBAAA,SAAsBC,GAClB,IAAI9B,EAAM,EAAA5Y,UAAUoX,OAAOsD,GAAgB/B,EAAM,EAAA3Y,UAAUkX,OAAOwD,GAC9DC,EAAMte,KAAKoZ,OACf,OAAOhT,KAAK4V,MAAMsC,EAAItX,EAAIuV,EAAM+B,EAAIvX,EAAIuV,EAAKgC,EAAItD,EAAIsB,EAAMgC,EAAIxD,EAAIyB,GAAO,EAAA5Y,UAAUsY,QAGxF,YAAAsC,qBAAA,SAAsBC,GAClB,IAAIjC,EAAM,EAAA5Y,UAAUoX,OAAOyD,GAAgBlC,EAAM,EAAA3Y,UAAUkX,OAAO2D,GAC9DF,EAAMte,KAAKoZ,OACf,OAAOhT,KAAK4V,MAAMM,EAAMgC,EAAIvX,EAAIwV,EAAM+B,EAAItD,EAAGsB,EAAMgC,EAAItX,EAAIuV,EAAM+B,EAAIxD,GAAK,EAAAnX,UAAUsY,QAGxF,YAAAwC,YAAA,SAAara,GACT,IAAIka,EAAMte,KAAKoZ,OACXpS,EAAIsX,EAAItX,EAAGD,EAAIuX,EAAIxD,EAAGA,EAAIwD,EAAIvX,EAAGiU,EAAIsD,EAAItD,EACzCsB,EAAM,EAAA3Y,UAAUkX,OAAOzW,GAAUmY,EAAM,EAAA5Y,UAAUoX,OAAO3W,GAC5Dka,EAAItX,EAAIsV,EAAMtV,EAAIuV,EAAMzB,EACxBwD,EAAIxD,EAAIwB,EAAMvV,EAAIwV,EAAMvB,EACxBsD,EAAIvX,EAAIwV,EAAMvV,EAAIsV,EAAMxB,EACxBwD,EAAItD,EAAIuB,EAAMxV,EAAIuV,EAAMtB,EACxBhb,KAAK+Z,cAAe,GAjSjB,EAAAY,OAAiB,EAmS5B,EApSA,GAAa,EAAAD,KAAI,EADA,GAAAlb,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,IA0BY8b,EA1BZ,EAiBI,SAAY/Y,EAAe3C,EAAcuZ,GACrC,GAbJ,KAAA5V,EAAI,EACJ,KAAAC,EAAI,EACJ,KAAAmB,SAAW,EACX,KAAAmB,OAAS,EACT,KAAAC,OAAS,EACT,KAAAS,OAAS,EACT,KAAAC,OAAS,EACT,KAAA4U,cAAgBC,EAAcC,OAC9B,KAAAmD,cAAe,EAEf,KAAA9X,MAAQ,IAAI,EAAA+X,MAGJpc,EAAQ,EAAG,MAAM,IAAIxC,MAAM,uBAC/B,GAAY,MAARH,EAAc,MAAM,IAAIG,MAAM,wBAClCC,KAAKuC,MAAQA,EACbvC,KAAKJ,KAAOA,EACZI,KAAKmZ,OAASA,GAtBT,EAAAyF,SAAQ,EA0BrB,SAAYtD,GACR,uBAAQ,yCAAiB,uDAAwB,yBAAS,iDAD9D,CAAYA,EAAA,EAAAA,gBAAA,EAAAA,cAAa,KA3BR,GAAA9b,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCDpB,SAAUA,IAAW,SAAAC,GACjB,MACI,SAAmBI,EAAqBif,EAAsBH,GAA3C,KAAA9e,OAAqB,KAAAif,QAAsB,KAAAH,gBAD5C,EAAAI,eAAc,EADnB,GAAAtf,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCCpB,SAAUA,IAAW,SAAAC,GACjB,MAUI,SAAYkB,EAAckE,GACtB,GAAY,MAARA,EAAc,MAAM,IAAI7E,MAAM,wBAClCC,KAAKU,KAAOA,EACZV,KAAK4E,KAAOA,GAbP,EAAAma,MAAK,EADD,GAAAvf,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,MASI,SAAaI,GACTI,KAAKJ,KAAOA,GAVP,EAAAof,UAAS,EADL,GAAAxf,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,iBAWI,WAAaoF,EAAwBpE,GACjC,GARJ,KAAA6K,cAAgB,EAChB,KAAAC,UAAW,EACX,KAAAC,SAAU,EACV,KAAAJ,IAAM,EACN,KAAAC,SAAW,EACX,KAAA3G,QAAS,EAGO,MAARG,EAAc,MAAM,IAAI7E,MAAM,wBAClC,GAAgB,MAAZS,EAAkB,MAAM,IAAIT,MAAM,4BACtCC,KAAK4E,KAAOA,EACZ5E,KAAKmL,IAAMvG,EAAKuG,IAChBnL,KAAKoL,SAAWxG,EAAKwG,SACrBpL,KAAKqL,cAAgBzG,EAAKyG,cAC1BrL,KAAKsL,SAAW1G,EAAK0G,SACrBtL,KAAKuL,QAAU3G,EAAK2G,QAEpBvL,KAAKwE,MAAQ,IAAIsE,MACjB,IAAK,IAAI5I,EAAI,EAAGA,EAAI0E,EAAKJ,MAAMrE,OAAQD,IACnCF,KAAKwE,MAAMkG,KAAKlK,EAASye,SAASra,EAAKJ,MAAMtE,GAAGN,OACpDI,KAAKkB,OAASV,EAASye,SAASra,EAAK1D,OAAOtB,MAgOpD,OA7NI,YAAAwa,SAAA,WACI,OAAOpa,KAAKyE,QAGhB,YAAAlE,MAAA,WACIP,KAAK5B,UAGT,YAAAA,OAAA,WACI,IAAI8C,EAASlB,KAAKkB,OACdsD,EAAQxE,KAAKwE,MACjB,OAAQA,EAAMrE,QACV,KAAK,EACDH,KAAKkf,OAAO1a,EAAM,GAAItD,EAAOie,OAAQje,EAAOke,OAAQpf,KAAKsL,SAAUtL,KAAKuL,QAASvL,KAAK4E,KAAKya,QAASrf,KAAKmL,KACzG,MACJ,KAAK,EACDnL,KAAKsf,OAAO9a,EAAM,GAAIA,EAAM,GAAItD,EAAOie,OAAQje,EAAOke,OAAQpf,KAAKqL,cAAerL,KAAKuL,QAASvL,KAAKoL,SAAUpL,KAAKmL,OAOhI,YAAA+T,OAAA,SAAQ3a,EAAYgb,EAAiBC,EAAiBlU,EAAmBC,EAAkB8T,EAAkBze,GACpG2D,EAAKwV,cAAcxV,EAAK2Y,yBAC7B,IAAIuC,EAAIlb,EAAK4U,OAAOC,OAGhB6B,EAAKwE,EAAEzY,EAAGkU,EAAKuE,EAAE3E,EAAGK,EAAKsE,EAAE1Y,EAAGqU,EAAKqE,EAAEzE,EACrC0E,GAAcnb,EAAKsV,QAAUtV,EAAKmV,UAAWQ,EAAK,EAAGC,EAAK,EAE9D,OAAO5V,EAAKK,KAAKyW,eACb,KAAK,EAAAC,cAAcM,gBACf1B,EAAKqF,EAAUhb,EAAK4a,OACpBhF,EAAKqF,EAAUjb,EAAK6a,OACpB,MACJ,KAAK,EAAA9D,cAAcO,uBACf,IAAIE,EAAI3V,KAAKC,IAAI4U,EAAKG,EAAKF,EAAKC,IAAOF,EAAKA,EAAKE,EAAKA,GAClDwE,EAAK1E,EAAK1W,EAAK/D,SAASsF,OACxB8Z,EAAKzE,EAAK5W,EAAK/D,SAASuF,OAC5BmV,GAAM0E,EAAK7D,EAAIxX,EAAK/D,SAASsF,OAC7BsV,EAAKuE,EAAK5D,EAAIxX,EAAK/D,SAASuF,OAC5B2Z,GAActZ,KAAK4V,MAAM4D,EAAID,GAAM,EAAAhc,UAAUsY,OAEjD,QACI,IAAI1Y,EAAIgc,EAAUE,EAAEvF,GAAI1W,EAAIgc,EAAUC,EAAEtF,GACpCa,EAAIC,EAAKG,EAAKF,EAAKC,EACvBjB,GAAM3W,EAAI6X,EAAK5X,EAAI0X,GAAMF,EAAIzW,EAAKiV,GAClCW,GAAM3W,EAAIyX,EAAK1X,EAAI4X,GAAMH,EAAIzW,EAAKkV,GAE1CiG,GAActZ,KAAK4V,MAAM7B,EAAID,GAAM,EAAAvW,UAAUsY,OAEzC1X,EAAKoV,QAAU,IAAG+F,GAAc,KAChCA,EAAa,IACbA,GAAc,IACTA,GAAc,MAAKA,GAAc,KAC1C,IAAIlF,EAAKjW,EAAKoV,QAASc,EAAKlW,EAAKqV,QACjC,GAAItO,GAAYC,EAAS,CACrB,OAAQhH,EAAKK,KAAKyW,eACd,KAAK,EAAAC,cAAcc,QACnB,KAAK,EAAAd,cAAce,oBACfnC,EAAKqF,EAAUhb,EAAK4a,OACpBhF,EAAKqF,EAAUjb,EAAK6a,OAE5B,IAAIrY,EAAIxC,EAAKK,KAAKzE,OAASqa,EAAIqF,EAAKzZ,KAAKsW,KAAKxC,EAAKA,EAAKC,EAAKA,GAC7D,GAAK7O,GAAYuU,EAAK9Y,GAAOwE,GAAWsU,EAAK9Y,GAAMA,EAAI,KAEnDyT,GADIuB,GAAK8D,EAAK9Y,EAAI,GAAKnG,EAAQ,EAE3Bye,IAAS5E,GAAMsB,GAG3BxX,EAAK8V,yBAAyB9V,EAAKiV,GAAIjV,EAAKkV,GAAIlV,EAAKmV,UAAYgG,EAAa9e,EAAO4Z,EAAIC,EAAIlW,EAAKsV,QAC9FtV,EAAKuV,UAMb,YAAAwF,OAAA,SAAQnG,EAAc2G,EAAaP,EAAiBC,EAAiBO,EAAiBxU,EAAkBH,EAAkBxK,GACtH,GAAa,GAATA,EAAJ,CAIKuY,EAAOY,cAAcZ,EAAO+D,yBAC5B4C,EAAM/F,cAAc+F,EAAM5C,yBAC/B,IAAI8C,EAAK7G,EAAOK,GAAIyG,EAAK9G,EAAOM,GAAIyG,EAAM/G,EAAOQ,QAASa,EAAK0F,EAAKC,EAAMhH,EAAOS,QAASwG,EAAMN,EAAMnG,QAClG0G,EAAOlH,EAAOC,OACdkH,EAAM,EAAGC,EAAM,EAAGC,EAAK,EACvBN,EAAM,GACNA,GAAOA,EACPI,EAAM,IACNE,GAAM,IAENF,EAAM,EACNE,EAAK,GAELL,EAAM,IACNA,GAAOA,EACPK,GAAMA,GAENJ,EAAM,GACNA,GAAOA,EACPG,EAAM,KAENA,EAAM,EACV,IAAIE,EAAKX,EAAMtG,GAAIkH,EAAK,EAAGC,EAAM,EAAGC,EAAM,EAAG5Z,EAAIqZ,EAAKrZ,EAAGD,EAAIsZ,EAAKvF,EAAGA,EAAIuF,EAAKtZ,EAAGiU,EAAIqF,EAAKrF,EACtF6F,EAAIza,KAAKC,IAAI6Z,EAAMC,IAAQ,KAC1BU,GAMDF,EAAM3Z,EAAIyZ,EAAK1Z,GADf2Z,EAAKZ,EAAMrG,IACa4G,EAAKnG,GAC7B0G,EAAM9F,EAAI2F,EAAKzF,EAAI0F,EAAKL,EAAKlG,KAN7BuG,EAAK,EACLC,EAAM3Z,EAAIyZ,EAAKJ,EAAKnG,GACpB0G,EAAM9F,EAAI2F,EAAKJ,EAAKlG,IAMxB,IAAI2G,EAAK3H,EAAOA,OAAOC,OACvBpS,EAAI8Z,EAAG9Z,EACPD,EAAI+Z,EAAGhG,EACPA,EAAIgG,EAAG/Z,EAEP,IAEqEga,EAAIC,EAFrE1gB,EAAK,GAAK0G,GADdgU,EAAI8F,EAAG9F,GACejU,EAAI+T,GAAIvX,EAAIod,EAAMG,EAAG5G,GAAI1W,EAAIod,EAAME,EAAG3G,GACxDkD,GAAM9Z,EAAIyX,EAAIxX,EAAIuD,GAAKzG,EAAK0f,EAAI1C,GAAM9Z,EAAIwD,EAAIzD,EAAIuX,GAAKxa,EAAK2f,EAC5DgB,EAAK7a,KAAKsW,KAAKW,EAAKA,EAAKC,EAAKA,GAAK4D,EAAKpB,EAAMlb,KAAKzE,OAASigB,EAChE,GAAIa,EAAK,KAGL,OAFAjhB,KAAKkf,OAAO/F,EAAQoG,EAASC,GAAS,EAAOjU,GAAS,EAAO3K,QAC7Dkf,EAAMzF,yBAAyBoG,EAAIC,EAAI,EAAGZ,EAAMnG,QAASmG,EAAMlG,QAASkG,EAAMjG,QAASiG,EAAMhG,SAKjG,IAAII,IAFJ3W,EAAIgc,EAAUuB,EAAG5G,IAEHc,GADdxX,EAAIgc,EAAUsB,EAAG3G,IACKpT,GAAKzG,EAAK0f,EAAI7F,GAAM3W,EAAIwD,EAAIzD,EAAIuX,GAAKxa,EAAK2f,EAC5DJ,EAAK3F,EAAKA,EAAKC,EAAKA,EACxB,GAAgB,GAAZ/O,EAAe,CACfA,GAAY8U,GAAOE,EAAM,GAAK,EAC9B,IAAIe,EAAK/a,KAAKsW,KAAKmD,GAAKuB,EAAKD,EAAKF,EAAKC,EAAKhB,EAAM9U,EAClD,GAAIgW,EAAK,EAAG,CACR,IAAI3B,EAAIrZ,KAAKuN,IAAI,EAAGyN,GAAiB,EAAXhW,IAAiB,EAI3CyU,GAFA3F,IADAuF,GAAK2B,EAAKhW,GAAY,EAAIqU,EAAIA,IAAM0B,GAC1BjH,GAEAA,GADVC,GAAMsF,EAAItF,GACUA,GAG5BlF,EACI,GAAI4L,EAAG,CAEH,IAAIvE,GAAOuD,EAAKoB,EAAKA,GADrBC,GAAMhB,GACyBgB,IAAO,EAAID,EAAKC,GAC3C5E,GAAO,EACPA,GAAO,EACFA,EAAM,IACXA,EAAM,EACF/Q,IAASiP,IAAOpU,KAAKsW,KAAKmD,IAAOoB,EAAKC,GAAM,GAAKtgB,EAAQ,IAEjEogB,EAAK5a,KAAKib,KAAK/E,GAAOyD,EACtB/Y,EAAIia,EAAKC,EAAK5E,EACdvV,EAAIma,EAAK9a,KAAKmW,IAAIyE,GAClBD,EAAK3a,KAAK4V,MAAM7B,EAAKnT,EAAIkT,EAAKnT,EAAGmT,EAAKlT,EAAImT,EAAKpT,OAC5C,CAGH,IAAIua,GAFJta,EAAIkZ,EAAMgB,GAEGla,EAAGua,GADhBxa,EAAIoZ,EAAMe,GACena,EAAGya,EAAKpb,KAAK4V,MAAM7B,EAAID,GAE5CuH,GAAM,EAAIF,EAAKN,EAAIS,EAAKH,EAAKD,EAEjC,IADAtG,EAAIyG,EAAKA,EAAK,EAAIC,GAFlB5G,EAAIyG,EAAKN,EAAKA,EAAKK,EAAKzB,EAAKyB,EAAKC,KAGzB,EAAG,CACR,IAAII,EAAIvb,KAAKsW,KAAK1B,GACdyG,EAAK,IAAGE,GAAKA,GAEjB,IAAIC,GADJD,IAAMF,EAAKE,GAAK,GACHD,EAAIhP,EAAKoI,EAAI6G,EACtBrc,EAAIc,KAAKC,IAAIub,GAAMxb,KAAKC,IAAIqM,GAAMkP,EAAKlP,EAC3C,GAAIpN,EAAIA,GAAKua,EAAI,CACbrc,EAAI4C,KAAKsW,KAAKmD,EAAKva,EAAIA,GAAKya,EAC5BgB,EAAKS,EAAKpb,KAAK4V,MAAMxY,EAAG8B,GACxB0b,EAAK5a,KAAK4V,MAAMxY,EAAI2c,GAAM7a,EAAI2b,GAAMf,GACpC,MAAMjL,GAGd,IAAI4M,GAAW,EAAAle,UAAUgZ,GAAImF,GAAOb,EAAKja,EAAG+a,GAAUD,GAAOA,GAAME,GAAO,EACtEC,GAAW,EAAGC,GAAOjB,EAAKja,EAAGmb,GAAUD,GAAOA,GAAME,GAAO,GAC/DtH,GAAK9T,EAAIia,GAAMK,EAAKC,MACV,GAAKzG,GAAK,IAChBA,EAAI1U,KAAKib,KAAKvG,IAGdE,GAFAzX,EAAIyD,EAAIZ,KAAKkW,IAAIxB,GAAKmG,GAEd1d,GADRC,EAAIuD,EAAIX,KAAKmW,IAAIzB,IACDtX,GACRue,KACJF,GAAW/G,EACXiH,GAAU/G,EACV8G,GAAOve,EACPye,GAAOxe,GAEPwX,EAAImH,KACJF,GAAWnH,EACXqH,GAAUnH,EACVkH,GAAO3e,EACP6e,GAAO5e,IAGXqc,IAAOkC,GAAUI,IAAW,GAC5BpB,EAAKS,EAAKpb,KAAK4V,MAAMgG,GAAOjC,EAAS+B,IACrCd,EAAKa,GAAW9B,IAEhBgB,EAAKS,EAAKpb,KAAK4V,MAAMoG,GAAOrC,EAASmC,IACrClB,EAAKiB,GAAWlC,GAG5B,IAAIsC,GAAKjc,KAAK4V,MAAM0E,EAAID,GAAMD,EAC1B7b,GAAWwU,EAAOO,WACtBqH,GAAMA,EAAKsB,IAAM,EAAA1e,UAAUsY,OAASqE,EAAM3b,IACjC,IACLoc,GAAM,IACDA,GAAM,MAAKA,GAAM,KAC1B5H,EAAOkB,yBAAyB2F,EAAIC,EAAItb,GAAWoc,EAAKngB,EAAO4Z,EAAIrB,EAAOS,QAAS,EAAG,GACtFjV,GAAWmb,EAAMpG,WACjBsH,IAAOA,EAAKqB,IAAM,EAAA1e,UAAUsY,OAAS6D,EAAMjG,SAAW2G,EAAKD,EAAM5b,IACxD,IACLqc,GAAM,IACDA,GAAM,MAAKA,GAAM,KAC1BlB,EAAMzF,yBAAyBoG,EAAIC,EAAI/b,GAAWqc,EAAKpgB,EAAOkf,EAAMnG,QAASmG,EAAMlG,QAASkG,EAAMjG,QAASiG,EAAMhG,cA3I7GgG,EAAMxF,wBA6IlB,EAxPA,GAAa,EAAAgI,aAAY,EADR,GAAA9iB,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,kBAUI,WAAaI,GAAb,MACI,YAAMA,EAAM,GAAG,IAAM,K,OAVzB,EAAA4E,MAAQ,IAAIsE,MAEZ,EAAAuC,cAAgB,EAChB,EAAAC,UAAW,EACX,EAAAC,SAAU,EACV,EAAA8T,SAAU,EACV,EAAAlU,IAAM,EACN,EAAAC,SAAW,E,EAKf,OAbsC,OAatC,EAbA,CAAsC,EAAA0T,gBAAzB,EAAAyD,iBAAgB,EADZ,GAAA/iB,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,iBAeI,WAAaoF,EAA0BpE,GACnC,GATJ,KAAAmN,SAAW,EAAG,KAAAG,QAAU,EAAG,KAAAtB,UAAY,EAAG,KAAAC,aAAe,EAEzD,KAAA+V,OAAS,IAAI1Z,MAAiB,KAAA2Z,UAAY,IAAI3Z,MAC9C,KAAAkV,MAAQ,IAAIlV,MAAiB,KAAAnH,OAAS,IAAImH,MAAiB,KAAA4Z,QAAU,IAAI5Z,MACzE,KAAA6Z,SAAW,IAAI7Z,MAEf,KAAArE,QAAS,EAGO,MAARG,EAAc,MAAM,IAAI7E,MAAM,wBAClC,GAAgB,MAAZS,EAAkB,MAAM,IAAIT,MAAM,4BACtCC,KAAK4E,KAAOA,EACZ5E,KAAKwE,MAAQ,IAAIsE,MACjB,IAAK,IAAI5I,EAAI,EAAGa,EAAI6D,EAAKJ,MAAMrE,OAAQD,EAAIa,EAAGb,IAC1CF,KAAKwE,MAAMkG,KAAKlK,EAASye,SAASra,EAAKJ,MAAMtE,GAAGN,OACpDI,KAAKkB,OAASV,EAASoiB,SAAShe,EAAK1D,OAAOtB,MAC5CI,KAAK2N,SAAW/I,EAAK+I,SACrB3N,KAAK8N,QAAUlJ,EAAKkJ,QACpB9N,KAAKwM,UAAY5H,EAAK4H,UACtBxM,KAAKyM,aAAe7H,EAAK6H,aA8VjC,OA3VI,YAAA2N,SAAA,WACI,OAAOpa,KAAKyE,QAGhB,YAAAlE,MAAA,WACIP,KAAK5B,UAGT,YAAAA,OAAA,WACI,IAAI2K,EAAa/I,KAAKkB,OAAOgI,gBAC7B,GAAMH,aAAsB,EAAA6P,eAA5B,CAEA,IAAIpM,EAAYxM,KAAKwM,UAAWC,EAAezM,KAAKyM,aAClBxI,EAASuI,EAAY,EACvD,GADgBC,EAAe,GACZxI,EAAnB,CAEA,IAAIW,EAAO5E,KAAK4E,KACZie,EAAcje,EAAKie,YACnBC,EAAgBD,GAAe,EAAAE,YAAYC,OAC3CC,EAAare,EAAKqe,WAClBC,EAAWD,GAAc,EAAAE,WAAWC,QAASvd,EAAQod,GAAc,EAAAE,WAAWE,WAC9EC,EAAYtjB,KAAKwE,MAAMrE,OAAQojB,EAAcL,EAAWI,EAAYA,EAAY,EAChF9e,EAAQxE,KAAKwE,MACbge,EAAS,EAAA5gB,MAAMmI,aAAa/J,KAAKwiB,OAAQe,GAAcb,EAAyB,KAChF5U,EAAU9N,KAAK8N,QACnB,GAAIjI,GAASid,EAAe,CACpBjd,IAAO6c,EAAU,EAAA9gB,MAAMmI,aAAa/J,KAAK0iB,QAASY,IACtD,IAAK,IAAIpjB,EAAI,EAAGa,EAAIwiB,EAAc,EAAGrjB,EAAIa,GAAI,CACzC,IACIyiB,GADAjf,EAAOC,EAAMtE,IACM0E,KAAKzE,OAC5B,GAAIqjB,EAAcC,EAAeC,QACzB7d,IAAO6c,EAAQxiB,GAAK,GACxBsiB,IAAStiB,GAAK,MACX,CACH,IAAIqD,EAAIigB,EAAcjf,EAAK6U,OAAOpS,EAAGxD,EAAIggB,EAAcjf,EAAK6U,OAAOrS,EAC/D,EAASX,KAAKsW,KAAKnZ,EAAIA,EAAIC,EAAIA,GAC/BqC,IAAO6c,EAAQxiB,GAAK,GACxBsiB,IAAStiB,IAAM4iB,EAAgBU,EAAc1V,EAAUA,GAAW,EAAS0V,SAInF,IAAStjB,EAAI,EAAGA,EAAIqjB,EAAarjB,IAC7BsiB,EAAOtiB,GAAK4N,EAGpB,IAAI2U,EAAYziB,KAAK2jB,sBAAsC5a,EAAYwa,EAAaL,EAChFte,EAAKgf,cAAgB,EAAAC,aAAaC,QAASjB,GAAe,EAAAE,YAAYe,SACtEC,EAAQtB,EAAU,GAAIuB,EAAQvB,EAAU,GAAIwB,EAAiBrf,EAAKqf,eAClEC,GAAM,EACV,GAAsB,GAAlBD,EACAC,EAAMjB,GAAc,EAAAE,WAAWgB,WAE/BD,GAAM,EAEND,IADIxE,EAAIzf,KAAKkB,OAAOqD,KAAK6U,QACLpS,EAAIyY,EAAEzE,EAAIyE,EAAE1Y,EAAI0Y,EAAE3E,EAAI,EAAI,EAAAnX,UAAUygB,QAAU,EAAAzgB,UAAUygB,OAEvElkB,EAAI,EAAb,IAAK,IAAWuf,EAAI,EAAGvf,EAAIojB,EAAWpjB,IAAKuf,GAAK,EAAG,CAC/C,IAAIlb,EACA+Z,GADA/Z,EAAOC,EAAMtE,IACFkZ,OACfkF,EAAIpE,KAAO6J,EAAQzF,EAAIpE,IAAMzN,EAC7B6R,EAAInE,KAAO6J,EAAQ1F,EAAInE,IAAM1N,EAC7B,IAA4C4Q,GAAxC9Z,EAAIkf,EAAUhD,IAAmCsE,EAAOzG,GAAtC9Z,EAAIif,EAAUhD,EAAI,IAA6BuE,EACrE,GAAIne,EAAO,CACP,IAAI,EAAS6c,EAAQxiB,GACrB,GAAc,GAAV,EAAa,CACb,IAAI6b,GAAK3V,KAAKsW,KAAKW,EAAKA,EAAKC,EAAKA,GAAM,EAAS,GAAK9Q,EAAY,EAClE8R,EAAItX,GAAK+U,EACTuC,EAAIvX,GAAKgV,GAKjB,GAFAgI,EAAQxgB,EACRygB,EAAQxgB,EACJS,EAAQ,CACR,IAAI+C,EAAIsX,EAAItX,EAAGD,EAAIuX,EAAIxD,EAAGA,EAAIwD,EAAIvX,EAAGiU,EAAIsD,EAAItD,EAAG1V,EAAI,EAAGgX,EAAM,EAAGC,EAAM,EAQtE,GANIjX,EADA4d,EACIT,EAAUhD,EAAI,GACI,GAAjB+C,EAAOtiB,EAAI,GACZuiB,EAAUhD,EAAI,GAEdrZ,KAAK4V,MAAMsB,EAAID,GACvB/X,GAAKc,KAAK4V,MAAMlB,EAAG9T,GACfkd,EAAK,CACL5H,EAAMlW,KAAKkW,IAAIhX,GACfiX,EAAMnW,KAAKmW,IAAIjX,GACf,IAAI,EAASf,EAAKK,KAAKzE,OACvB4jB,IAAU,GAAUzH,EAAMtV,EAAIuV,EAAMzB,GAAKuC,GAAM7Q,EAC/CwX,IAAU,GAAUzH,EAAMvV,EAAIsV,EAAMxB,GAAKwC,GAAM9Q,OAE/ClH,GAAK2e,EAEL3e,EAAI,EAAA3B,UAAUgZ,GACdrX,GAAK,EAAA3B,UAAU0gB,IACV/e,GAAK,EAAA3B,UAAUgZ,KACpBrX,GAAK,EAAA3B,UAAU0gB,KACnB/e,GAAKkH,EACL8P,EAAMlW,KAAKkW,IAAIhX,GACfiX,EAAMnW,KAAKmW,IAAIjX,GACfgZ,EAAItX,EAAIsV,EAAMtV,EAAIuV,EAAMzB,EACxBwD,EAAIxD,EAAIwB,EAAMvV,EAAIwV,EAAMvB,EACxBsD,EAAIvX,EAAIwV,EAAMvV,EAAIsV,EAAMxB,EACxBwD,EAAItD,EAAIuB,EAAMxV,EAAIuV,EAAMtB,EAE5BzW,EAAKwV,cAAe,MAI5B,YAAA4J,sBAAA,SAAuBxL,EAAsBoL,EAAqBL,EAAmBoB,EAC9DC,GACnB,IAAIrjB,EAASlB,KAAKkB,OACdyM,EAAW3N,KAAK2N,SAChB6U,EAASxiB,KAAKwiB,OAAQgC,EAAM,EAAA5iB,MAAMmI,aAAa/J,KAAKyiB,UAAyB,EAAdc,EAAkB,GAAIvF,EAAuB,KAC5GyG,EAAStM,EAAKsM,OACdC,EAAiBvM,EAAKwM,oBAAqBC,EAAaF,EAAiB,EAAGG,EAAYpB,EAAeqB,KAE3G,IAAK3M,EAAK4M,cAAe,CACrB,IAAIrC,EAAUvK,EAAKuK,QAEf,EAAaA,EADjBkC,GAAcH,EAAS,EAAI,GAG3B,GADIH,IAAiB3W,GAAY,GAC7B4W,EACA,IAAK,IAAIrkB,EAAI,EAAGA,EAAIqjB,EAAarjB,IAC7BsiB,EAAOtiB,IAAM,EAErB8d,EAAQ,EAAApc,MAAMmI,aAAa/J,KAAKge,MAAO,GAC9B9d,EAAI,EAAb,IAAK,IAAW8kB,EAAI,EAAGC,EAAQ,EAAG/kB,EAAIqjB,EAAarjB,IAAK8kB,GAAK,EAAG,CAC5D,IAEIvF,EADJ9R,GADIuX,EAAQ1C,EAAOtiB,GAInB,GAAIukB,GACAhF,GAAK,GACG,IAAGA,GAAK,GAChBwF,EAAQ,MACL,IAAIxF,EAAI,EAAG,CACVoF,GAAapB,EAAe0B,SAC5BN,EAAYpB,EAAe0B,OAC3BhN,EAAKiN,qBAAqBlkB,EAAQ,EAAG,EAAG8c,EAAO,EAAG,IAEtDhe,KAAKqlB,kBAAkB5F,EAAGzB,EAAO,EAAGwG,EAAKQ,GACzC,SACG,GAAIvF,EAAI,EAAY,CACnBoF,GAAapB,EAAe6B,QAC5BT,EAAYpB,EAAe6B,MAC3BnN,EAAKiN,qBAAqBlkB,EAAQwjB,EAAiB,EAAG,EAAG1G,EAAO,EAAG,IAEvEhe,KAAKulB,iBAAiB9F,EAAI,EAAYzB,EAAO,EAAGwG,EAAKQ,GACrD,UAIJ,MAAQC,IAAS,CACb,IAAI,EAASvC,EAAQuC,GACrB,KAAIxF,EAAI,GAAR,CACA,GAAa,GAATwF,EACAxF,GAAK,OAGLA,GAAKA,GADDpV,EAAOqY,EAAQuC,EAAQ,MACT,EAAS5a,GAE/B,OAEA4a,GAASJ,IACTA,EAAYI,EACRR,GAAUQ,GAASL,GACnBzM,EAAKiN,qBAAqBlkB,EAAQwjB,EAAiB,EAAG,EAAG1G,EAAO,EAAG,GACnE7F,EAAKiN,qBAAqBlkB,EAAQ,EAAG,EAAG8c,EAAO,EAAG,IAElD7F,EAAKiN,qBAAqBlkB,EAAgB,EAAR+jB,EAAY,EAAG,EAAGjH,EAAO,EAAG,IAEtEhe,KAAKwlB,iBAAiB/F,EAAGzB,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIwG,EAAKQ,EAC1G9B,GAAahjB,EAAI,GAAc,GAATglB,GAE9B,OAAOV,EAIPC,GACAC,GAAkB,EAClB1G,EAAQ,EAAApc,MAAMmI,aAAa/J,KAAKge,MAAO0G,GACvCvM,EAAKiN,qBAAqBlkB,EAAQ,EAAGwjB,EAAiB,EAAG1G,EAAO,EAAG,GACnE7F,EAAKiN,qBAAqBlkB,EAAQ,EAAG,EAAG8c,EAAO0G,EAAiB,EAAG,GACnE1G,EAAM0G,EAAiB,GAAK1G,EAAM,GAClCA,EAAM0G,EAAiB,GAAK1G,EAAM,KAElC4G,IACAF,GAAkB,EAClB1G,EAAQ,EAAApc,MAAMmI,aAAa/J,KAAKge,MAAO0G,GACvCvM,EAAKiN,qBAAqBlkB,EAAQ,EAAGwjB,EAAgB1G,EAAO,EAAG,IAQnE,IAJA,IAAIrc,EAAS,EAAAC,MAAMmI,aAAa/J,KAAK2B,OAAQijB,GACzCa,EAAa,EACbC,EAAK1H,EAAM,GAAI2H,EAAK3H,EAAM,GAAIrb,EAAM,EAAGC,EAAM,EAAGC,EAAM,EAAGC,EAAM,EAAG8iB,EAAK,EAAGC,EAAK,EAC/E9iB,EAAO,EAAGC,EAAO,EAAGC,EAAQ,EAAGC,EAAQ,EAAGC,EAAO,EAAGC,EAAO,EAAGC,EAAM,EAAGC,EAAM,EACjEwiB,GAAP5lB,EAAI,EAAO,GAAGA,EAAI0kB,EAAY1kB,IAAK4lB,GAAK,EAC7CnjB,EAAMqb,EAAM8H,GACZljB,EAAMob,EAAM8H,EAAI,GAChBjjB,EAAMmb,EAAM8H,EAAI,GAChBhjB,EAAMkb,EAAM8H,EAAI,GAOhB3iB,EAAc,GAJdJ,EAA8B,OAAtB2iB,EAAW,EAAN/iB,EAAUE,KAEvBI,EAAsC,QAAf,GAAbN,EAAME,GAAW6iB,GAJ3BE,EAAK5H,EAAM8H,EAAI,MAOf1iB,EAAc,GAJdJ,EAA8B,OAAtB2iB,EAAW,EAAN/iB,EAAUE,KAEvBI,EAAsC,QAAf,GAAbN,EAAME,GAAW6iB,GAJ3BE,EAAK7H,EAAM8H,EAAI,MAOfziB,EAAmB,KAAZV,EAAM+iB,GAAa3iB,EAAe,UAARE,EACjCK,EAAmB,KAAZV,EAAM+iB,GAAa3iB,EAAe,UAARE,EACjCuiB,GAAcrf,KAAKsW,KAAKrZ,EAAMA,EAAMC,EAAMA,GAC1CD,GAAOF,EACPG,GAAOF,EACPD,GAAQF,EACRG,GAAQF,EACRuiB,GAAcrf,KAAKsW,KAAKrZ,EAAMA,EAAMC,EAAMA,GAC1CD,GAAOF,EACPG,GAAOF,EACPqiB,GAAcrf,KAAKsW,KAAKrZ,EAAMA,EAAMC,EAAMA,GAC1CD,GAAOF,EAAOF,EACdK,GAAOF,EAAOF,EACduiB,GAAcrf,KAAKsW,KAAKrZ,EAAMA,EAAMC,EAAMA,GAC1C3B,EAAOzB,GAAKulB,EACZC,EAAKE,EACLD,EAAKE,EAGT,GADIvB,IAAiB3W,GAAY8X,GAC7BlB,EACA,IAASrkB,EAAI,EAAGA,EAAIqjB,EAAarjB,IAC7BsiB,EAAOtiB,IAAMulB,EAKrB,IAFA,IAAI9C,EAAW3iB,KAAK2iB,SAChBoD,EAAc,EACgBC,GAAzB9lB,EAAI,EAAG8kB,EAAI,EAAGC,EAAQ,EAAa,GAAG/kB,EAAIqjB,EAAarjB,IAAK8kB,GAAK,EAAG,CACzE,IAAIE,EAEAzF,EADJ9R,GADIuX,EAAQ1C,EAAOtiB,GAInB,GAAIukB,GACAhF,GAAKgG,GACG,IAAGhG,GAAKgG,GAChBR,EAAQ,MACL,IAAIxF,EAAI,EAAG,CACdzf,KAAKqlB,kBAAkB5F,EAAGzB,EAAO,EAAGwG,EAAKQ,GACzC,SACG,GAAIvF,EAAIgG,EAAY,CACvBzlB,KAAKulB,iBAAiB9F,EAAIgG,EAAYzH,EAAO0G,EAAiB,EAAGF,EAAKQ,GACtE,UAIJ,MAAQC,IAAS,CACb,IAAI,EAAStjB,EAAOsjB,GACpB,KAAIxF,EAAI,GAAR,CACA,GAAa,GAATwF,EACAxF,GAAK,OAGLA,GAAKA,GADDpV,EAAO1I,EAAOsjB,EAAQ,MACR,EAAS5a,GAE/B,OAIJ,GAAI4a,GAASJ,EAAW,CACpBA,EAAYI,EACZ,IAAIpU,EAAa,EAARoU,EAmBT,IAlBAS,EAAK1H,EAAMnN,GACX8U,EAAK3H,EAAMnN,EAAK,GAChBlO,EAAMqb,EAAMnN,EAAK,GACjBjO,EAAMob,EAAMnN,EAAK,GACjBhO,EAAMmb,EAAMnN,EAAK,GACjB/N,EAAMkb,EAAMnN,EAAK,GAOjB1N,EAAc,GAJdJ,EAA8B,KAAtB2iB,EAAW,EAAN/iB,EAAUE,KAEvBI,EAAsC,MAAf,GAAbN,EAAME,GAAW6iB,GAJ3BE,EAAK5H,EAAMnN,EAAK,MAOhBzN,EAAc,GAJdJ,EAA8B,KAAtB2iB,EAAW,EAAN/iB,EAAUE,KAEvBI,EAAsC,MAAf,GAAbN,EAAME,GAAW6iB,GAJ3BE,EAAK7H,EAAMnN,EAAK,MAOhBxN,EAAmB,IAAZV,EAAM+iB,GAAY3iB,EAAe,UAARE,EAChCK,EAAmB,IAAZV,EAAM+iB,GAAY3iB,EAAe,UAARE,EAChC6iB,EAAc3f,KAAKsW,KAAKrZ,EAAMA,EAAMC,EAAMA,GAC1Cqf,EAAS,GAAKoD,EACTlV,EAAK,EAAGA,EAAK,EAAGA,IACjBxN,GAAOF,EACPG,GAAOF,EACPD,GAAQF,EACRG,GAAQF,EACR6iB,GAAe3f,KAAKsW,KAAKrZ,EAAMA,EAAMC,EAAMA,GAC3Cqf,EAAS9R,GAAMkV,EAEnB1iB,GAAOF,EACPG,GAAOF,EACP2iB,GAAe3f,KAAKsW,KAAKrZ,EAAMA,EAAMC,EAAMA,GAC3Cqf,EAAS,GAAKoD,EACd1iB,GAAOF,EAAOF,EACdK,GAAOF,EAAOF,EACd6iB,GAAe3f,KAAKsW,KAAKrZ,EAAMA,EAAMC,EAAMA,GAC3Cqf,EAAS,GAAKoD,EACdC,EAAU,EAKd,IADAvG,GAAKsG,GACGC,IAAW,CACf,IAAI,EAASrD,EAASqD,GACtB,KAAIvG,EAAI,GAAR,CAII,IAAIpV,EAHR,GAAe,GAAX2b,EACAvG,GAAK,OAGLA,EAAIuG,GAAWvG,GADXpV,EAAOsY,EAASqD,EAAU,MACF,EAAS3b,GAEzC,OAEJrK,KAAKwlB,iBAAqB,GAAJ/F,EAASiG,EAAIC,EAAIhjB,EAAKC,EAAKC,EAAKC,EAAK8iB,EAAIC,EAAIrB,EAAKQ,EAAG9B,GAAahjB,EAAI,GAAc,GAATglB,GAErG,OAAOV,GAGX,YAAAa,kBAAA,SAAmB5F,EAAWwG,EAAqB/lB,EAAWskB,EAAoBQ,GAC9E,IAAIU,EAAKO,EAAK/lB,GAAIylB,EAAKM,EAAK/lB,EAAI,GAAImd,EAAK4I,EAAK/lB,EAAI,GAAKwlB,EAAIpI,EAAK2I,EAAK/lB,EAAI,GAAKylB,EAAIrgB,EAAIc,KAAK4V,MAAMsB,EAAID,GACrGmH,EAAIQ,GAAKU,EAAKjG,EAAIrZ,KAAKkW,IAAIhX,GAC3Bkf,EAAIQ,EAAI,GAAKW,EAAKlG,EAAIrZ,KAAKmW,IAAIjX,GAC/Bkf,EAAIQ,EAAI,GAAK1f,GAGjB,YAAAigB,iBAAA,SAAkB9F,EAAWwG,EAAqB/lB,EAAWskB,EAAoBQ,GAC7E,IAAIU,EAAKO,EAAK/lB,EAAI,GAAIylB,EAAKM,EAAK/lB,EAAI,GAAImd,EAAKqI,EAAKO,EAAK/lB,GAAIod,EAAKqI,EAAKM,EAAK/lB,EAAI,GAAIoF,EAAIc,KAAK4V,MAAMsB,EAAID,GACrGmH,EAAIQ,GAAKU,EAAKjG,EAAIrZ,KAAKkW,IAAIhX,GAC3Bkf,EAAIQ,EAAI,GAAKW,EAAKlG,EAAIrZ,KAAKmW,IAAIjX,GAC/Bkf,EAAIQ,EAAI,GAAK1f,GAGjB,YAAAkgB,iBAAA,SAAkB/F,EAAWiG,EAAYC,EAAYhjB,EAAaC,EAAaC,EAAaC,EAAa8iB,EAAYC,EACnGrB,EAAoBQ,EAAW9B,IACpC,GAALzD,GAAUyG,MAAMzG,MAAIA,EAAI,MAC5B,IAAI0G,EAAK1G,EAAIA,EAAG2G,EAAMD,EAAK1G,EAAGoB,EAAI,EAAIpB,EAAG4G,EAAKxF,EAAIA,EAAGyF,EAAMD,EAAKxF,EAC5D0F,EAAK1F,EAAIpB,EAAG+G,EAAW,EAALD,EAAQE,EAAO5F,EAAI2F,EAAKE,EAAOF,EAAM/G,EACvDlc,EAAImiB,EAAKY,EAAM3jB,EAAM8jB,EAAO5jB,EAAM6jB,EAAOd,EAAKQ,EAAK5iB,EAAImiB,EAAKW,EAAM1jB,EAAM6jB,EAAO3jB,EAAM4jB,EAAOb,EAAKO,EACrG5B,EAAIQ,GAAKzhB,EACTihB,EAAIQ,EAAI,GAAKxhB,EACT0f,IAAUsB,EAAIQ,EAAI,GAAK5e,KAAK4V,MAAMxY,GAAKmiB,EAAKU,EAAKzjB,EAAM2jB,EAAK,EAAIzjB,EAAMqjB,GAAK5iB,GAAKmiB,EAAKW,EAAK1jB,EAAM4jB,EAAK,EAAI1jB,EAAMsjB,MArXhH,EAAArB,MAAQ,EAAU,EAAAK,QAAU,EAAU,EAAAG,OAAS,EAC/C,EAAA5B,QAAU,KAsXrB,EAxXA,GAAa,EAAAD,eAAc,EADV,GAAAjkB,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,kBASI,WAAaI,GAAb,MACI,YAAMA,EAAM,GAAG,IAAM,K,OATzB,EAAA4E,MAAQ,IAAIsE,M,EAWhB,OAZwC,OAYxC,EAZA,CAAwC,EAAAgW,gBAA3B,EAAA6H,mBAAkB,EAc/B,SAAY9C,GACR,qBAAO,yBADX,CAAY,EAAAA,eAAA,EAAAA,aAAY,KAIxB,SAAYd,GACR,uBAAQ,qBAAO,yBADnB,CAAY,EAAAA,cAAA,EAAAA,YAAW,KAIvB,SAAYI,GACR,yBAAS,qBAAO,+BADpB,CAAY,EAAAA,aAAA,EAAAA,WAAU,KAvBL,GAAA3jB,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,iBAgBI,WAAaoF,GACT,GATJ,KAAAgiB,aAAe,IAAI9d,MACnB,KAAA+d,iBAAmB,IAAI/d,MAGvB,KAAApI,KAAO,EACP,KAAAoF,OAAS,EAAG,KAAAC,OAAS,EACrB,KAAAxC,EAAI,EAAG,KAAAC,EAAI,EAGK,MAARoB,EAAc,MAAM,IAAI7E,MAAM,wBAClCC,KAAK4E,KAAOA,EAEZ5E,KAAKwE,MAAQ,IAAIsE,MACjB,IAAK,IAAI5I,EAAI,EAAGA,EAAI0E,EAAKJ,MAAMrE,OAAQD,IAAK,CACxC,IAAI4mB,EAAWliB,EAAKJ,MAAMtE,GACtBqE,OAAI,EACR,GAAuB,MAAnBuiB,EAAS3N,OACT5U,EAAO,IAAI,EAAAmW,KAAKoM,EAAU9mB,KAAM,UAC/B,CACD,IAAI,EAASA,KAAKwE,MAAMsiB,EAAS3N,OAAO5W,OACxCgC,EAAO,IAAI,EAAAmW,KAAKoM,EAAU9mB,KAAM,GAChC,EAAOuZ,SAAS7O,KAAKnG,GAEzBvE,KAAKwE,MAAMkG,KAAKnG,GAGpBvE,KAAKsH,MAAQ,IAAIwB,MACjB9I,KAAK6K,UAAY,IAAI/B,MACrB,IAAS5I,EAAI,EAAGA,EAAI0E,EAAK0C,MAAMnH,OAAQD,IAAK,CACxC,IAAI6mB,EAAWniB,EAAK0C,MAAMpH,GAEtBmH,GADA9C,EAAOvE,KAAKwE,MAAMuiB,EAASD,SAASvkB,OAC7B,IAAI,EAAAykB,KAAKD,EAAUxiB,IAC9BvE,KAAKsH,MAAMoD,KAAKrD,GAChBrH,KAAK6K,UAAUH,KAAKrD,GAGxBrH,KAAK8L,cAAgB,IAAIhD,MACzB,IAAS5I,EAAI,EAAGA,EAAI0E,EAAKkH,cAAc3L,OAAQD,IAAK,CAChD,IAAI+mB,EAAmBriB,EAAKkH,cAAc5L,GAC1CF,KAAK8L,cAAcpB,KAAK,IAAI,EAAA4X,aAAa2E,EAAkBjnB,OAG/DA,KAAKgN,qBAAuB,IAAIlE,MAChC,IAAS5I,EAAI,EAAGA,EAAI0E,EAAKoI,qBAAqB7M,OAAQD,IAAK,CACvD,IAAIgnB,EAA0BtiB,EAAKoI,qBAAqB9M,GACxDF,KAAKgN,qBAAqBtC,KAAK,IAAI,EAAAyc,oBAAoBD,EAAyBlnB,OAGpFA,KAAK0N,gBAAkB,IAAI5E,MAC3B,IAAS5I,EAAI,EAAGA,EAAI0E,EAAK8I,gBAAgBvN,OAAQD,IAAK,CAClD,IAAIknB,EAAqBxiB,EAAK8I,gBAAgBxN,GAC9CF,KAAK0N,gBAAgBhD,KAAK,IAAI,EAAA+Y,eAAe2D,EAAoBpnB,OAGrEA,KAAK4G,MAAQ,IAAI,EAAA+X,MAAM,EAAG,EAAG,EAAG,GAChC3e,KAAKqnB,cAsdb,OAndI,YAAAA,YAAA,WACsBrnB,KAAK4mB,aACXzmB,OAAS,EACrBH,KAAK6mB,iBAAiB1mB,OAAS,EAG/B,IADA,IAAIqE,EAAQxE,KAAKwE,MACRtE,EAAI,EAAGa,EAAIyD,EAAMrE,OAAQD,EAAIa,EAAGb,IAAK,EACtCqE,EAAOC,EAAMtE,IACZ8Z,OAASzV,EAAKK,KAAK8Z,aACxBna,EAAKE,QAAUF,EAAKyV,OAGxB,GAAiB,MAAbha,KAAKhB,KACL,KAAIsoB,EAAYtnB,KAAKhB,KAAKwF,MAC1B,IAAStE,EAAI,EAAGa,EAAIf,KAAKhB,KAAKwF,MAAMrE,OAAQD,EAAIa,EAAGb,IAAK,CACpD,IAAIqE,EAAOvE,KAAKwE,MAAM8iB,EAAUpnB,GAAGqC,OACnC,GACIgC,EAAKyV,QAAS,EACdzV,EAAKE,QAAS,EACdF,EAAOA,EAAK4U,aACC,MAAR5U,IAKjB,IAAIuH,EAAgB9L,KAAK8L,cACrBkB,EAAuBhN,KAAKgN,qBAC5BU,EAAkB1N,KAAK0N,gBACvB6Z,EAAUzb,EAAc3L,OAAQqnB,EAAiBxa,EAAqB7M,OAAQsnB,EAAY/Z,EAAgBvN,OAC1GunB,EAAkBH,EAAUC,EAAiBC,EAEjDxS,EACI,IAAS/U,EAAI,EAAGA,EAAIwnB,EAAiBxnB,IAAK,CACtC,IAAK,IAAI2Q,EAAK,EAAGA,EAAK0W,EAAS1W,IAAM,CAEjC,IADIhF,EAAaC,EAAc+E,IAChBjM,KAAKia,OAAS3e,EAAG,CAC5BF,KAAK2nB,iBAAiB9b,GACtB,SAASoJ,GAGjB,IAASpE,EAAK,EAAGA,EAAK2W,EAAgB3W,IAAM,CAExC,IADIhF,EAAamB,EAAqB6D,IACvBjM,KAAKia,OAAS3e,EAAG,CAC5BF,KAAK4nB,wBAAwB/b,GAC7B,SAASoJ,GAGjB,IAASpE,EAAK,EAAGA,EAAK4W,EAAW5W,IAAM,CACnC,IAAIhF,EACJ,IADIA,EAAa6B,EAAgBmD,IAClBjM,KAAKia,OAAS3e,EAAG,CAC5BF,KAAK6nB,mBAAmBhc,GACxB,SAASoJ,IAKzB,IAAS/U,EAAI,EAAGa,EAAIyD,EAAMrE,OAAQD,EAAIa,EAAGb,IACrCF,KAAK8nB,SAAStjB,EAAMtE,KAG5B,YAAAynB,iBAAA,SAAkB9b,GAEd,GADAA,EAAWpH,OAASoH,EAAW3K,OAAOkZ,cAAgBvO,EAAWjH,KAAK8Z,cAA8B,MAAb1e,KAAKhB,MAAgB,EAAA4C,MAAMmmB,SAAS/nB,KAAKhB,KAAKgpB,YAAanc,EAAWjH,MAAM,IAC9JiH,EAAWpH,OAAhB,CAEA,IAAIvD,EAAS2K,EAAW3K,OACxBlB,KAAK8nB,SAAS5mB,GAEd,IAAI+mB,EAAcpc,EAAWrH,MACzB2U,EAAS8O,EAAY,GAGzB,GAFAjoB,KAAK8nB,SAAS3O,GAEV8O,EAAY9nB,OAAS,EAAG,CACxB,IAAI2f,EAAQmI,EAAYA,EAAY9nB,OAAS,GACvCH,KAAK4mB,aAAarR,QAAQuK,IAAU,GAAI9f,KAAK6mB,iBAAiBnc,KAAKoV,GAG7E9f,KAAK4mB,aAAalc,KAAKmB,GAEvB7L,KAAKkoB,UAAU/O,EAAOI,UACtB0O,EAAYA,EAAY9nB,OAAS,GAAG6Z,QAAS,IAGjD,YAAA6N,mBAAA,SAAoBhc,GAEhB,GADAA,EAAWpH,OAASoH,EAAW3K,OAAOqD,KAAK6V,cAAgBvO,EAAWjH,KAAK8Z,cAA8B,MAAb1e,KAAKhB,MAAgB,EAAA4C,MAAMmmB,SAAS/nB,KAAKhB,KAAKgpB,YAAanc,EAAWjH,MAAM,IACnKiH,EAAWpH,OAAhB,CAEA,IAAI4C,EAAOwE,EAAW3K,OAClB2F,EAAYQ,EAAKzC,KAAKrC,MACtB4lB,EAAW9gB,EAAK9C,KACH,MAAbvE,KAAKhB,MAAcgB,KAAKooB,6BAA6BpoB,KAAKhB,KAAM6H,EAAWshB,GAClD,MAAzBnoB,KAAK4E,KAAKyjB,aAAuBroB,KAAK4E,KAAKyjB,aAAeroB,KAAKhB,MAC/DgB,KAAKooB,6BAA6BpoB,KAAK4E,KAAKyjB,YAAaxhB,EAAWshB,GACxE,IAAK,IAAIjoB,EAAI,EAAGa,EAAIf,KAAK4E,KAAK0jB,MAAMnoB,OAAQD,EAAIa,EAAGb,IAC/CF,KAAKooB,6BAA6BpoB,KAAK4E,KAAK0jB,MAAMpoB,GAAI2G,EAAWshB,GAErE,IAAIpf,EAAa1B,EAAK6B,gBAClBH,aAAsB,EAAA6P,gBAAgB5Y,KAAKuoB,iCAAiCxf,EAAYof,GAE5F,IAAIF,EAAcpc,EAAWrH,MACzB8e,EAAY2E,EAAY9nB,OAC5B,IAASD,EAAI,EAAGA,EAAIojB,EAAWpjB,IAC3BF,KAAK8nB,SAASG,EAAY/nB,IAE9BF,KAAK4mB,aAAalc,KAAKmB,GAEvB,IAAS3L,EAAI,EAAGA,EAAIojB,EAAWpjB,IAC3BF,KAAKkoB,UAAUD,EAAY/nB,GAAGqZ,UAClC,IAASrZ,EAAI,EAAGA,EAAIojB,EAAWpjB,IAC3B+nB,EAAY/nB,GAAG8Z,QAAS,IAGhC,YAAA4N,wBAAA,SAAyB/b,GAErB,GADAA,EAAWpH,OAASoH,EAAW3K,OAAOkZ,cAAgBvO,EAAWjH,KAAK8Z,cAA8B,MAAb1e,KAAKhB,MAAgB,EAAA4C,MAAMmmB,SAAS/nB,KAAKhB,KAAKgpB,YAAanc,EAAWjH,MAAM,IAC9JiH,EAAWpH,OAAhB,CAEAzE,KAAK8nB,SAASjc,EAAW3K,QAEzB,IAAI+mB,EAAcpc,EAAWrH,MACzB8e,EAAY2E,EAAY9nB,OAC5B,GAAI0L,EAAWjH,KAAKuZ,MAChB,IAAK,IAAIje,EAAI,EAAGA,EAAIojB,EAAWpjB,IAAK,CAChC,IAAI4f,EAAQmI,EAAY/nB,GACxBF,KAAK8nB,SAAShI,EAAM3G,QACdnZ,KAAK4mB,aAAarR,QAAQuK,IAAU,GAAI9f,KAAK6mB,iBAAiBnc,KAAKoV,QAG7E,IAAS5f,EAAI,EAAGA,EAAIojB,EAAWpjB,IAC3BF,KAAK8nB,SAASG,EAAY/nB,IAIlCF,KAAK4mB,aAAalc,KAAKmB,GAEvB,IAAK,IAAIgF,EAAK,EAAGA,EAAKyS,EAAWzS,IAC7B7Q,KAAKkoB,UAAUD,EAAYpX,GAAI0I,UACnC,IAAS1I,EAAK,EAAGA,EAAKyS,EAAWzS,IAC7BoX,EAAYpX,GAAImJ,QAAS,IAGjC,YAAAoO,6BAAA,SAA8BppB,EAAY6H,EAAmBshB,GACzD,IAAItW,EAAc7S,EAAK6S,YAAYhL,GACnC,GAAKgL,EACL,IAAK,IAAIkG,KAAOlG,EACZ7R,KAAKuoB,iCAAiC1W,EAAYkG,GAAMoQ,IAIhE,YAAAI,iCAAA,SAAkCxf,EAAwBof,GACtD,GAAMpf,aAAsB,EAAA6P,eAA5B,CACA,IAAI4P,EAA6Bzf,EAAYvE,MAC7C,GAAiB,MAAbgkB,EACAxoB,KAAK8nB,SAASK,QAId,IAFA,IAAI3jB,EAAQxE,KAAKwE,MACbtE,EAAI,EACDA,EAAIsoB,EAAUroB,QAEjB,IADA,IAAImjB,EAAYkF,EAAUtoB,KACjBa,EAAIb,EAAIojB,EAAWpjB,EAAIa,EAAGb,IAAK,CACpC,IAAIgE,EAAYskB,EAAUtoB,GAC1BF,KAAK8nB,SAAStjB,EAAMN,OAMpC,YAAA4jB,SAAA,SAAUvjB,GACN,IAAIA,EAAKyV,OAAT,CACA,IAAIb,EAAS5U,EAAK4U,OACJ,MAAVA,GAAgBnZ,KAAK8nB,SAAS3O,GAClC5U,EAAKyV,QAAS,EACdha,KAAK4mB,aAAalc,KAAKnG,KAG3B,YAAA2jB,UAAA,SAAW1jB,GACP,IAAK,IAAItE,EAAI,EAAGa,EAAIyD,EAAMrE,OAAQD,EAAIa,EAAGb,IAAK,CAC1C,IAAIqE,EAAOC,EAAMtE,GACZqE,EAAKE,SACNF,EAAKyV,QAAQha,KAAKkoB,UAAU3jB,EAAKgV,UACrChV,EAAKyV,QAAS,KAKtB,YAAAM,qBAAA,WAEI,IADA,IAAIuM,EAAmB7mB,KAAK6mB,iBACnB3mB,EAAI,EAAGa,EAAI8lB,EAAiB1mB,OAAQD,EAAIa,EAAGb,IAAK,CACrD,IAAIqE,EAAOsiB,EAAiB3mB,GAC5BqE,EAAKiV,GAAKjV,EAAKhB,EACfgB,EAAKkV,GAAKlV,EAAKf,EACfe,EAAKmV,UAAYnV,EAAKI,SACtBJ,EAAKoV,QAAUpV,EAAKuB,OACpBvB,EAAKqV,QAAUrV,EAAKwB,OACpBxB,EAAKsV,QAAUtV,EAAKiC,OACpBjC,EAAKuV,QAAUvV,EAAKkC,OACpBlC,EAAKwV,cAAe,EAExB,IAAIsN,EAAcrnB,KAAK4mB,aACvB,IAAS1mB,EAAI,EAAGa,EAAIsmB,EAAYlnB,OAAQD,EAAIa,EAAGb,IAC3CmnB,EAAYnnB,GAAG9B,UAIvB,YAAA6b,eAAA,WACIja,KAAKyoB,sBACLzoB,KAAK0oB,uBAIT,YAAAD,oBAAA,WAEI,IADA,IAAIjkB,EAAQxE,KAAKwE,MACRtE,EAAI,EAAGa,EAAIyD,EAAMrE,OAAQD,EAAIa,EAAGb,IACrCsE,EAAMtE,GAAG+Z,iBAEb,IAAInO,EAAgB9L,KAAK8L,cACzB,IAAS5L,EAAI,EAAGa,EAAI+K,EAAc3L,OAAQD,EAAIa,EAAGb,IAAK,EAC9C2L,EAAaC,EAAc5L,IACpBiL,IAAMU,EAAWjH,KAAKuG,IACjCU,EAAWT,SAAWS,EAAWjH,KAAKwG,SACtCS,EAAWR,cAAgBQ,EAAWjH,KAAKyG,cAC3CQ,EAAWP,SAAWO,EAAWjH,KAAK0G,SACtCO,EAAWN,QAAUM,EAAWjH,KAAK2G,QAGzC,IAAIyB,EAAuBhN,KAAKgN,qBAChC,IAAS9M,EAAI,EAAGa,EAAIiM,EAAqB7M,OAAQD,EAAIa,EAAGb,IAAK,CACzD,IACI0E,GADAiH,EAAamB,EAAqB9M,IAChB0E,KACtBiH,EAAWW,UAAY5H,EAAK4H,UAC5BX,EAAWY,aAAe7H,EAAK6H,aAC/BZ,EAAWa,SAAW9H,EAAK8H,SAC3Bb,EAAWc,SAAW/H,EAAK+H,SAG/B,IAAIe,EAAkB1N,KAAK0N,gBAC3B,IAASxN,EAAI,EAAGa,EAAI2M,EAAgBvN,OAAQD,EAAIa,EAAGb,IAAK,CACpD,IAAI2L,EACAjH,GADAiH,EAAa6B,EAAgBxN,IACX0E,KACtBiH,EAAW8B,SAAW/I,EAAK+I,SAC3B9B,EAAWiC,QAAUlJ,EAAKkJ,QAC1BjC,EAAWW,UAAY5H,EAAK4H,UAC5BX,EAAWY,aAAe7H,EAAK6H,eAIvC,YAAAic,oBAAA,WACI,IAAIphB,EAAQtH,KAAKsH,MACjB,EAAA1F,MAAMsI,UAAU5C,EAAO,EAAGtH,KAAK6K,UAAW,EAAGvD,EAAMnH,QACnD,IAAK,IAAID,EAAI,EAAGa,EAAIuG,EAAMnH,OAAQD,EAAIa,EAAGb,IACrCoH,EAAMpH,GAAG+Z,kBAIjB,YAAA0O,YAAA,WACI,OAAyB,GAArB3oB,KAAKwE,MAAMrE,OAAoB,KAC5BH,KAAKwE,MAAM,IAItB,YAAAya,SAAA,SAAU2J,GACN,GAAgB,MAAZA,EAAkB,MAAM,IAAI7oB,MAAM,4BAEtC,IADA,IAAIyE,EAAQxE,KAAKwE,MACRtE,EAAI,EAAGa,EAAIyD,EAAMrE,OAAQD,EAAIa,EAAGb,IAAK,CAC1C,IAAIqE,EAAOC,EAAMtE,GACjB,GAAIqE,EAAKK,KAAKhF,MAAQgpB,EAAU,OAAOrkB,EAE3C,OAAO,MAIX,YAAAskB,cAAA,SAAeD,GACX,GAAgB,MAAZA,EAAkB,MAAM,IAAI7oB,MAAM,4BAEtC,IADA,IAAIyE,EAAQxE,KAAKwE,MACRtE,EAAI,EAAGa,EAAIyD,EAAMrE,OAAQD,EAAIa,EAAGb,IACrC,GAAIsE,EAAMtE,GAAG0E,KAAKhF,MAAQgpB,EAAU,OAAO1oB,EAC/C,OAAQ,GAIZ,YAAA0iB,SAAA,SAAUkG,GACN,GAAgB,MAAZA,EAAkB,MAAM,IAAI/oB,MAAM,4BAEtC,IADA,IAAIuH,EAAQtH,KAAKsH,MACRpH,EAAI,EAAGa,EAAIuG,EAAMnH,OAAQD,EAAIa,EAAGb,IAAK,CAC1C,IAAImH,EAAOC,EAAMpH,GACjB,GAAImH,EAAKzC,KAAKhF,MAAQkpB,EAAU,OAAOzhB,EAE3C,OAAO,MAIX,YAAA0hB,cAAA,SAAeD,GACX,GAAgB,MAAZA,EAAkB,MAAM,IAAI/oB,MAAM,4BAEtC,IADA,IAAIuH,EAAQtH,KAAKsH,MACRpH,EAAI,EAAGa,EAAIuG,EAAMnH,OAAQD,EAAIa,EAAGb,IACrC,GAAIoH,EAAMpH,GAAG0E,KAAKhF,MAAQkpB,EAAU,OAAO5oB,EAC/C,OAAQ,GAKZ,YAAA8oB,cAAA,SAAeC,GACX,IAAIjqB,EAAOgB,KAAK4E,KAAKskB,SAASD,GAC9B,GAAY,MAARjqB,EAAc,MAAM,IAAIe,MAAM,mBAAqBkpB,GACvDjpB,KAAKmpB,QAAQnqB,IAOjB,YAAAmqB,QAAA,SAASC,GACL,GAAIA,GAAWppB,KAAKhB,KAApB,CACA,GAAe,MAAXoqB,EACA,GAAiB,MAAbppB,KAAKhB,KACLoqB,EAAQC,UAAUrpB,KAAMA,KAAKhB,WAG7B,IADA,IAAIsI,EAAQtH,KAAKsH,MACRpH,EAAI,EAAGa,EAAIuG,EAAMnH,OAAQD,EAAIa,EAAGb,IAAK,CAC1C,IAAImH,EAAOC,EAAMpH,GACb,EAAOmH,EAAKzC,KAAKoE,eACrB,GAAY,MAAR,EAAc,CACd,IAAID,EAAyBqgB,EAAQlgB,cAAchJ,EAAG,GACpC,MAAd6I,GAAoB1B,EAAK4B,cAAcF,IAK3D/I,KAAKhB,KAAOoqB,EACZppB,KAAKqnB,gBAIT,YAAAiC,oBAAA,SAAqBR,EAAkB9f,GACnC,OAAOhJ,KAAKkJ,cAAclJ,KAAK4E,KAAKmkB,cAAcD,GAAW9f,IAIjE,YAAAE,cAAA,SAAerC,EAAmBmC,GAC9B,GAAsB,MAAlBA,EAAwB,MAAM,IAAIjJ,MAAM,kCAC5C,GAAiB,MAAbC,KAAKhB,KAAc,CACnB,IAAI+J,EAAyB/I,KAAKhB,KAAKkK,cAAcrC,EAAWmC,GAChE,GAAkB,MAAdD,EAAoB,OAAOA,EAEnC,OAA6B,MAAzB/I,KAAK4E,KAAKyjB,YAA4BroB,KAAK4E,KAAKyjB,YAAYnf,cAAcrC,EAAWmC,GAClF,MAIX,YAAAC,cAAA,SAAe6f,EAAkB9f,GAC7B,GAAgB,MAAZ8f,EAAkB,MAAM,IAAI/oB,MAAM,4BAEtC,IADA,IAAIuH,EAAQtH,KAAKsH,MACRpH,EAAI,EAAGa,EAAIuG,EAAMnH,OAAQD,EAAIa,EAAGb,IAAK,CAC1C,IAAImH,EAAOC,EAAMpH,GACjB,GAAImH,EAAKzC,KAAKhF,MAAQkpB,EAAU,CAC5B,IAAI/f,EAAyB,KAC7B,GAAsB,MAAlBC,GAEkB,OADlBD,EAAa/I,KAAKkJ,cAAchJ,EAAG8I,IAE/B,MAAM,IAAIjJ,MAAM,yBAA2BiJ,EAAiB,eAAiB8f,GAGrF,YADAzhB,EAAK4B,cAAcF,IAI3B,MAAM,IAAIhJ,MAAM,mBAAqB+oB,IAIzC,YAAAS,iBAAA,SAAkBC,GACd,GAAsB,MAAlBA,EAAwB,MAAM,IAAIzpB,MAAM,kCAE5C,IADA,IAAI+L,EAAgB9L,KAAK8L,cAChB5L,EAAI,EAAGa,EAAI+K,EAAc3L,OAAQD,EAAIa,EAAGb,IAAK,CAClD,IAAI+K,EAAea,EAAc5L,GACjC,GAAI+K,EAAarG,KAAKhF,MAAQ4pB,EAAgB,OAAOve,EAEzD,OAAO,MAIX,YAAAwe,wBAAA,SAAyBD,GACrB,GAAsB,MAAlBA,EAAwB,MAAM,IAAIzpB,MAAM,kCAE5C,IADA,IAAIiN,EAAuBhN,KAAKgN,qBACvB9M,EAAI,EAAGa,EAAIiM,EAAqB7M,OAAQD,EAAIa,EAAGb,IAAK,CACzD,IAAI2L,EAAamB,EAAqB9M,GACtC,GAAI2L,EAAWjH,KAAKhF,MAAQ4pB,EAAgB,OAAO3d,EAEvD,OAAO,MAIX,YAAA6d,mBAAA,SAAoBF,GAChB,GAAsB,MAAlBA,EAAwB,MAAM,IAAIzpB,MAAM,kCAE5C,IADA,IAAI2N,EAAkB1N,KAAK0N,gBAClBxN,EAAI,EAAGa,EAAI2M,EAAgBvN,OAAQD,EAAIa,EAAGb,IAAK,CACpD,IAAI2L,EAAa6B,EAAgBxN,GACjC,GAAI2L,EAAWjH,KAAKhF,MAAQ4pB,EAAgB,OAAO3d,EAEvD,OAAO,MAOX,YAAA8d,UAAA,SAAWC,EAAiBC,EAAe5D,GACvC,QADuC,IAAAA,MAAA,IAA0Bnd,MAAc,IACjE,MAAV8gB,EAAgB,MAAM,IAAI7pB,MAAM,0BACpC,GAAY,MAAR8pB,EAAc,MAAM,IAAI9pB,MAAM,wBAGlC,IAFA,IAAI8K,EAAY7K,KAAK6K,UACjBiX,EAAOtX,OAAOsf,kBAAmB9H,EAAOxX,OAAOsf,kBAAmB5H,EAAO1X,OAAOuf,kBAAmB3H,EAAO5X,OAAOuf,kBAC5G7pB,EAAI,EAAGa,EAAI8J,EAAU1K,OAAQD,EAAIa,EAAGb,IAAK,CAC9C,IAAImH,EAAOwD,EAAU3K,GACrB,GAAKmH,EAAK9C,KAAKE,OAAf,CACA,IAAIigB,EAAiB,EACjBnb,EAA8B,KAC9BR,EAAa1B,EAAK6B,gBACtB,GAAIH,aAAsB,EAAAuP,iBACtBoM,EAAiB,EACjBnb,EAAW,EAAA3H,MAAMmI,aAAakc,EAAMvB,EAAgB,GACjC3b,EAAYqc,qBAAqB/d,EAAK9C,KAAMgF,EAAU,EAAG,QACzE,GAAIR,aAAsB,EAAAyP,eAAgB,CAC7C,IAAIwR,EAAwBjhB,EAC5B2b,EAAiBsF,EAAKrF,oBACtBpb,EAAW,EAAA3H,MAAMmI,aAAakc,EAAMvB,EAAgB,GACpDsF,EAAK5E,qBAAqB/d,EAAM,EAAGqd,EAAgBnb,EAAU,EAAG,GAEpE,GAAgB,MAAZA,EACA,IAAK,IAAIsH,EAAK,EAAGoZ,EAAK1gB,EAASpJ,OAAQ0Q,EAAKoZ,EAAIpZ,GAAM,EAAG,CACrD,IAAItN,EAAIgG,EAASsH,GAAKrN,EAAI+F,EAASsH,EAAK,GACxCiR,EAAO1b,KAAKuN,IAAImO,EAAMve,GACtBye,EAAO5b,KAAKuN,IAAIqO,EAAMxe,GACtB0e,EAAO9b,KAAKmM,IAAI2P,EAAM3e,GACtB6e,EAAOhc,KAAKmM,IAAI6P,EAAM5e,KAIlComB,EAAOhiB,IAAIka,EAAME,GACjB6H,EAAKjiB,IAAIsa,EAAOJ,EAAMM,EAAOJ,IAGjC,YAAA5jB,OAAA,SAAQyQ,GACJ7O,KAAKU,MAAQmO,GAGjB,sBAAI,oBAAK,C,IAAT,WACI,OAAuB,GAAhB7O,KAAK8F,Q,IAGhB,SAAU0H,GACD0c,EAAStU,qBACVsU,EAAStU,oBAAqB,EAC9BC,QAAQC,KAAK,+FAEjB9V,KAAK8F,OAAS0H,EAAQ,GAAO,G,gCAGjC,sBAAI,oBAAK,C,IAAT,WACI,OAAuB,GAAhBxN,KAAK+F,Q,IAGhB,SAAUyH,GACD0c,EAAStU,qBACVsU,EAAStU,oBAAqB,EAC9BC,QAAQC,KAAK,+FAEjB9V,KAAK+F,OAASyH,EAAQ,GAAO,G,gCAGlB,EAAAoI,oBAA8B,EACjD,EArhBA,GAAa,EAAAsU,SAAQ,EADJ,GAAA1qB,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCFpB,SAAUA,IAAW,SAAAC,GACpB,iBA6BC,WAAa2qB,GAHb,KAAAtkB,MAAQ,EACA,KAAAukB,aAAe,IAAIthB,MAG1B9I,KAAKmqB,iBAAmBA,EAotB1B,OAjtBC,YAAAE,iBAAA,SAAkBC,GACjB,IAAIzkB,EAAQ7F,KAAK6F,MAEbiO,EAAe,IAAI,EAAAyW,aACvBzW,EAAalU,KAAO,GAEpB,IAAI4qB,EAAQ,IAAIC,EAAYH,GAInB,GAFTxW,EAAa4W,KAAOF,EAAMG,aAC1B7W,EAAa8W,QAAUJ,EAAMG,aACS,WAAzB7W,EAAa8W,QACjB,CAEI/U,QAAQgV,MADI,iGAGzB/W,EAAavQ,EAAIinB,EAAMM,YACvBhX,EAAatQ,EAAIgnB,EAAMM,YACvBhX,EAAaiX,MAAQP,EAAMM,YAC3BhX,EAAakX,OAASR,EAAMM,YAE5B,IAAIG,EAAeT,EAAMU,cACrBD,IACHnX,EAAaqX,IAAMX,EAAMM,YAEzBhX,EAAasX,WAAaZ,EAAMG,aAChC7W,EAAauX,UAAYb,EAAMG,cAGhC,IAAI5pB,EAAI,EAERA,EAAIypB,EAAMc,SAAQ,GAClB,IAAK,IAAIprB,EAAI,EAAGA,EAAIa,EAAGb,IACtBsqB,EAAMe,QAAQ7gB,KAAK8f,EAAMG,cAG1B5pB,EAAIypB,EAAMc,SAAQ,GAClB,IAASprB,EAAI,EAAGA,EAAIa,EAAGb,IAAK,CAC3B,IAAI,EAAOsqB,EAAMG,aACb,EAAc,GAALzqB,EAAS,KAAO4T,EAAatP,MAAMgmB,EAAMc,SAAQ,KAC1D1mB,EAAO,IAAI,EAAAga,SAAS1e,EAAG,EAAM,IAC5ByE,SAAW6lB,EAAMM,YACtBlmB,EAAKrB,EAAIinB,EAAMM,YAAcjlB,EAC7BjB,EAAKpB,EAAIgnB,EAAMM,YAAcjlB,EAC7BjB,EAAKkB,OAAS0kB,EAAMM,YACpBlmB,EAAKmB,OAASykB,EAAMM,YACpBlmB,EAAK4B,OAASgkB,EAAMM,YACpBlmB,EAAK6B,OAAS+jB,EAAMM,YACpBlmB,EAAKzE,OAASqqB,EAAMM,YAAcjlB,EAClCjB,EAAKyW,cAAgBmQ,EAAeC,oBAAoBjB,EAAMc,SAAQ,IACtE1mB,EAAK8Z,aAAe8L,EAAMU,cACtBD,GAAc,EAAAtM,MAAM+M,gBAAgB9mB,EAAKgC,MAAO4jB,EAAMmB,aAC1D7X,EAAatP,MAAMkG,KAAK9F,GAIzB7D,EAAIypB,EAAMc,SAAQ,GAClB,IAASprB,EAAI,EAAGA,EAAIa,EAAGb,IAAK,CAC3B,IAAI4oB,EAAW0B,EAAMG,aACjB7D,EAAWhT,EAAatP,MAAMgmB,EAAMc,SAAQ,IAC5C1mB,EAAO,IAAI,EAAAgnB,SAAS1rB,EAAG4oB,EAAUhC,GACrC,EAAAnI,MAAM+M,gBAAgB9mB,EAAKgC,MAAO4jB,EAAMmB,aAExC,IAAItjB,EAAYmiB,EAAMmB,aACJ,GAAdtjB,GAAiB,EAAAsW,MAAMkN,cAAcjnB,EAAKyD,UAAY,IAAI,EAAAsW,MAAStW,GAEvEzD,EAAKoE,eAAiBwhB,EAAMsB,gBAC5BlnB,EAAKmnB,UAAYP,EAAeQ,gBAAgBxB,EAAMc,SAAQ,IAC9DxX,EAAaxM,MAAMoD,KAAK9F,GAIzB7D,EAAIypB,EAAMc,SAAQ,GACTprB,EAAI,EAAb,IAAK,IAAW+pB,OAAE,EAAE/pB,EAAIa,EAAGb,IAAK,EAC3B0E,EAAO,IAAI,EAAA2d,iBAAiBiI,EAAMG,eACjC9L,MAAQ2L,EAAMc,SAAQ,GAC3B1mB,EAAK8Z,aAAe8L,EAAMU,cAC1BjB,EAAKO,EAAMc,SAAQ,GACnB,IAAK,IAAIza,EAAK,EAAGA,EAAKoZ,EAAIpZ,IACzBjM,EAAKJ,MAAMkG,KAAKoJ,EAAatP,MAAMgmB,EAAMc,SAAQ,KAClD1mB,EAAK1D,OAAS4S,EAAatP,MAAMgmB,EAAMc,SAAQ,IAC/C1mB,EAAKuG,IAAMqf,EAAMM,YACjBlmB,EAAKwG,SAAWof,EAAMM,YAAcjlB,EACpCjB,EAAKyG,cAAgBmf,EAAMyB,WAC3BrnB,EAAK0G,SAAWkf,EAAMU,cACtBtmB,EAAK2G,QAAUif,EAAMU,cACrBtmB,EAAKya,QAAUmL,EAAMU,cACrBpX,EAAahI,cAAcpB,KAAK9F,GAIjC7D,EAAIypB,EAAMc,SAAQ,GAClB,IAASprB,EAAI,EAAG+pB,OAAE,EAAE/pB,EAAIa,EAAGb,IAAK,EAC3B0E,EAAO,IAAI,EAAAsnB,wBAAwB1B,EAAMG,eACxC9L,MAAQ2L,EAAMc,SAAQ,GAC3B1mB,EAAK8Z,aAAe8L,EAAMU,cAC1BjB,EAAKO,EAAMc,SAAQ,GACnB,IAASza,EAAK,EAAGA,EAAKoZ,EAAIpZ,IACzBjM,EAAKJ,MAAMkG,KAAKoJ,EAAatP,MAAMgmB,EAAMc,SAAQ,KAClD1mB,EAAK1D,OAAS4S,EAAatP,MAAMgmB,EAAMc,SAAQ,IAC/C1mB,EAAKuZ,MAAQqM,EAAMU,cACnBtmB,EAAKunB,SAAW3B,EAAMU,cACtBtmB,EAAKqf,eAAiBuG,EAAMM,YAC5BlmB,EAAKwnB,QAAU5B,EAAMM,YAAcjlB,EACnCjB,EAAKynB,QAAU7B,EAAMM,YAAcjlB,EACnCjB,EAAK0nB,aAAe9B,EAAMM,YAC1BlmB,EAAK2nB,aAAe/B,EAAMM,YAC1BlmB,EAAK4nB,aAAehC,EAAMM,YAC1BlmB,EAAK4H,UAAYge,EAAMM,YACvBlmB,EAAK6H,aAAe+d,EAAMM,YAC1BlmB,EAAK8H,SAAW8d,EAAMM,YACtBlmB,EAAK+H,SAAW6d,EAAMM,YACtBhX,EAAa9G,qBAAqBtC,KAAK9F,GAIxC7D,EAAIypB,EAAMc,SAAQ,GAClB,IAASprB,EAAI,EAAG+pB,OAAE,EAAE/pB,EAAIa,EAAGb,IAAK,EAC3B0E,EAAO,IAAI,EAAA+hB,mBAAmB6D,EAAMG,eACnC9L,MAAQ2L,EAAMc,SAAQ,GAC3B1mB,EAAK8Z,aAAe8L,EAAMU,cAC1BjB,EAAKO,EAAMc,SAAQ,GACnB,IAASza,EAAK,EAAGA,EAAKoZ,EAAIpZ,IACzBjM,EAAKJ,MAAMkG,KAAKoJ,EAAatP,MAAMgmB,EAAMc,SAAQ,KAClD1mB,EAAK1D,OAAS4S,EAAaxM,MAAMkjB,EAAMc,SAAQ,IAC/C1mB,EAAKgf,aAAe4H,EAAeiB,mBAAmBjC,EAAMc,SAAQ,IACpE1mB,EAAKie,YAAc2I,EAAekB,kBAAkBlC,EAAMc,SAAQ,IAClE1mB,EAAKqe,WAAauI,EAAemB,iBAAiBnC,EAAMc,SAAQ,IAChE1mB,EAAKqf,eAAiBuG,EAAMM,YAC5BlmB,EAAK+I,SAAW6c,EAAMM,YAClBlmB,EAAKgf,cAAgB,EAAAC,aAAa+I,QAAOhoB,EAAK+I,UAAY9H,GAC9DjB,EAAKkJ,QAAU0c,EAAMM,YACjBlmB,EAAKie,aAAe,EAAAE,YAAYC,QAAUpe,EAAKie,aAAe,EAAAE,YAAY6J,QAAOhoB,EAAKkJ,SAAWjI,GACrGjB,EAAK4H,UAAYge,EAAMM,YACvBlmB,EAAK6H,aAAe+d,EAAMM,YAC1BhX,EAAapG,gBAAgBhD,KAAK9F,GAInC,IAAIyjB,EAAcroB,KAAK6sB,SAASrC,EAAO1W,GAAc,EAAMmX,GACxC,MAAf5C,IACHvU,EAAauU,YAAcA,EAC3BvU,EAAawU,MAAM5d,KAAK2d,IAKpBnoB,EAAI4T,EAAawU,MAAMnoB,OAE3B,IADA,EAAAyB,MAAMmI,aAAa+J,EAAawU,MAAOvnB,EAAIb,EAAIsqB,EAAMc,SAAQ,IACtDprB,EAAIa,EAAGb,IACb4T,EAAawU,MAAMpoB,GAAKF,KAAK6sB,SAASrC,EAAO1W,GAAc,EAAOmX,GAIpElqB,EAAIf,KAAKoqB,aAAajqB,OACtB,IAASD,EAAI,EAAGA,EAAIa,EAAGb,IAAK,CAC3B,IAAI4sB,EAAa9sB,KAAKoqB,aAAalqB,GAC/BlB,EAA0B,MAAnB8tB,EAAW9tB,KAAe8U,EAAauU,YAAcvU,EAAaoV,SAAS4D,EAAW9tB,MACjG,GAAY,MAARA,EAAc,MAAM,IAAIe,MAAM,mBAAqB+sB,EAAW9tB,MAClE,IAAI,EAASA,EAAKkK,cAAc4jB,EAAWjmB,UAAWimB,EAAW3T,QACjE,GAAc,MAAV,EAAgB,MAAM,IAAIpZ,MAAM,0BAA4B+sB,EAAW3T,QAC3E2T,EAAW9C,KAAKrgB,iBAAmBmjB,EAAWC,cAAgB,EAA6BD,EAAW9C,KACtG8C,EAAW9C,KAAKgD,cAAc,GAG/BhtB,KAAKoqB,aAAajqB,OAAS,EAG3BY,EAAIypB,EAAMc,SAAQ,GAClB,IAASprB,EAAI,EAAGA,EAAIa,EAAGb,IAAK,EACvB0E,EAAO,IAAI,EAAAoa,UAAUwL,EAAMsB,kBAC1BmB,SAAWzC,EAAMc,SAAQ,GAC9B1mB,EAAKsoB,WAAa1C,EAAMM,YACxBlmB,EAAKuoB,YAAc3C,EAAMG,aACzB/lB,EAAKymB,UAAYb,EAAMG,aACD,MAAlB/lB,EAAKymB,YACRzmB,EAAKwoB,OAAS5C,EAAMM,YACpBlmB,EAAKyoB,QAAU7C,EAAMM,aAEtBhX,EAAanT,OAAO+J,KAAK9F,GAI1B7D,EAAIypB,EAAMc,SAAQ,GAClB,IAASprB,EAAI,EAAGA,EAAIa,EAAGb,IACtB4T,EAAawZ,WAAW5iB,KAAK1K,KAAKutB,cAAc/C,EAAOA,EAAMG,aAAc7W,IAC5E,OAAOA,GAGA,YAAA+Y,SAAR,SAAkBrC,EAAoB1W,EAA4BuU,EAAsB4C,GAC9E,IAAIjsB,EAAO,KACPwuB,EAAY,EAEhB,GAAInF,EAAa,CAEb,GAAiB,IADjBmF,EAAYhD,EAAMc,SAAQ,IACN,OAAO,KAC3BtsB,EAAO,IAAI,EAAAyuB,KAAK,eACb,EACHzuB,EAAO,IAAI,EAAAyuB,KAAKjD,EAAMsB,kBACjBtnB,MAAMrE,OAASqqB,EAAMc,SAAQ,GAClC,IAAK,IAAIprB,EAAI,EAAGa,EAAI/B,EAAKwF,MAAMrE,OAAQD,EAAIa,EAAGb,IAC1ClB,EAAKwF,MAAMtE,GAAK4T,EAAatP,MAAMgmB,EAAMc,SAAQ,IAErD,IAASprB,EAAI,EAAGa,EAAIypB,EAAMc,SAAQ,GAAOprB,EAAIa,EAAGb,IAC5ClB,EAAKgpB,YAAYtd,KAAKoJ,EAAahI,cAAc0e,EAAMc,SAAQ,KACnE,IAASprB,EAAI,EAAGa,EAAIypB,EAAMc,SAAQ,GAAOprB,EAAIa,EAAGb,IAC5ClB,EAAKgpB,YAAYtd,KAAKoJ,EAAa9G,qBAAqBwd,EAAMc,SAAQ,KAC1E,IAASprB,EAAI,EAAGa,EAAIypB,EAAMc,SAAQ,GAAOprB,EAAIa,EAAGb,IAC5ClB,EAAKgpB,YAAYtd,KAAKoJ,EAAapG,gBAAgB8c,EAAMc,SAAQ,KAErEkC,EAAYhD,EAAMc,SAAQ,GAG9B,IAASprB,EAAI,EAAGA,EAAIstB,EAAWttB,IAE3B,IADA,IAAI2G,EAAY2jB,EAAMc,SAAQ,GACrBza,EAAK,EAAGoZ,EAAKO,EAAMc,SAAQ,GAAOza,EAAKoZ,EAAIpZ,IAAM,CACtD,IAAI,EAAO2Z,EAAMsB,gBACb/iB,EAAa/I,KAAK0tB,eAAelD,EAAO1W,EAAc9U,EAAM6H,EAAW,EAAMokB,GAC/D,MAAdliB,GAAoB/J,EAAKiK,cAAcpC,EAAW,EAAMkC,GAGpE,OAAO/J,GAGT,YAAA0uB,eAAR,SAAuBlD,EAAoB1W,EAA4B9U,EAAY6H,EAAmBmC,EAAwBiiB,GAC7H,IAAIplB,EAAQ7F,KAAK6F,MAEbjG,EAAO4qB,EAAMsB,gBACL,MAARlsB,IAAcA,EAAOoJ,GAEzB,IAAI2kB,EAAYnD,EAAMyB,WAEtB,OADWT,EAAeoC,qBAAqBD,IAE/C,KAAK,EAAAE,eAAeC,OACnB,IAAI3V,EAAOqS,EAAMsB,gBACbnnB,EAAW6lB,EAAMM,YACjBvnB,EAAIinB,EAAMM,YACVtnB,EAAIgnB,EAAMM,YACVhlB,EAAS0kB,EAAMM,YACf/kB,EAASykB,EAAMM,YACfC,EAAQP,EAAMM,YACdE,EAASR,EAAMM,YACflkB,EAAQ4jB,EAAMmB,YAEN,MAARxT,IAAcA,EAAOvY,GACzB,IAAIwY,EAASpY,KAAKmqB,iBAAiBjS,oBAAoBlZ,EAAMY,EAAMuY,GACnE,OAAc,MAAVC,EAAuB,MAC3BA,EAAOD,KAAOA,EACdC,EAAO7U,EAAIA,EAAIsC,EACfuS,EAAO5U,EAAIA,EAAIqC,EACfuS,EAAOtS,OAASA,EAChBsS,EAAOrS,OAASA,EAChBqS,EAAOzT,SAAWA,EAClByT,EAAO2S,MAAQA,EAAQllB,EACvBuS,EAAO4S,OAASA,EAASnlB,EACzB,EAAA8Y,MAAM+M,gBAAgBtT,EAAOxR,MAAOA,GAE7BwR,GAER,KAAK,EAAAyV,eAAeE,YACnB,IAAIlkB,EAAc2gB,EAAMc,SAAQ,GAC5B/hB,EAAWvJ,KAAKguB,aAAaxD,EAAO3gB,GAGpCokB,GAFArnB,EAAQqkB,EAAeT,EAAMmB,YAAc,EAErC3rB,KAAKmqB,iBAAiB1R,yBAAyBzZ,EAAMY,IAC/D,OAAW,MAAPquB,EAAoB,MACxBA,EAAItJ,oBAAsB9a,GAAe,EACzCokB,EAAI1kB,SAAWA,EAASA,SACxB0kB,EAAIzpB,MAAQ+E,EAAS/E,MACjBymB,GAAc,EAAAtM,MAAM+M,gBAAgBuC,EAAIrnB,MAAOA,GAC5CqnB,GAER,KAAK,EAAAJ,eAAeK,KACf/V,EAAOqS,EAAMsB,gBACbllB,EAAQ4jB,EAAMmB,YACd9hB,EAAc2gB,EAAMc,SAAQ,GAFhC,IAGI6C,EAAMnuB,KAAKouB,eAAe5D,EAAO3gB,GAAe,EAAG,GACnDwkB,EAAYruB,KAAKsuB,eAAe9D,GAEhC+D,GADAhlB,EAAWvJ,KAAKguB,aAAaxD,EAAO3gB,GACvB2gB,EAAMc,SAAQ,IAC3BkD,EAAQ,KACRzD,EAAQ,EAAGC,EAAS,EASxB,OARIC,IACHuD,EAAQxuB,KAAKsuB,eAAe9D,GAC5BO,EAAQP,EAAMM,YACdE,EAASR,EAAMM,aAGJ,MAAR3S,IAAcA,EAAOvY,GAEb,OADRoqB,EAAOhqB,KAAKmqB,iBAAiB5R,kBAAkBvZ,EAAMY,EAAMuY,IACtC,MACzB6R,EAAK7R,KAAOA,EACZ,EAAAwG,MAAM+M,gBAAgB1B,EAAKpjB,MAAOA,GAClCojB,EAAKxlB,MAAQ+E,EAAS/E,MACtBwlB,EAAKzgB,SAAWA,EAASA,SACzBygB,EAAKrF,oBAAsB9a,GAAe,EAC1CmgB,EAAKqE,UAAYA,EACjBrE,EAAKyE,UAAY,IAAIC,aAAaP,GAElCnE,EAAKuE,WAAaA,GAAc,EAC5BtD,IACHjB,EAAKwE,MAAQA,EACbxE,EAAKe,MAAQA,EAAQllB,EACrBmkB,EAAKgB,OAASA,EAASnlB,GAEjBmkB,GAER,KAAK,EAAA6D,eAAec,WACfxW,EAAOqS,EAAMsB,gBACbllB,EAAQ4jB,EAAMmB,YADlB,IAYI3B,EAVAf,EAAWuB,EAAMsB,gBACjB,EAAStB,EAAMsB,gBACfiB,EAAgBvC,EAAMU,cACtBH,EAAQ,EAAGC,EAAS,EAQxB,OAPIC,IACHF,EAAQP,EAAMM,YACdE,EAASR,EAAMM,aAGJ,MAAR3S,IAAcA,EAAOvY,GAEb,OADRoqB,EAAOhqB,KAAKmqB,iBAAiB5R,kBAAkBvZ,EAAMY,EAAMuY,IACtC,MACzB6R,EAAK7R,KAAOA,EACZ,EAAAwG,MAAM+M,gBAAgB1B,EAAKpjB,MAAOA,GAC9BqkB,IACHjB,EAAKe,MAAQA,EAAQllB,EACrBmkB,EAAKgB,OAASA,EAASnlB,GAExB7F,KAAKoqB,aAAa1f,KAAK,IAAIikB,EAAW3E,EAAMf,EAAUpiB,EAAW,EAAQkmB,IAClE/C,GAER,KAAK,EAAA6D,eAAee,KAMnB,IALA,IAAI,EAASpE,EAAMU,cACfnG,EAAgByF,EAAMU,cAGtBxI,GAFA7Y,EAAc2gB,EAAMc,SAAQ,GAC5B/hB,EAAWvJ,KAAKguB,aAAaxD,EAAO3gB,GAC1B,EAAAjI,MAAMitB,SAAShlB,EAAc,EAAG,IACrC3J,EAAI,EAAGa,EAAI2hB,EAAQviB,OAAQD,EAAIa,EAAGb,IAC1CwiB,EAAQxiB,GAAKsqB,EAAMM,YAAcjlB,EAC9Be,EAAQqkB,EAAeT,EAAMmB,YAAc,EAG/C,OAAY,OADRxT,EAAOnY,KAAKmqB,iBAAiBxR,kBAAkB3Z,EAAMY,IAChC,MACzBuY,EAAKsM,OAAS,EACdtM,EAAK4M,cAAgBA,EACrB5M,EAAKwM,oBAAsB9a,GAAe,EAC1CsO,EAAK5O,SAAWA,EAASA,SACzB4O,EAAK3T,MAAQ+E,EAAS/E,MACtB2T,EAAKuK,QAAUA,EACXuI,GAAc,EAAAtM,MAAM+M,gBAAgBvT,EAAKvR,MAAOA,GAC7CuR,GAER,KAAK,EAAA0V,eAAeiB,MACfnqB,EAAW6lB,EAAMM,YACjBvnB,EAAIinB,EAAMM,YACVtnB,EAAIgnB,EAAMM,YACVlkB,EAAQqkB,EAAeT,EAAMmB,YAAc,EAH/C,IAKIoD,EAAQ/uB,KAAKmqB,iBAAiBtR,mBAAmB7Z,EAAMY,GAC3D,OAAa,MAATmvB,EAAsB,MAC1BA,EAAMxrB,EAAIA,EAAIsC,EACdkpB,EAAMvrB,EAAIA,EAAIqC,EACdkpB,EAAMpqB,SAAWA,EACbsmB,GAAc,EAAAtM,MAAM+M,gBAAgBqD,EAAMnoB,MAAOA,GAC9CmoB,GAER,KAAK,EAAAlB,eAAemB,SACnB,IAAIC,EAAezE,EAAMc,SAAQ,GAK7B4D,GAJArlB,EAAc2gB,EAAMc,SAAQ,GAC5B/hB,EAAWvJ,KAAKguB,aAAaxD,EAAO3gB,GACpCjD,EAAQqkB,EAAeT,EAAMmB,YAAc,EAEpC3rB,KAAKmqB,iBAAiBpR,sBAAsB/Z,EAAMY,IAC7D,OAAY,MAARsvB,EAAqB,MACzBA,EAAKC,QAAUrb,EAAaxM,MAAM2nB,GAClCC,EAAKvK,oBAAsB9a,GAAe,EAC1CqlB,EAAK3lB,SAAWA,EAASA,SACzB2lB,EAAK1qB,MAAQ+E,EAAS/E,MAClBymB,GAAc,EAAAtM,MAAM+M,gBAAgBwD,EAAKtoB,MAAOA,GAC7CsoB,GAGR,OAAO,MAGA,YAAAlB,aAAR,SAAsBxD,EAAoB3gB,GACzC,IAAI6a,EAAiB7a,GAAe,EAChCN,EAAW,IAAI6lB,EACfvpB,EAAQ7F,KAAK6F,MACjB,IAAK2kB,EAAMU,cAEV,OADA3hB,EAASA,SAAWvJ,KAAKouB,eAAe5D,EAAO9F,EAAgB7e,GACxD0D,EAIR,IAFA,IAAI8lB,EAAU,IAAIvmB,MACdwmB,EAAa,IAAIxmB,MACZ5I,EAAI,EAAGA,EAAI2J,EAAa3J,IAAK,CACrC,IAAIojB,EAAYkH,EAAMc,SAAQ,GAC9BgE,EAAW5kB,KAAK4Y,GAChB,IAAK,IAAIzS,EAAK,EAAGA,EAAKyS,EAAWzS,IAChCye,EAAW5kB,KAAK8f,EAAMc,SAAQ,IAC9B+D,EAAQ3kB,KAAK8f,EAAMM,YAAcjlB,GACjCwpB,EAAQ3kB,KAAK8f,EAAMM,YAAcjlB,GACjCwpB,EAAQ3kB,KAAK8f,EAAMM,aAKrB,OAFAvhB,EAASA,SAAW,EAAA3H,MAAM2tB,aAAaF,GACvC9lB,EAAS/E,MAAQ8qB,EACV/lB,GAGA,YAAA6kB,eAAR,SAAwB5D,EAAoBzpB,EAAW8E,GACtD,IAAI2pB,EAAQ,IAAI1mB,MAAc/H,GAC9B,GAAa,GAAT8E,EACH,IAAK,IAAI3F,EAAI,EAAGA,EAAIa,EAAGb,IACtBsvB,EAAMtvB,GAAKsqB,EAAMM,iBAElB,IAAS5qB,EAAI,EAAGA,EAAIa,EAAGb,IACtBsvB,EAAMtvB,GAAKsqB,EAAMM,YAAcjlB,EAEjC,OAAO2pB,GAGA,YAAAlB,eAAR,SAAwB9D,GAGvB,IAFA,IAAIzpB,EAAIypB,EAAMc,SAAQ,GAClBkE,EAAQ,IAAI1mB,MAAc/H,GACrBb,EAAI,EAAGA,EAAIa,EAAGb,IACtBsvB,EAAMtvB,GAAKsqB,EAAMiF,YAClB,OAAOD,GAGA,YAAAjC,cAAR,SAAuB/C,EAAoB5qB,EAAckU,GAQxD,IAPA,IAAIjU,EAAY,IAAIiJ,MAChBjD,EAAQ7F,KAAK6F,MACb/F,EAAW,EACX4vB,EAAa,IAAI,EAAA/Q,MACjBgR,EAAa,IAAI,EAAAhR,MAGZze,EAAI,EAAGa,EAAIypB,EAAMc,SAAQ,GAAOprB,EAAIa,EAAGb,IAE/C,IADA,IAAI2G,EAAY2jB,EAAMc,SAAQ,GACrBza,EAAK,EAAGoZ,EAAKO,EAAMc,SAAQ,GAAOza,EAAKoZ,EAAIpZ,IAAM,CACzD,IAAI+e,EAAepF,EAAMyB,WACrBvqB,EAAa8oB,EAAMc,SAAQ,GAC/B,OAAQsE,GACR,KAAKpE,EAAeqE,iBACf9e,EAAW,IAAI,EAAA5H,mBAAmBzH,IAC7BmF,UAAYA,EACrB,IAAK,IAAI3E,EAAa,EAAGA,EAAaR,EAAYQ,IACjD6O,EAAS5M,SAASjC,EAAYsoB,EAAMM,YAAaN,EAAMsB,iBACxDjsB,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,OAAOtC,EAAa,IAC3D,MAED,KAAK8pB,EAAesE,YACf/e,EAAW,IAAI,EAAApK,cAAcjF,IACxBmF,UAAYA,EACrB,IAAS3E,EAAa,EAAGA,EAAaR,EAAYQ,IAAc,CAC/D,IAAIxB,EAAO8pB,EAAMM,YACjB,EAAAnM,MAAM+M,gBAAgBgE,EAAYlF,EAAMmB,aACxC5a,EAAS5M,SAASjC,EAAYxB,EAAMgvB,EAAWpqB,EAAGoqB,EAAW5oB,EAAG4oB,EAAW3oB,EAAG2oB,EAAW1oB,GACrF9E,EAAaR,EAAa,GAAG1B,KAAK+vB,UAAUvF,EAAOtoB,EAAY6O,GAEpElR,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,QAAQtC,EAAa,GAAK,EAAAiF,cAAc7B,UAC/E,MAED,KAAK0mB,EAAewE,gBACfjf,EAAW,IAAI,EAAAlJ,iBAAiBnG,IAC3BmF,UAAYA,EACrB,IAAS3E,EAAa,EAAGA,EAAaR,EAAYQ,IAAc,CAC3DxB,EAAO8pB,EAAMM,YACjB,EAAAnM,MAAM+M,gBAAgBgE,EAAYlF,EAAMmB,aACxC,EAAAhN,MAAMkN,cAAc8D,EAAYnF,EAAMmB,aACtC5a,EAAS5M,SAASjC,EAAYxB,EAAMgvB,EAAWpqB,EAAGoqB,EAAW5oB,EAAG4oB,EAAW3oB,EAAG2oB,EAAW1oB,EAAG2oB,EAAWrqB,EACtGqqB,EAAW7oB,EAAG6oB,EAAW5oB,GACtB7E,EAAaR,EAAa,GAAG1B,KAAK+vB,UAAUvF,EAAOtoB,EAAY6O,GAEpElR,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,QAAQtC,EAAa,GAAK,EAAAmG,iBAAiB/C,WAQrF,IAAS5E,EAAI,EAAGa,EAAIypB,EAAMc,SAAQ,GAAOprB,EAAIa,EAAGb,IAC/C,KAAIgE,EAAYsmB,EAAMc,SAAQ,GAC9B,IAASza,EAAK,EAAGoZ,EAAKO,EAAMc,SAAQ,GAAOza,EAAKoZ,EAAIpZ,IAAM,CACrD+e,EAAepF,EAAMyB,WACrBvqB,EAAa8oB,EAAMc,SAAQ,GAC/B,OAAQsE,GACR,KAAKpE,EAAeyE,aACflf,EAAW,IAAI,EAAA1M,eAAe3C,IACzBwC,UAAYA,EACrB,IAAShC,EAAa,EAAGA,EAAaR,EAAYQ,IACjD6O,EAAS5M,SAASjC,EAAYsoB,EAAMM,YAAaN,EAAMM,aACnD5oB,EAAaR,EAAa,GAAG1B,KAAK+vB,UAAUvF,EAAOtoB,EAAY6O,GAEpElR,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,QAAQtC,EAAa,GAAK,EAAA2C,eAAeS,UAChF,MAED,KAAK0mB,EAAe0E,eACpB,KAAK1E,EAAe2E,WACpB,KAAK3E,EAAe4E,WACnB,IAAIrf,OAAQ,EACRsf,EAAgB,EAChBT,GAAgBpE,EAAe2E,WAClCpf,EAAW,IAAI,EAAA/K,cAActE,GACrBkuB,GAAgBpE,EAAe4E,WACvCrf,EAAW,IAAI,EAAArK,cAAchF,IAE7BqP,EAAW,IAAI,EAAAxL,kBAAkB7D,GACjC2uB,EAAgBxqB,GAEjBkL,EAAS7M,UAAYA,EACrB,IAAShC,EAAa,EAAGA,EAAaR,EAAYQ,IACjD6O,EAAS5M,SAASjC,EAAYsoB,EAAMM,YAAaN,EAAMM,YAAcuF,EACpE7F,EAAMM,YAAcuF,GACjBnuB,EAAaR,EAAa,GAAG1B,KAAK+vB,UAAUvF,EAAOtoB,EAAY6O,GAEpElR,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,QAAQtC,EAAa,GAAK,EAAA6D,kBAAkBT,YAQtF,IAAS5E,EAAI,EAAGa,EAAIypB,EAAMc,SAAQ,GAAOprB,EAAIa,EAAGb,IAAK,CACpD,IAAIqC,EAAQioB,EAAMc,SAAQ,GACtB5pB,EAAa8oB,EAAMc,SAAQ,IAC3Bva,EAAW,IAAI,EAAA/F,qBAAqBtJ,IAC/BwJ,kBAAoB3I,EAC7B,IAASL,EAAa,EAAGA,EAAaR,EAAYQ,IACjD6O,EAAS5M,SAASjC,EAAYsoB,EAAMM,YAAaN,EAAMM,YAAaN,EAAMM,YAAcjlB,EAAO2kB,EAAMyB,WAAYzB,EAAMU,cACtHV,EAAMU,eACHhpB,EAAaR,EAAa,GAAG1B,KAAK+vB,UAAUvF,EAAOtoB,EAAY6O,GAEpElR,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,QAAQtC,EAAa,GAAK,EAAAsJ,qBAAqBlG,UAIvF,IAAS5E,EAAI,EAAGa,EAAIypB,EAAMc,SAAQ,GAAOprB,EAAIa,EAAGb,IAAK,CAChDqC,EAAQioB,EAAMc,SAAQ,GACtB5pB,EAAa8oB,EAAMc,SAAQ,IAC3Bva,EAAW,IAAI,EAAA1E,4BAA4B3K,IACtC6K,yBAA2BhK,EACpC,IAASL,EAAa,EAAGA,EAAaR,EAAYQ,IACjD6O,EAAS5M,SAASjC,EAAYsoB,EAAMM,YAAaN,EAAMM,YAAaN,EAAMM,YAAaN,EAAMM,YAC5FN,EAAMM,aACH5oB,EAAaR,EAAa,GAAG1B,KAAK+vB,UAAUvF,EAAOtoB,EAAY6O,GAEpElR,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,QAAQtC,EAAa,GAAK,EAAA2K,4BAA4BvH,UAI9F,IAAS5E,EAAI,EAAGa,EAAIypB,EAAMc,SAAQ,GAAOprB,EAAIa,EAAGb,IAC/C,CAAIqC,EAAQioB,EAAMc,SAAQ,GAA1B,IACI1mB,EAAOkP,EAAapG,gBAAgBnL,GACxC,IAASsO,EAAK,EAAGoZ,EAAKO,EAAMc,SAAQ,GAAOza,EAAKoZ,EAAIpZ,IAAM,CACrD+e,EAAepF,EAAMyB,WACrBvqB,EAAa8oB,EAAMc,SAAQ,GAC/B,OAAQsE,GACR,KAAKpE,EAAe8E,cACpB,KAAK9E,EAAe+E,aACfxf,OAAQ,EACRsf,EAAgB,EAChBT,GAAgBpE,EAAe+E,cAClCxf,EAAW,IAAI,EAAAhD,8BAA8BrM,GACzCkD,EAAKie,aAAe,EAAAE,YAAYC,QAAUpe,EAAKie,aAAe,EAAAE,YAAY6J,QAAOyD,EAAgBxqB,KAErGkL,EAAW,IAAI,EAAA1D,+BAA+B3L,GAC1CkD,EAAKgf,cAAgB,EAAAC,aAAa+I,QAAOyD,EAAgBxqB,IAE9DkL,EAASxD,oBAAsBhL,EAC/B,IAASL,EAAa,EAAGA,EAAaR,EAAYQ,IACjD6O,EAAS5M,SAASjC,EAAYsoB,EAAMM,YAAaN,EAAMM,YAAcuF,GACjEnuB,EAAaR,EAAa,GAAG1B,KAAK+vB,UAAUvF,EAAOtoB,EAAY6O,GAEpElR,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,QAAQtC,EAAa,GAAK,EAAA2L,+BAA+BvI,UAChG,MAED,KAAK0mB,EAAegF,UACfzf,EAAW,IAAI,EAAA/C,0BAA0BtM,IACpC6L,oBAAsBhL,EAC/B,IAASL,EAAa,EAAGA,EAAaR,EAAYQ,IACjD6O,EAAS5M,SAASjC,EAAYsoB,EAAMM,YAAaN,EAAMM,YAAaN,EAAMM,aACtE5oB,EAAaR,EAAa,GAAG1B,KAAK+vB,UAAUvF,EAAOtoB,EAAY6O,GAEpElR,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,QAAQtC,EAAa,GAAK,EAAAsM,0BAA0BlJ,YAQ9F,IAAS5E,EAAI,EAAGa,EAAIypB,EAAMc,SAAQ,GAAOprB,EAAIa,EAAGb,IAC/C,KAAIlB,EAAO8U,EAAawU,MAAMkC,EAAMc,SAAQ,IAC5C,IAASza,EAAK,EAAGoZ,EAAKO,EAAMc,SAAQ,GAAOza,EAAKoZ,EAAIpZ,IACnD,CAAIhK,EAAY2jB,EAAMc,SAAQ,GAC9B,IADA,IACSmF,EAAM,EAAGC,EAAMlG,EAAMc,SAAQ,GAAOmF,EAAMC,EAAKD,IAAO,CAC9D,IAAI1nB,EAAa/J,EAAKkK,cAAcrC,EAAW2jB,EAAMsB,iBACjD6E,EAA+B,MAApB5nB,EAAWvE,MACtB+E,EAAWR,EAAWQ,SACtBqnB,EAAeD,EAAWpnB,EAASpJ,OAAS,EAAI,EAAIoJ,EAASpJ,OAE7DuB,EAAa8oB,EAAMc,SAAQ,IAC3Bva,EAAW,IAAI,EAAAzG,eAAe5I,IACzBmF,UAAYA,EACrBkK,EAAShI,WAAaA,EAEtB,IAAS7G,EAAa,EAAGA,EAAaR,EAAYQ,IAAc,CAC3DxB,EAAO8pB,EAAMM,YAAjB,IACIxhB,OAAM,EACNqG,EAAM6a,EAAMc,SAAQ,GACxB,GAAW,GAAP3b,EACHrG,EAASqnB,EAAW,EAAA/uB,MAAMC,cAAc+uB,GAAgBrnB,MACpD,CACJD,EAAS,EAAA1H,MAAMC,cAAc+uB,GAC7B,IAAI/sB,EAAQ2mB,EAAMc,SAAQ,GAE1B,GADA3b,GAAO9L,EACM,GAATgC,EACH,IAAK,IAAIgrB,EAAIhtB,EAAOgtB,EAAIlhB,EAAKkhB,IAC5BvnB,EAAOunB,GAAKrG,EAAMM,iBAEnB,IAAS+F,EAAIhtB,EAAOgtB,EAAIlhB,EAAKkhB,IAC5BvnB,EAAOunB,GAAKrG,EAAMM,YAAcjlB,EAElC,IAAK8qB,EACC,CAAIE,EAAI,EAAb,IAAK,IAAWC,EAAKxnB,EAAOnJ,OAAQ0wB,EAAIC,EAAID,IAC3CvnB,EAAOunB,IAAMtnB,EAASsnB,IAIzB9f,EAAS5M,SAASjC,EAAYxB,EAAM4I,GAChCpH,EAAaR,EAAa,GAAG1B,KAAK+vB,UAAUvF,EAAOtoB,EAAY6O,GAEpElR,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,OAAOtC,EAAa,MAM9D,IAAIqvB,EAAiBvG,EAAMc,SAAQ,GACnC,GAAIyF,EAAiB,EAAG,CACnBhgB,EAAW,IAAI,EAAAhG,kBAAkBgmB,GAArC,IACIvD,EAAY1Z,EAAaxM,MAAMnH,OACnC,IAASD,EAAI,EAAGA,EAAI6wB,EAAgB7wB,IAAK,CACpCQ,EAAO8pB,EAAMM,YAAjB,IACIkG,EAAcxG,EAAMc,SAAQ,GAC5BzgB,EAAY,EAAAjJ,MAAMitB,SAASrB,EAAW,GAC1C,IAAS3c,EAAK2c,EAAY,EAAG3c,GAAM,EAAGA,IACrChG,EAAUgG,IAAO,EAClB,IAAIogB,EAAY,EAAArvB,MAAMitB,SAASrB,EAAYwD,EAAa,GACpDE,EAAgB,EAAGC,EAAiB,EACxC,IAAStgB,EAAK,EAAGA,EAAKmgB,EAAangB,IAAM,CAGxC,IAFIhK,EAAY2jB,EAAMc,SAAQ,GAEvB4F,GAAiBrqB,GACvBoqB,EAAUE,KAAoBD,IAE/BrmB,EAAUqmB,EAAgB1G,EAAMc,SAAQ,IAAS4F,IAGlD,KAAOA,EAAgB1D,GACtByD,EAAUE,KAAoBD,IAE/B,IAASrgB,EAAK2c,EAAY,EAAG3c,GAAM,EAAGA,KACf,GAAlBhG,EAAUgG,KAAWhG,EAAUgG,GAAMogB,IAAYE,IACtDpgB,EAAS5M,SAASjE,EAAGQ,EAAMmK,GAE5BhL,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,OAAO+sB,EAAiB,IAIhE,IAAIK,EAAa5G,EAAMc,SAAQ,GAC/B,GAAI8F,EAAa,EAAG,CAEnB,IADIrgB,EAAW,IAAI,EAAApG,cAAcymB,GACxBlxB,EAAI,EAAGA,EAAIkxB,EAAYlxB,IAAK,CAChCQ,EAAO8pB,EAAMM,YAAjB,IACIuG,EAAYvd,EAAanT,OAAO6pB,EAAMc,SAAQ,IAC9C,EAAQ,IAAI,EAAAvM,MAAMre,EAAM2wB,GAC5B,EAAMpE,SAAWzC,EAAMc,SAAQ,GAC/B,EAAM4B,WAAa1C,EAAMM,YACzB,EAAMqC,YAAc3C,EAAMU,cAAgBV,EAAMG,aAAe0G,EAAUlE,YAC7C,MAAxB,EAAMvoB,KAAKymB,YACd,EAAM+B,OAAS5C,EAAMM,YACrB,EAAMuC,QAAU7C,EAAMM,aAEvB/Z,EAAS5M,SAASjE,EAAG,GAEtBL,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,OAAOotB,EAAa,IAG5D,OAAO,IAAI,EAAA3vB,UAAU7B,EAAMC,EAAWC,IAG/B,YAAAiwB,UAAR,SAAmBvF,EAAoBtoB,EAAoB6O,GAC1D,OAAQyZ,EAAMyB,YACd,KAAKT,EAAe8F,cACnBvgB,EAAS3O,WAAWF,GACpB,MACD,KAAKspB,EAAe+F,aACnBvxB,KAAK0C,SAASqO,EAAU7O,EAAYsoB,EAAMM,YAAaN,EAAMM,YAAaN,EAAMM,YAAaN,EAAMM,eAKrG,YAAApoB,SAAA,SAAUqO,EAAyB7O,EAAoBS,EAAaC,EAAaC,EAAaC,GAC7FiO,EAASrO,SAASR,EAAYS,EAAKC,EAAKC,EAAKC,IA/uBvC,EAAA8qB,qBAAuB,CAAE,EAA6B,EAAiC,EAA0B,EAAgC,EAA0B,EAA2B,GACtM,EAAAnC,oBAAsB,CAAC,EAAAnQ,cAAcC,OAAQ,EAAAD,cAAcM,gBAAiB,EAAAN,cAAcO,uBAAwB,EAAAP,cAAcc,QAAS,EAAAd,cAAce,qBACvJ,EAAAoQ,mBAAqB,CAAE,EAAA5I,aAAa+I,MAAO,EAAA/I,aAAaC,SACxD,EAAA4I,kBAAoB,CAAE,EAAA3J,YAAYC,OAAQ,EAAAD,YAAY6J,MAAO,EAAA7J,YAAYe,SACzE,EAAA6I,iBAAmB,CAAE,EAAAxJ,WAAWC,QAAS,EAAAD,WAAWgB,MAAO,EAAAhB,WAAWE,YACtE,EAAA2I,gBAAkB,CAAE,EAAA9S,UAAUqC,OAAQ,EAAArC,UAAUsY,SAAU,EAAAtY,UAAUuY,SAAU,EAAAvY,UAAUwY,QAExF,EAAAzB,YAAc,EACd,EAAAC,eAAiB,EACjB,EAAAC,WAAa,EACb,EAAAC,WAAa,EAEb,EAAAP,gBAAkB,EAClB,EAAAC,WAAa,EACb,EAAAE,eAAiB,EAEjB,EAAAM,cAAgB,EAChB,EAAAC,aAAe,EACf,EAAAC,SAAW,EAEX,EAAAmB,aAAe,EACf,EAAAL,cAAgB,EAChB,EAAAC,aAAe,EA2tBvB,EAlvBA,GAAa,EAAA/F,eAAc,EAovB3B,iBACC,WAAY5mB,EAAyB2mB,EAAuChpB,EAA2BqvB,QAAlE,IAAArG,MAAA,IAAcziB,YAAyB,IAAAvG,MAAA,QAA2B,IAAAqvB,MAAA,IAAaC,SAASjtB,EAAKgtB,SAA7F,KAAArG,UAAuC,KAAAhpB,QAA2B,KAAAqvB,SAuFxG,OAnFC,YAAA3F,SAAA,WACC,OAAOjsB,KAAK4xB,OAAOE,QAAQ9xB,KAAKuC,UAGjC,YAAAktB,UAAA,WACC,IAAIjiB,EAAQxN,KAAK4xB,OAAOG,SAAS/xB,KAAKuC,OAEtC,OADAvC,KAAKuC,OAAS,EACPiL,GAGR,YAAAme,UAAA,WACE,IAAIne,EAAQxN,KAAK4xB,OAAOI,SAAShyB,KAAKuC,OAEtC,OADAvC,KAAKuC,OAAS,EACPiL,GAGT,YAAA8d,QAAA,SAAQ2G,GACP,IAAIlrB,EAAI/G,KAAKisB,WACTiG,EAAa,IAAJnrB,EAiBb,OAhBkB,IAAT,IAAJA,KAEJmrB,IAAe,KADfnrB,EAAI/G,KAAKisB,cACe,EACN,IAAT,IAAJllB,KAEJmrB,IAAe,KADfnrB,EAAI/G,KAAKisB,cACe,GACN,IAAT,IAAJllB,KAEJmrB,IAAe,KADfnrB,EAAI/G,KAAKisB,cACe,GACN,IAAT,IAAJllB,KAEJmrB,IAAe,KADfnrB,EAAI/G,KAAKisB,cACe,OAKrBgG,EAAmBC,EAAWA,IAAW,IAAgB,EAATA,IAGxD,YAAApG,cAAA,WACC,IAAIvpB,EAAQvC,KAAKsrB,SAAQ,GACzB,OAAgB,GAAT/oB,EAAa,KAAOvC,KAAKurB,QAAQhpB,EAAQ,IAGjD,YAAAooB,WAAA,WACC,IAAIwH,EAAYnyB,KAAKsrB,SAAQ,GAC7B,OAAQ6G,GACR,KAAK,EACJ,OAAO,KACR,KAAK,EACJ,MAAO,GAERA,IAGA,IAFA,IAAIC,EAAQ,GAEHlyB,EAAI,EAAGA,EAAIiyB,GAAY,CAC/B,IAAIprB,EAAI/G,KAAKisB,WACb,OAAQllB,GAAK,GACb,KAAK,GACL,KAAK,GACJqrB,GAASC,OAAOC,cAAmB,GAAJvrB,IAAa,EAAsB,GAAlB/G,KAAKisB,YACrD/rB,GAAK,EACL,MACD,KAAK,GACJkyB,GAASC,OAAOC,cAAmB,GAAJvrB,IAAa,IAAwB,GAAlB/G,KAAKisB,aAAsB,EAAsB,GAAlBjsB,KAAKisB,YACtF/rB,GAAK,EACL,MACD,QACCkyB,GAASC,OAAOC,aAAavrB,GAC7B7G,KAGF,OAAOkyB,GAGR,YAAAtH,UAAA,WACC,IAAItd,EAAQxN,KAAK4xB,OAAOW,WAAWvyB,KAAKuC,OAExC,OADAvC,KAAKuC,OAAS,EACPiL,GAGR,YAAA0d,YAAA,WACC,OAA0B,GAAnBlrB,KAAKisB,YAEd,EAxFA,GA0FA,EAMC,SAAajC,EAAsBhrB,EAAc6H,EAAmBsS,EAAgB4T,GACnF/sB,KAAKgqB,KAAOA,EACZhqB,KAAKhB,KAAOA,EACZgB,KAAK6G,UAAYA,EACjB7G,KAAKmZ,OAASA,EACdnZ,KAAK+sB,cAAgBA,GAIvB,EACC,SAAmBvoB,EAAoC+E,QAApC,IAAA/E,MAAA,WAAoC,IAAA+E,MAAA,MAApC,KAAA/E,QAAoC,KAAA+E,YA/1BpC,GAAA/J,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCEpB,SAAUA,IAAW,SAAAC,GACjB,8BACI,KAAAsiB,KAAO,EAAG,KAAAE,KAAO,EAAG,KAAAE,KAAO,EAAG,KAAAE,KAAO,EACrC,KAAAoQ,cAAgB,IAAI1pB,MACpB,KAAA2pB,SAAW,IAAI3pB,MACP,KAAA4pB,YAAc,IAAI,EAAA9jB,MAAwB,WAC9C,OAAO,EAAAhN,MAAMC,cAAc,OAyKnC,OAtKI,YAAAzD,OAAA,SAAQoC,EAAoBmyB,GACxB,GAAgB,MAAZnyB,EAAkB,MAAM,IAAIT,MAAM,4BACtC,IAAIyyB,EAAgBxyB,KAAKwyB,cACrBC,EAAWzyB,KAAKyyB,SAChBC,EAAc1yB,KAAK0yB,YACnBprB,EAAQ9G,EAAS8G,MACjBkmB,EAAYlmB,EAAMnH,OAEtBqyB,EAAcryB,OAAS,EACvBuyB,EAAYE,QAAQH,GACpBA,EAAStyB,OAAS,EAElB,IAAK,IAAID,EAAI,EAAGA,EAAIstB,EAAWttB,IAAK,CAChC,IAAImH,EAAOC,EAAMpH,GACjB,GAAKmH,EAAK9C,KAAKE,OAAf,CACA,IAAIsE,EAAa1B,EAAK6B,gBACtB,GAAIH,aAAsB,EAAA2P,sBAAuB,CAC7C,IAAIma,EAAc9pB,EAClBypB,EAAc9nB,KAAKmoB,GAEnB,IAAIC,EAAUJ,EAAYhe,SACtBoe,EAAQ3yB,QAAU0yB,EAAYlO,sBAC9BmO,EAAU,EAAAlxB,MAAMC,cAAcgxB,EAAYlO,sBAE9C8N,EAAS/nB,KAAKooB,GACdD,EAAYzN,qBAAqB/d,EAAM,EAAGwrB,EAAYlO,oBAAqBmO,EAAS,EAAG,KAI3FH,EACA3yB,KAAK+yB,eAEL/yB,KAAK8hB,KAAOtX,OAAOsf,kBACnB9pB,KAAKgiB,KAAOxX,OAAOsf,kBACnB9pB,KAAKkiB,KAAO1X,OAAOuf,kBACnB/pB,KAAKoiB,KAAO5X,OAAOuf,oBAI3B,YAAAgJ,YAAA,WAGI,IAFA,IAAIjR,EAAOtX,OAAOsf,kBAAmB9H,EAAOxX,OAAOsf,kBAAmB5H,EAAO1X,OAAOuf,kBAAmB3H,EAAO5X,OAAOuf,kBACjH0I,EAAWzyB,KAAKyyB,SACXvyB,EAAI,EAAGa,EAAI0xB,EAAStyB,OAAQD,EAAIa,EAAGb,IAGxC,IAFA,IAAI4yB,EAAUL,EAASvyB,GACnBqJ,EAAWupB,EACNjiB,EAAK,EAAGoZ,EAAK6I,EAAQ3yB,OAAQ0Q,EAAKoZ,EAAIpZ,GAAM,EAAG,CACpD,IAAItN,EAAIgG,EAASsH,GACbrN,EAAI+F,EAASsH,EAAK,GACtBiR,EAAO1b,KAAKuN,IAAImO,EAAMve,GACtBye,EAAO5b,KAAKuN,IAAIqO,EAAMxe,GACtB0e,EAAO9b,KAAKmM,IAAI2P,EAAM3e,GACtB6e,EAAOhc,KAAKmM,IAAI6P,EAAM5e,GAG9BxD,KAAK8hB,KAAOA,EACZ9hB,KAAKgiB,KAAOA,EACZhiB,KAAKkiB,KAAOA,EACZliB,KAAKoiB,KAAOA,GAIhB,YAAA4Q,kBAAA,SAAmBzvB,EAAWC,GAC1B,OAAOD,GAAKvD,KAAK8hB,MAAQve,GAAKvD,KAAKkiB,MAAQ1e,GAAKxD,KAAKgiB,MAAQxe,GAAKxD,KAAKoiB,MAI3E,YAAA6Q,sBAAA,SAAuBvN,EAAYC,EAAYC,EAAYC,GACvD,IAAI/D,EAAO9hB,KAAK8hB,KACZE,EAAOhiB,KAAKgiB,KACZE,EAAOliB,KAAKkiB,KACZE,EAAOpiB,KAAKoiB,KAChB,GAAKsD,GAAM5D,GAAQ8D,GAAM9D,GAAU6D,GAAM3D,GAAQ6D,GAAM7D,GAAU0D,GAAMxD,GAAQ0D,GAAM1D,GAAUyD,GAAMvD,GAAQyD,GAAMzD,EAC/G,OAAO,EACX,IAAI7H,GAAKsL,EAAKF,IAAOC,EAAKF,GACtBliB,EAAI+W,GAAKuH,EAAO4D,GAAMC,EAC1B,GAAIniB,EAAIwe,GAAQxe,EAAI4e,EAAM,OAAO,EAEjC,IADA5e,EAAI+W,GAAK2H,EAAOwD,GAAMC,GACd3D,GAAQxe,EAAI4e,EAAM,OAAO,EACjC,IAAI7e,GAAKye,EAAO2D,GAAMpL,EAAImL,EAC1B,OAAIniB,EAAIue,GAAQve,EAAI2e,IACpB3e,GAAK6e,EAAOuD,GAAMpL,EAAImL,GACd5D,GAAQve,EAAI2e,GAKxB,YAAAgR,uBAAA,SAAwBC,GACpB,OAAOnzB,KAAK8hB,KAAOqR,EAAOjR,MAAQliB,KAAKkiB,KAAOiR,EAAOrR,MAAQ9hB,KAAKgiB,KAAOmR,EAAO/Q,MAAQpiB,KAAKoiB,KAAO+Q,EAAOnR,MAK/G,YAAAoR,cAAA,SAAe7vB,EAAWC,GAEtB,IADA,IAAIivB,EAAWzyB,KAAKyyB,SACXvyB,EAAI,EAAGa,EAAI0xB,EAAStyB,OAAQD,EAAIa,EAAGb,IACxC,GAAIF,KAAKqzB,qBAAqBZ,EAASvyB,GAAIqD,EAAGC,GAAI,OAAOxD,KAAKwyB,cAActyB,GAChF,OAAO,MAIX,YAAAmzB,qBAAA,SAAsBP,EAA4BvvB,EAAWC,GAMzD,IALA,IAAI+F,EAAWupB,EACX7I,EAAK6I,EAAQ3yB,OAEbmzB,EAAYrJ,EAAK,EACjBsJ,GAAS,EACJ1iB,EAAK,EAAGA,EAAKoZ,EAAIpZ,GAAM,EAAG,CAC/B,IAAI2iB,EAAUjqB,EAASsH,EAAK,GACxB9M,EAAQwF,EAAS+pB,EAAY,GACjC,GAAKE,EAAUhwB,GAAKO,GAASP,GAAOO,EAAQP,GAAKgwB,GAAWhwB,EAAI,CAC5D,IAAIiwB,EAAUlqB,EAASsH,GACnB4iB,GAAWjwB,EAAIgwB,IAAYzvB,EAAQyvB,IAAYjqB,EAAS+pB,GAAaG,GAAWlwB,IAAGgwB,GAAUA,GAErGD,EAAYziB,EAEhB,OAAO0iB,GAMX,YAAAG,kBAAA,SAAmBhO,EAAYC,EAAYC,EAAYC,GAEnD,IADA,IAAI4M,EAAWzyB,KAAKyyB,SACXvyB,EAAI,EAAGa,EAAI0xB,EAAStyB,OAAQD,EAAIa,EAAGb,IACxC,GAAIF,KAAK2zB,yBAAyBlB,EAASvyB,GAAIwlB,EAAIC,EAAIC,EAAIC,GAAK,OAAO7lB,KAAKwyB,cAActyB,GAC9F,OAAO,MAIX,YAAAyzB,yBAAA,SAA0Bb,EAA4BpN,EAAYC,EAAYC,EAAYC,GAOtF,IANA,IAAItc,EAAWupB,EACX7I,EAAK6I,EAAQ3yB,OAEbyzB,EAAUlO,EAAKE,EAAIiO,EAAWlO,EAAKE,EACnCiO,EAAOpO,EAAKG,EAAKF,EAAKC,EACtBmO,EAAKxqB,EAAS0gB,EAAK,GAAI+J,EAAKzqB,EAAS0gB,EAAK,GACrCpZ,EAAK,EAAGA,EAAKoZ,EAAIpZ,GAAM,EAAG,CAC/B,IAAIojB,EAAK1qB,EAASsH,GAAKqjB,EAAK3qB,EAASsH,EAAK,GACtCsjB,EAAOJ,EAAKG,EAAKF,EAAKC,EACtBG,EAAUL,EAAKE,EAAII,EAAWL,EAAKE,EACnCI,EAAOV,EAAUS,EAAWR,EAAWO,EACvC7wB,GAAKuwB,EAAOM,EAAUR,EAAUO,GAAQG,EAC5C,IAAM/wB,GAAKwwB,GAAMxwB,GAAK0wB,GAAQ1wB,GAAK0wB,GAAM1wB,GAAKwwB,KAAUxwB,GAAKmiB,GAAMniB,GAAKqiB,GAAQriB,GAAKqiB,GAAMriB,GAAKmiB,GAAM,CAClG,IAAIliB,GAAKswB,EAAOO,EAAWR,EAAWM,GAAQG,EAC9C,IAAM9wB,GAAKwwB,GAAMxwB,GAAK0wB,GAAQ1wB,GAAK0wB,GAAM1wB,GAAKwwB,KAAUxwB,GAAKmiB,GAAMniB,GAAKqiB,GAAQriB,GAAKqiB,GAAMriB,GAAKmiB,GAAM,OAAO,EAEjHoO,EAAKE,EACLD,EAAKE,EAET,OAAO,GAIX,YAAAK,WAAA,SAAY1B,GACR,GAAmB,MAAfA,EAAqB,MAAM,IAAI9yB,MAAM,+BACzC,IAAIwC,EAAQvC,KAAKwyB,cAAcjd,QAAQsd,GACvC,OAAiB,GAAVtwB,EAAc,KAAOvC,KAAKyyB,SAASlwB,IAG9C,YAAAiyB,SAAA,WACI,OAAOx0B,KAAKkiB,KAAOliB,KAAK8hB,MAG5B,YAAA2S,UAAA,WACI,OAAOz0B,KAAKoiB,KAAOpiB,KAAKgiB,MAEhC,EA9KA,GAAa,EAAA0S,eAAc,EADV,GAAAl1B,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCDpB,SAAUA,IAAW,SAAAC,GACpB,8BACS,KAAAm1B,aAAe,IAAI,EAAAC,aACnB,KAAAC,gBAAkB,IAAI/rB,MACtB,KAAAgsB,WAAa,IAAIhsB,MACzB,KAAAisB,gBAAkB,IAAIjsB,MACtB,KAAAksB,iBAAmB,IAAIlsB,MACf,KAAAmsB,QAAU,IAAInsB,MAySvB,OApSC,YAAAosB,UAAA,SAAW7tB,EAAY6nB,GACtB,GAA2B,MAAvBlvB,KAAKm1B,eAAwB,OAAO,EACxCn1B,KAAKm1B,eAAiBjG,EAEtB,IAAInuB,EAAImuB,EAAKvK,oBACTpb,EAAW,EAAA3H,MAAMmI,aAAa/J,KAAK60B,gBAAiB9zB,GACxDmuB,EAAK9J,qBAAqB/d,EAAM,EAAGtG,EAAGwI,EAAU,EAAG,GACnD,IAAIsrB,EAAkB70B,KAAK60B,gBAC3BO,EAAiBC,cAAcR,GAE/B,IADA,IAAIS,EAAmBt1B,KAAKs1B,iBAAmBt1B,KAAK20B,aAAaY,UAAUV,EAAiB70B,KAAK20B,aAAaa,YAAYX,IACjH30B,EAAI,EAAG,EAAIo1B,EAAiBn1B,OAAQD,EAAI,EAAGA,IAAK,CACxD,IAAI4yB,EAAUwC,EAAiBp1B,GAC/Bk1B,EAAiBC,cAAcvC,GAC/BA,EAAQpoB,KAAKooB,EAAQ,IACrBA,EAAQpoB,KAAKooB,EAAQ,IAGtB,OAAOwC,EAAiBn1B,QAGzB,YAAAs1B,gBAAA,SAAiBpuB,GACW,MAAvBrH,KAAKm1B,gBAA0Bn1B,KAAKm1B,eAAehG,SAAW9nB,EAAKzC,MAAM5E,KAAK01B,WAGnF,YAAAA,QAAA,WAC4B,MAAvB11B,KAAKm1B,iBACTn1B,KAAKm1B,eAAiB,KACtBn1B,KAAKs1B,iBAAmB,KACxBt1B,KAAK+0B,gBAAgB50B,OAAS,EAC9BH,KAAKg1B,iBAAiB70B,OAAS,EAC/BH,KAAK60B,gBAAgB10B,OAAS,IAG/B,YAAAw1B,WAAA,WACC,OAA8B,MAAvB31B,KAAKm1B,gBAGb,YAAAS,cAAA,SAAersB,EAA6Bmb,EAAwB2J,EAA8BwH,EAAyB1H,EAC1H7lB,EAAcC,EAAaT,GAE3B,IAAIgtB,EAAa90B,KAAK80B,WAAYC,EAAkB/0B,KAAK+0B,gBACrDC,EAAmBh1B,KAAKg1B,iBACxBvC,EAAWzyB,KAAKs1B,iBAChBQ,EAAgB91B,KAAKs1B,iBAAiBn1B,OACtC41B,EAAajuB,EAAW,GAAK,EAE7BvF,EAAQ,EACZwyB,EAAgB50B,OAAS,EACzB60B,EAAiB70B,OAAS,EAC1B8U,EACA,IAAK,IAAI/U,EAAI,EAAGA,EAAI21B,EAAiB31B,GAAK,EAazC,IAZA,IAAI81B,EAAe3H,EAAUnuB,IAAM,EAC/BwlB,EAAKnc,EAASysB,GAAerQ,EAAKpc,EAASysB,EAAe,GAC1DC,EAAK9H,EAAI6H,GAAeE,EAAK/H,EAAI6H,EAAe,GAGhDpQ,EAAKrc,EADTysB,EAAe3H,EAAUnuB,EAAI,IAAM,GACF2lB,EAAKtc,EAASysB,EAAe,GAC1DG,EAAKhI,EAAI6H,GAAeI,EAAKjI,EAAI6H,EAAe,GAGhDjC,EAAKxqB,EADTysB,EAAe3H,EAAUnuB,EAAI,IAAM,GACF8zB,EAAKzqB,EAASysB,EAAe,GAC1DK,EAAKlI,EAAI6H,GAAeM,EAAKnI,EAAI6H,EAAe,GAE3CvW,EAAI,EAAGA,EAAIqW,EAAerW,IAAK,CACvC,IAAI1D,EAAIgZ,EAAgB50B,OACxB,IAAIH,KAAKkvB,KAAKxJ,EAAIC,EAAIC,EAAIC,EAAIkO,EAAIC,EAAIvB,EAAShT,GAAIqV,GA2C5C,EACFyB,EAAuB,EAAA30B,MAAMmI,aAAagrB,EAAiBhZ,EAAI,EAAIga,IAClDha,GAAK2J,EAC1B6Q,EAAqBxa,EAAI,GAAK4J,EAC9B4Q,EAAqBxa,EAAI,GAAKzT,EAAMhD,EACpCixB,EAAqBxa,EAAI,GAAKzT,EAAMxB,EACpCyvB,EAAqBxa,EAAI,GAAKzT,EAAMvB,EACpCwvB,EAAqBxa,EAAI,GAAKzT,EAAMtB,EAC/Bc,GAsBJyuB,EAAqBxa,EAAI,GAAKka,EAC9BM,EAAqBxa,EAAI,GAAKma,EAC9BK,EAAqBxa,EAAI,GAAKxT,EAAKjD,EACnCixB,EAAqBxa,EAAI,GAAKxT,EAAKzB,EACnCyvB,EAAqBxa,EAAI,IAAMxT,EAAKxB,EACpCwvB,EAAqBxa,EAAI,IAAMxT,EAAKvB,EAEpCuvB,EAAqBxa,EAAI,IAAM6J,EAC/B2Q,EAAqBxa,EAAI,IAAM8J,EAC/B0Q,EAAqBxa,EAAI,IAAMzT,EAAMhD,EACrCixB,EAAqBxa,EAAI,IAAMzT,EAAMxB,EACrCyvB,EAAqBxa,EAAI,IAAMzT,EAAMvB,EACrCwvB,EAAqBxa,EAAI,IAAMzT,EAAMtB,EACrCuvB,EAAqBxa,EAAI,IAAMoa,EAC/BI,EAAqBxa,EAAI,IAAMqa,EAC/BG,EAAqBxa,EAAI,IAAMxT,EAAKjD,EACpCixB,EAAqBxa,EAAI,IAAMxT,EAAKzB,EACpCyvB,EAAqBxa,EAAI,IAAMxT,EAAKxB,EACpCwvB,EAAqBxa,EAAI,IAAMxT,EAAKvB,EAEpCuvB,EAAqBxa,EAAI,IAAMgY,EAC/BwC,EAAqBxa,EAAI,IAAMiY,EAC/BuC,EAAqBxa,EAAI,IAAMzT,EAAMhD,EACrCixB,EAAqBxa,EAAI,IAAMzT,EAAMxB,EACrCyvB,EAAqBxa,EAAI,IAAMzT,EAAMvB,EACrCwvB,EAAqBxa,EAAI,IAAMzT,EAAMtB,EACrCuvB,EAAqBxa,EAAI,IAAMsa,EAC/BE,EAAqBxa,EAAI,IAAMua,EAC/BC,EAAqBxa,EAAI,IAAMxT,EAAKjD,EACpCixB,EAAqBxa,EAAI,IAAMxT,EAAKzB,EACpCyvB,EAAqBxa,EAAI,IAAMxT,EAAKxB,EACpCwvB,EAAqBxa,EAAI,IAAMxT,EAAKvB,IApDpCuvB,EAAqBxa,EAAI,GAAKka,EAC9BM,EAAqBxa,EAAI,GAAKma,EAE9BK,EAAqBxa,EAAI,GAAK6J,EAC9B2Q,EAAqBxa,EAAI,GAAK8J,EAC9B0Q,EAAqBxa,EAAI,IAAMzT,EAAMhD,EACrCixB,EAAqBxa,EAAI,IAAMzT,EAAMxB,EACrCyvB,EAAqBxa,EAAI,IAAMzT,EAAMvB,EACrCwvB,EAAqBxa,EAAI,IAAMzT,EAAMtB,EACrCuvB,EAAqBxa,EAAI,IAAMoa,EAC/BI,EAAqBxa,EAAI,IAAMqa,EAE/BG,EAAqBxa,EAAI,IAAMgY,EAC/BwC,EAAqBxa,EAAI,IAAMiY,EAC/BuC,EAAqBxa,EAAI,IAAMzT,EAAMhD,EACrCixB,EAAqBxa,EAAI,IAAMzT,EAAMxB,EACrCyvB,EAAqBxa,EAAI,IAAMzT,EAAMvB,EACrCwvB,EAAqBxa,EAAI,IAAMzT,EAAMtB,EACrCuvB,EAAqBxa,EAAI,IAAMsa,EAC/BE,EAAqBxa,EAAI,IAAMua,GAoChCva,EAAIiZ,EAAiB70B,QACjBq2B,EAAwB,EAAA50B,MAAMmI,aAAairB,EAAkBjZ,EAAI,IAC/CA,GAAKxZ,EAC3Bi0B,EAAsBza,EAAI,GAAMxZ,EAAQ,EACxCi0B,EAAsBza,EAAI,GAAMxZ,EAAQ,EACxCA,GAAS,EACT,SAAS0S,EAhHT,IAAIwhB,EAAmB3B,EAAW30B,OAClC,GAAwB,GAApBs2B,EAAJ,CAOA,IANA,IAAIC,EAAK7Q,EAAKmO,EAAI2C,EAAK5C,EAAKnO,EAAIgR,EAAKlR,EAAKqO,EAAI8C,EAAK7C,EAAKrO,EACpD3K,EAAI,GAAK0b,EAAKE,EAAKD,GAAMhR,EAAKqO,IAE9B8C,EAAkBL,GAAoB,EACtCM,EAAkB/2B,KAAK80B,WACvByB,EAAuB,EAAA30B,MAAMmI,aAAagrB,EAAiBhZ,EAAI+a,EAAkBf,GAC5EllB,EAAK,EAAGA,EAAK4lB,EAAkB5lB,GAAM,EAAG,CAChD,IAAItN,EAAIwzB,EAAgBlmB,GAAKrN,EAAIuzB,EAAgBlmB,EAAK,GACtD0lB,EAAqBxa,GAAKxY,EAC1BgzB,EAAqBxa,EAAI,GAAKvY,EAC9B+yB,EAAqBxa,EAAI,GAAKzT,EAAMhD,EACpCixB,EAAqBxa,EAAI,GAAKzT,EAAMxB,EACpCyvB,EAAqBxa,EAAI,GAAKzT,EAAMvB,EACpCwvB,EAAqBxa,EAAI,GAAKzT,EAAMtB,EACpC,IAAIgwB,EAAKzzB,EAAIwwB,EAAItS,EAAKje,EAAIwwB,EACtBhtB,GAAK0vB,EAAKM,EAAKL,EAAKlV,GAAMzG,EAC1BjU,GAAK8vB,EAAKG,EAAKJ,EAAKnV,GAAMzG,EAC1BF,EAAI,EAAI9T,EAAID,EAChBwvB,EAAqBxa,EAAI,GAAKka,EAAKjvB,EAAImvB,EAAKpvB,EAAIsvB,EAAKvb,EACrDyb,EAAqBxa,EAAI,GAAKma,EAAKlvB,EAAIovB,EAAKrvB,EAAIuvB,EAAKxb,EACjDhT,IACHyuB,EAAqBxa,EAAI,GAAKxT,EAAKjD,EACnCixB,EAAqBxa,EAAI,GAAKxT,EAAKzB,EACnCyvB,EAAqBxa,EAAI,IAAMxT,EAAKxB,EACpCwvB,EAAqBxa,EAAI,IAAMxT,EAAKvB,GAErC+U,GAAKga,EAGNha,EAAIiZ,EAAiB70B,OACrB,IAAIq2B,EAAwB,EAAA50B,MAAMmI,aAAairB,EAAkBjZ,EAAI,GAAK+a,EAAkB,IAC5FA,IACA,IAASjmB,EAAK,EAAGA,EAAKimB,EAAiBjmB,IACtC2lB,EAAsBza,GAAKxZ,EAC3Bi0B,EAAsBza,EAAI,GAAMxZ,EAAQsO,EACxC2lB,EAAsBza,EAAI,GAAMxZ,EAAQsO,EAAK,EAC7CkL,GAAK,EAENxZ,GAASu0B,EAAkB,KAgF/B,YAAA5H,KAAA,SAAMxJ,EAAYC,EAAYC,EAAYC,EAAYkO,EAAYC,EAAYiD,EAA6BC,GAC1G,IAAIC,EAAiBD,EACjBE,GAAU,EAGV5M,EAAuB,KACvByM,EAAa92B,OAAS,GAAK,GAC9BqqB,EAAQ0M,EACRA,EAASl3B,KAAKi1B,SAEdzK,EAAQxqB,KAAKi1B,QAEdzK,EAAMrqB,OAAS,EACfqqB,EAAM9f,KAAKgb,GACX8E,EAAM9f,KAAKib,GACX6E,EAAM9f,KAAKkb,GACX4E,EAAM9f,KAAKmb,GACX2E,EAAM9f,KAAKqpB,GACXvJ,EAAM9f,KAAKspB,GACXxJ,EAAM9f,KAAKgb,GACX8E,EAAM9f,KAAKib,GACXuR,EAAO/2B,OAAS,EAIhB,IAFA,IAAIk3B,EAAmBJ,EACnBK,EAAuBL,EAAa92B,OAAS,EACxCD,EAAI,GAAIA,GAAK,EAAG,CAOxB,IANA,IAAIq3B,EAAQF,EAAiBn3B,GAAIs3B,EAAQH,EAAiBn3B,EAAI,GAC1Du3B,EAASJ,EAAiBn3B,EAAI,GAAIw3B,EAASL,EAAiBn3B,EAAI,GAChEy3B,EAASJ,EAAQE,EAAQG,EAASJ,EAAQE,EAE1CG,EAAgBrN,EAChBsN,EAAsBtN,EAAMrqB,OAAS,EAAG43B,EAAcb,EAAO/2B,OACxD0Q,EAAK,EAAGA,EAAKinB,EAAqBjnB,GAAM,EAAG,CACnD,IAAImnB,EAASH,EAAchnB,GAAKonB,EAASJ,EAAchnB,EAAK,GACxDqnB,EAAUL,EAAchnB,EAAK,GAAIsnB,EAAUN,EAAchnB,EAAK,GAC9DunB,EAAQT,GAAUQ,EAAUT,GAAUE,GAAUM,EAAUT,GAAU,EACxE,GAAIE,GAAUM,EAASP,GAAUE,GAAUI,EAASP,GAAU,EAAG,CAChE,GAAIW,EAAO,CACVlB,EAAOxsB,KAAKwtB,GACZhB,EAAOxsB,KAAKytB,GACZ,SAGD,IACIE,IADuB3W,EAAKwW,EAAUF,IAC1BR,EAAQS,IADpBjB,EAAKmB,EAAUF,IACqBV,EAAQS,KAAYhB,GAAMS,EAASF,GAAS7V,GAAMgW,EAASF,IACnGN,EAAOxsB,KAAK6sB,GAASE,EAASF,GAASc,GACvCnB,EAAOxsB,KAAK8sB,GAASE,EAASF,GAASa,QACjC,GAAID,EAAO,CACjB,IAAIpB,EAAuBtV,EACvB2W,IADuB3W,EAAKwW,EAAUF,IAC1BR,EAAQS,IADpBjB,EAAKmB,EAAUF,IACqBV,EAAQS,KAAYhB,GAAMS,EAASF,GAAS7V,GAAMgW,EAASF,IACnGN,EAAOxsB,KAAK6sB,GAASE,EAASF,GAASc,GACvCnB,EAAOxsB,KAAK8sB,GAASE,EAASF,GAASa,GACvCnB,EAAOxsB,KAAKwtB,GACZhB,EAAOxsB,KAAKytB,GAEbf,GAAU,EAGX,GAAIW,GAAeb,EAAO/2B,OAEzB,OADAg3B,EAAeh3B,OAAS,GACjB,EAMR,GAHA+2B,EAAOxsB,KAAKwsB,EAAO,IACnBA,EAAOxsB,KAAKwsB,EAAO,IAEfh3B,GAAKo3B,EAAsB,MAC/B,IAAIrR,EAAOiR,GACXA,EAAS1M,GACFrqB,OAAS,EAChBqqB,EAAQvE,EAGT,GAAIkR,GAAkBD,EAAQ,CAC7BC,EAAeh3B,OAAS,EACfD,EAAI,EAAb,IAAK,IAAWa,EAAIm2B,EAAO/2B,OAAS,EAAGD,EAAIa,EAAGb,IAC7Ci3B,EAAej3B,GAAKg3B,EAAOh3B,QAE5Bi3B,EAAeh3B,OAASg3B,EAAeh3B,OAAS,EAEjD,OAAOi3B,GAGM,EAAA/B,cAAd,SAA6BvC,GAK5B,IAJA,IAAIvpB,EAAWupB,EACXwF,EAAiBxF,EAAQ3yB,OAEzBo4B,EAAOhvB,EAAS+uB,EAAiB,GAAK/uB,EAAS,GAAKA,EAAS,GAAKA,EAAS+uB,EAAiB,GAAIE,EAAM,EAAGC,EAAM,EAAGC,EAAM,EACnHx4B,EAAI,EAAGa,EAAIu3B,EAAiB,EAAGp4B,EAAIa,EAAGb,GAAK,EACnDs4B,EAAMjvB,EAASrJ,GACfu4B,EAAMlvB,EAASrJ,EAAI,GACnBw4B,EAAMnvB,EAASrJ,EAAI,GAEnBq4B,GAAQC,EADFjvB,EAASrJ,EAAI,GACCw4B,EAAMD,EAE3B,KAAIF,EAAO,GAEN,CAAIr4B,EAAI,EAAR,IAAWy4B,EAAQL,EAAiB,EAAzC,IAA4Cv3B,EAAIu3B,GAAkB,EAAGp4B,EAAIa,EAAGb,GAAK,EAAG,CACnF,IAAIqD,EAAIgG,EAASrJ,GAAIsD,EAAI+F,EAASrJ,EAAI,GAClC04B,EAAQD,EAAQz4B,EACpBqJ,EAASrJ,GAAKqJ,EAASqvB,GACvBrvB,EAASrJ,EAAI,GAAKqJ,EAASqvB,EAAQ,GACnCrvB,EAASqvB,GAASr1B,EAClBgG,EAASqvB,EAAQ,GAAKp1B,KAGzB,EA/SA,GAAa,EAAA4xB,iBAAgB,EADT,GAAA51B,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCCpB,SAAUA,IAAW,SAAAC,GACjB,8BAEI,KAAAgF,MAAQ,IAAIsE,MACZ,KAAAxB,MAAQ,IAAIwB,MACZ,KAAAwf,MAAQ,IAAIxf,MAEZ,KAAAnI,OAAS,IAAImI,MACb,KAAAwkB,WAAa,IAAIxkB,MACjB,KAAAgD,cAAgB,IAAIhD,MACpB,KAAAkE,qBAAuB,IAAIlE,MAC3B,KAAA4E,gBAAkB,IAAI5E,MAKtB,KAAAqiB,IAAM,EA2GV,OAvGI,YAAAlM,SAAA,SAAU2J,GACN,GAAgB,MAAZA,EAAkB,MAAM,IAAI7oB,MAAM,4BAEtC,IADA,IAAIyE,EAAQxE,KAAKwE,MACRtE,EAAI,EAAGa,EAAIyD,EAAMrE,OAAQD,EAAIa,EAAGb,IAAK,CAC1C,IAAIqE,EAAOC,EAAMtE,GACjB,GAAIqE,EAAK3E,MAAQgpB,EAAU,OAAOrkB,EAEtC,OAAO,MAGX,YAAAskB,cAAA,SAAeD,GACX,GAAgB,MAAZA,EAAkB,MAAM,IAAI7oB,MAAM,4BAEtC,IADA,IAAIyE,EAAQxE,KAAKwE,MACRtE,EAAI,EAAGa,EAAIyD,EAAMrE,OAAQD,EAAIa,EAAGb,IACrC,GAAIsE,EAAMtE,GAAGN,MAAQgpB,EAAU,OAAO1oB,EAC1C,OAAQ,GAGZ,YAAA0iB,SAAA,SAAUkG,GACN,GAAgB,MAAZA,EAAkB,MAAM,IAAI/oB,MAAM,4BAEtC,IADA,IAAIuH,EAAQtH,KAAKsH,MACRpH,EAAI,EAAGa,EAAIuG,EAAMnH,OAAQD,EAAIa,EAAGb,IAAK,CAC1C,IAAImH,EAAOC,EAAMpH,GACjB,GAAImH,EAAKzH,MAAQkpB,EAAU,OAAOzhB,EAEtC,OAAO,MAGX,YAAA0hB,cAAA,SAAeD,GACX,GAAgB,MAAZA,EAAkB,MAAM,IAAI/oB,MAAM,4BAEtC,IADA,IAAIuH,EAAQtH,KAAKsH,MACRpH,EAAI,EAAGa,EAAIuG,EAAMnH,OAAQD,EAAIa,EAAGb,IACrC,GAAIoH,EAAMpH,GAAGN,MAAQkpB,EAAU,OAAO5oB,EAC1C,OAAQ,GAGZ,YAAAgpB,SAAA,SAAUD,GACN,GAAgB,MAAZA,EAAkB,MAAM,IAAIlpB,MAAM,4BAEtC,IADA,IAAIuoB,EAAQtoB,KAAKsoB,MACRpoB,EAAI,EAAGa,EAAIunB,EAAMnoB,OAAQD,EAAIa,EAAGb,IAAK,CAC1C,IAAIlB,EAAOspB,EAAMpoB,GACjB,GAAIlB,EAAKY,MAAQqpB,EAAU,OAAOjqB,EAEtC,OAAO,MAGX,YAAA65B,UAAA,SAAWC,GACP,GAAqB,MAAjBA,EAAuB,MAAM,IAAI/4B,MAAM,iCAE3C,IADA,IAAIY,EAASX,KAAKW,OACTT,EAAI,EAAGa,EAAIJ,EAAOR,OAAQD,EAAIa,EAAGb,IAAK,CAC3C,IAAI,EAAQS,EAAOT,GACnB,GAAI,EAAMN,MAAQk5B,EAAe,OAAO,EAE5C,OAAO,MAGX,YAAA/kB,cAAA,SAAeF,GACX,GAAqB,MAAjBA,EAAuB,MAAM,IAAI9T,MAAM,iCAE3C,IADA,IAAIutB,EAAattB,KAAKstB,WACbptB,EAAI,EAAGa,EAAIusB,EAAWntB,OAAQD,EAAIa,EAAGb,IAAK,CAC/C,IAAIpB,EAAYwuB,EAAWptB,GAC3B,GAAIpB,EAAUc,MAAQiU,EAAe,OAAO/U,EAEhD,OAAO,MAGX,YAAAyqB,iBAAA,SAAkBC,GACd,GAAsB,MAAlBA,EAAwB,MAAM,IAAIzpB,MAAM,kCAE5C,IADA,IAAI+L,EAAgB9L,KAAK8L,cAChB5L,EAAI,EAAGa,EAAI+K,EAAc3L,OAAQD,EAAIa,EAAGb,IAAK,CAClD,IAAI2L,EAAaC,EAAc5L,GAC/B,GAAI2L,EAAWjM,MAAQ4pB,EAAgB,OAAO3d,EAElD,OAAO,MAGX,YAAA4d,wBAAA,SAAyBD,GACrB,GAAsB,MAAlBA,EAAwB,MAAM,IAAIzpB,MAAM,kCAE5C,IADA,IAAIiN,EAAuBhN,KAAKgN,qBACvB9M,EAAI,EAAGa,EAAIiM,EAAqB7M,OAAQD,EAAIa,EAAGb,IAAK,CACzD,IAAI2L,EAAamB,EAAqB9M,GACtC,GAAI2L,EAAWjM,MAAQ4pB,EAAgB,OAAO3d,EAElD,OAAO,MAGX,YAAA6d,mBAAA,SAAoBF,GAChB,GAAsB,MAAlBA,EAAwB,MAAM,IAAIzpB,MAAM,kCAE5C,IADA,IAAI2N,EAAkB1N,KAAK0N,gBAClBxN,EAAI,EAAGa,EAAI2M,EAAgBvN,OAAQD,EAAIa,EAAGb,IAAK,CACpD,IAAI2L,EAAa6B,EAAgBxN,GACjC,GAAI2L,EAAWjM,MAAQ4pB,EAAgB,OAAO3d,EAElD,OAAO,MAGX,YAAAktB,wBAAA,SAAyBC,GACrB,GAA0B,MAAtBA,EAA4B,MAAM,IAAIj5B,MAAM,sCAEhD,IADA,IAAI2N,EAAkB1N,KAAK0N,gBAClBxN,EAAI,EAAGa,EAAI2M,EAAgBvN,OAAQD,EAAIa,EAAGb,IAC/C,GAAIwN,EAAgBxN,GAAGN,MAAQo5B,EAAoB,OAAO94B,EAC9D,OAAQ,GAEhB,EA1HA,GAAa,EAAAqqB,aAAY,EADR,GAAA/qB,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GAKN,EAAAy5B,2BAA4B,EAEvC,iBAKI,WAAa9O,GAHb,KAAAtkB,MAAQ,EACA,KAAAukB,aAAe,IAAIthB,MAGvB9I,KAAKmqB,iBAAmBA,EAwyBhC,OAryBI,YAAAE,iBAAA,SAAkB6O,GACd,IAAIrzB,EAAQ7F,KAAK6F,MACbiO,EAAe,IAAI,EAAAyW,aACnB4O,EAAwB,kBAAVD,EAAqBE,KAAKC,MAAMH,GAAQA,EAGtDI,EAAcH,EAAK34B,SACvB,GAAmB,MAAf84B,EAAqB,CAGrB,GAFAxlB,EAAa4W,KAAO4O,EAAY5O,KAChC5W,EAAa8W,QAAU0O,EAAY56B,MACO,QAAtCoV,EAAa8W,QAAQ2O,OAAO,EAAG,GAAc,CAC7C,IAAI1O,EAAQ,kFAAkFyO,EAAY56B,MAAK,oEAC/GmX,QAAQgV,MAAMA,GAElB,GAA6B,WAAzB/W,EAAa8W,QACjB,CACQC,EAAQ,gGACZhV,QAAQgV,MAAMA,GAElB/W,EAAavQ,EAAI+1B,EAAY/1B,EAC7BuQ,EAAatQ,EAAI81B,EAAY91B,EAC7BsQ,EAAaiX,MAAQuO,EAAYvO,MACjCjX,EAAakX,OAASsO,EAAYtO,OAClClX,EAAaqX,IAAMmO,EAAYnO,IAC/BrX,EAAasX,WAAakO,EAAYE,OAI1C,GAAIL,EAAK30B,MACL,IAAK,IAAItE,EAAI,EAAGA,EAAIi5B,EAAK30B,MAAMrE,OAAQD,IAAK,CACxC,IAAIu5B,EAAUN,EAAK30B,MAAMtE,GAErB,EAAmB,KACnBw5B,EAAqB15B,KAAK25B,SAASF,EAAS,SAAU,MAC1D,GAAkB,MAAdC,GAEc,OADd,EAAS5lB,EAAamL,SAASya,IACX,MAAM,IAAI35B,MAAM,0BAA4B25B,IAEhE90B,EAAO,IAAI,EAAAga,SAAS9K,EAAatP,MAAMrE,OAAQs5B,EAAQ75B,KAAM,IAC5DO,OAASH,KAAK25B,SAASF,EAAS,SAAU,GAAK5zB,EACpDjB,EAAKrB,EAAIvD,KAAK25B,SAASF,EAAS,IAAK,GAAK5zB,EAC1CjB,EAAKpB,EAAIxD,KAAK25B,SAASF,EAAS,IAAK,GAAK5zB,EAC1CjB,EAAKD,SAAW3E,KAAK25B,SAASF,EAAS,WAAY,GACnD70B,EAAKkB,OAAS9F,KAAK25B,SAASF,EAAS,SAAU,GAC/C70B,EAAKmB,OAAS/F,KAAK25B,SAASF,EAAS,SAAU,GAC/C70B,EAAK4B,OAASxG,KAAK25B,SAASF,EAAS,SAAU,GAC/C70B,EAAK6B,OAASzG,KAAK25B,SAASF,EAAS,SAAU,GAC/C70B,EAAKyW,cAAgBue,EAAaC,wBAAwB75B,KAAK25B,SAASF,EAAS,YAAa,WAC9F70B,EAAK8Z,aAAe1e,KAAK25B,SAASF,EAAS,QAAQ,GAEnD3lB,EAAatP,MAAMkG,KAAK9F,GAKhC,GAAIu0B,EAAK7xB,MACL,IAASpH,EAAI,EAAGA,EAAIi5B,EAAK7xB,MAAMnH,OAAQD,IAAK,CACxC,IACI4oB,GADAgR,EAAUX,EAAK7xB,MAAMpH,IACMN,KAC3BgpB,EAAmBkR,EAAQv1B,KAC3BuiB,EAAWhT,EAAamL,SAAS2J,GACrC,GAAgB,MAAZ9B,EAAkB,MAAM,IAAI/mB,MAAM,wBAA0B6oB,GAChE,IAAIhkB,EAAO,IAAI,EAAAgnB,SAAS9X,EAAaxM,MAAMnH,OAAQ2oB,EAAUhC,GAEzDlgB,EAAgB5G,KAAK25B,SAASG,EAAS,QAAS,MACvC,MAATlzB,GAAehC,EAAKgC,MAAMmzB,cAAcnzB,GAE5C,IAAI2B,EAAevI,KAAK25B,SAASG,EAAS,OAAQ,MACtC,MAARvxB,IACA3D,EAAKyD,UAAY,IAAI,EAAAsW,MAAM,EAAG,EAAG,EAAG,GACpC/Z,EAAKyD,UAAU0xB,cAAcxxB,IAGjC3D,EAAKoE,eAAiBhJ,KAAK25B,SAASG,EAAS,aAAc,MAC3Dl1B,EAAKmnB,UAAY6N,EAAaI,oBAAoBh6B,KAAK25B,SAASG,EAAS,QAAS,WAClFhmB,EAAaxM,MAAMoD,KAAK9F,GAKhC,GAAIu0B,EAAKc,GACL,IAAS/5B,EAAI,EAAGA,EAAIi5B,EAAKc,GAAG95B,OAAQD,IAAK,CACrC,IAAIg6B,EAAgBf,EAAKc,GAAG/5B,IACxB0E,EAAO,IAAI,EAAA2d,iBAAiB2X,EAAct6B,OACzCif,MAAQ7e,KAAK25B,SAASO,EAAe,QAAS,GACnDt1B,EAAK8Z,aAAe1e,KAAK25B,SAASO,EAAe,QAAQ,GAEzD,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAc11B,MAAMrE,OAAQg6B,IAAK,CAC7CvR,EAAWsR,EAAc11B,MAAM21B,GAEnC,GAAY,OADR51B,EAAOuP,EAAamL,SAAS2J,IACf,MAAM,IAAI7oB,MAAM,sBAAwB6oB,GAC1DhkB,EAAKJ,MAAMkG,KAAKnG,GAGpB,IAAI61B,EAAqBF,EAAch5B,OAEvC,GADA0D,EAAK1D,OAAS4S,EAAamL,SAASmb,GACjB,MAAfx1B,EAAK1D,OAAgB,MAAM,IAAInB,MAAM,6BAA+Bq6B,GAExEx1B,EAAKuG,IAAMnL,KAAK25B,SAASO,EAAe,MAAO,GAC/Ct1B,EAAKwG,SAAWpL,KAAK25B,SAASO,EAAe,WAAY,GAAKr0B,EAC9DjB,EAAKyG,cAAgBrL,KAAK25B,SAASO,EAAe,gBAAgB,GAAQ,GAAK,EAC/Et1B,EAAK0G,SAAWtL,KAAK25B,SAASO,EAAe,YAAY,GACzDt1B,EAAK2G,QAAUvL,KAAK25B,SAASO,EAAe,WAAW,GACvDt1B,EAAKya,QAAUrf,KAAK25B,SAASO,EAAe,WAAW,GAEvDpmB,EAAahI,cAAcpB,KAAK9F,GAKxC,GAAIu0B,EAAKkB,UACL,IAASn6B,EAAI,EAAGA,EAAIi5B,EAAKkB,UAAUl6B,OAAQD,IAAK,CACxCg6B,EAAgBf,EAAKkB,UAAUn6B,IAC/B0E,EAAO,IAAI,EAAAsnB,wBAAwBgO,EAAct6B,OAChDif,MAAQ7e,KAAK25B,SAASO,EAAe,QAAS,GACnDt1B,EAAK8Z,aAAe1e,KAAK25B,SAASO,EAAe,QAAQ,GAEzD,IAASC,EAAI,EAAGA,EAAID,EAAc11B,MAAMrE,OAAQg6B,IAAK,CAC7CvR,EAAWsR,EAAc11B,MAAM21B,GAEnC,GAAY,OADR51B,EAAOuP,EAAamL,SAAS2J,IACf,MAAM,IAAI7oB,MAAM,wCAA0C6oB,GAC5EhkB,EAAKJ,MAAMkG,KAAKnG,GAGhB61B,EAAqBF,EAAch5B,OAEvC,GADA0D,EAAK1D,OAAS4S,EAAamL,SAASmb,GACjB,MAAfx1B,EAAK1D,OAAgB,MAAM,IAAInB,MAAM,+CAAiDq6B,GAE1Fx1B,EAAKuZ,MAAQne,KAAK25B,SAASO,EAAe,SAAS,GACnDt1B,EAAKunB,SAAWnsB,KAAK25B,SAASO,EAAe,YAAY,GACzDt1B,EAAKqf,eAAiBjkB,KAAK25B,SAASO,EAAe,WAAY,GAC/Dt1B,EAAKwnB,QAAUpsB,KAAK25B,SAASO,EAAe,IAAK,GAAKr0B,EACtDjB,EAAKynB,QAAUrsB,KAAK25B,SAASO,EAAe,IAAK,GAAKr0B,EACtDjB,EAAK0nB,aAAetsB,KAAK25B,SAASO,EAAe,SAAU,GAC3Dt1B,EAAK2nB,aAAevsB,KAAK25B,SAASO,EAAe,SAAU,GAC3Dt1B,EAAK4nB,aAAexsB,KAAK25B,SAASO,EAAe,SAAU,GAE3Dt1B,EAAK4H,UAAYxM,KAAK25B,SAASO,EAAe,YAAa,GAC3Dt1B,EAAK6H,aAAezM,KAAK25B,SAASO,EAAe,eAAgB,GACjEt1B,EAAK8H,SAAW1M,KAAK25B,SAASO,EAAe,WAAY,GACzDt1B,EAAK+H,SAAW3M,KAAK25B,SAASO,EAAe,WAAY,GAEzDpmB,EAAa9G,qBAAqBtC,KAAK9F,GAK/C,GAAIu0B,EAAKhhB,KACL,IAASjY,EAAI,EAAGA,EAAIi5B,EAAKhhB,KAAKhY,OAAQD,IAAK,CACnCg6B,EAAgBf,EAAKhhB,KAAKjY,IAC1B0E,EAAO,IAAI,EAAA+hB,mBAAmBuT,EAAct6B,OAC3Cif,MAAQ7e,KAAK25B,SAASO,EAAe,QAAS,GACnDt1B,EAAK8Z,aAAe1e,KAAK25B,SAASO,EAAe,QAAQ,GAEzD,IAASC,EAAI,EAAGA,EAAID,EAAc11B,MAAMrE,OAAQg6B,IAAK,CAC7CvR,EAAWsR,EAAc11B,MAAM21B,GAEnC,GAAY,OADR51B,EAAOuP,EAAamL,SAAS2J,IACf,MAAM,IAAI7oB,MAAM,wCAA0C6oB,GAC5EhkB,EAAKJ,MAAMkG,KAAKnG,GAGhB61B,EAAqBF,EAAch5B,OAEvC,GADA0D,EAAK1D,OAAS4S,EAAa8O,SAASwX,GACjB,MAAfx1B,EAAK1D,OAAgB,MAAM,IAAInB,MAAM,+BAAiCq6B,GAE1Ex1B,EAAKgf,aAAegW,EAAaU,uBAAuBt6B,KAAK25B,SAASO,EAAe,eAAgB,YACrGt1B,EAAKie,YAAc+W,EAAaW,sBAAsBv6B,KAAK25B,SAASO,EAAe,cAAe,WAClGt1B,EAAKqe,WAAa2W,EAAaY,qBAAqBx6B,KAAK25B,SAASO,EAAe,aAAc,YAC/Ft1B,EAAKqf,eAAiBjkB,KAAK25B,SAASO,EAAe,WAAY,GAC/Dt1B,EAAK+I,SAAW3N,KAAK25B,SAASO,EAAe,WAAY,GACrDt1B,EAAKgf,cAAgB,EAAAC,aAAa+I,QAAOhoB,EAAK+I,UAAY9H,GAC9DjB,EAAKkJ,QAAU9N,KAAK25B,SAASO,EAAe,UAAW,GACnDt1B,EAAKie,aAAe,EAAAE,YAAYC,QAAUpe,EAAKie,aAAe,EAAAE,YAAY6J,QAAOhoB,EAAKkJ,SAAWjI,GACrGjB,EAAK4H,UAAYxM,KAAK25B,SAASO,EAAe,YAAa,GAC3Dt1B,EAAK6H,aAAezM,KAAK25B,SAASO,EAAe,eAAgB,GAEjEpmB,EAAapG,gBAAgBhD,KAAK9F,GAK1C,GAAIu0B,EAAK7Q,MACL,IAASpoB,EAAI,EAAGA,EAAIi5B,EAAK7Q,MAAMnoB,OAAQD,IAAK,CACxC,IAAIu6B,EAAUtB,EAAK7Q,MAAMpoB,GACrBlB,EAAO,IAAI,EAAAyuB,KAAKgN,EAAQ76B,MAE5B,GAAI66B,EAAQj2B,MACR,IAAK,IAAIqM,EAAK,EAAGA,EAAK4pB,EAAQj2B,MAAMrE,OAAQ0Q,IAAM,CAC9C,IAAItM,EACJ,GAAY,OADRA,EAAOuP,EAAamL,SAASwb,EAAQj2B,MAAMqM,KAC7B,MAAM,IAAI9Q,MAAM,wBAA0B06B,EAAQj2B,MAAMtE,IAC1ElB,EAAKwF,MAAMkG,KAAKnG,GAIxB,GAAIk2B,EAAQR,GACR,IAASppB,EAAK,EAAGA,EAAK4pB,EAAQR,GAAG95B,OAAQ0Q,IAAM,CAE3C,GAAkB,OADdhF,EAAaiI,EAAayV,iBAAiBkR,EAAQR,GAAGppB,KAClC,MAAM,IAAI9Q,MAAM,iCAAmC06B,EAAQR,GAAG/5B,IACtFlB,EAAKgpB,YAAYtd,KAAKmB,GAI9B,GAAI4uB,EAAQJ,UACR,IAASxpB,EAAK,EAAGA,EAAK4pB,EAAQJ,UAAUl6B,OAAQ0Q,IAAM,CAElD,GAAkB,OADdhF,EAAaiI,EAAa2V,wBAAwBgR,EAAQJ,UAAUxpB,KAChD,MAAM,IAAI9Q,MAAM,wCAA0C06B,EAAQJ,UAAUn6B,IACpGlB,EAAKgpB,YAAYtd,KAAKmB,GAI9B,GAAI4uB,EAAQtiB,KACR,IAAStH,EAAK,EAAGA,EAAK4pB,EAAQtiB,KAAKhY,OAAQ0Q,IAAM,CAC7C,IAAIhF,EACJ,GAAkB,OADdA,EAAaiI,EAAa4V,mBAAmB+Q,EAAQtiB,KAAKtH,KACtC,MAAM,IAAI9Q,MAAM,mCAAqC06B,EAAQtiB,KAAKjY,IAC1FlB,EAAKgpB,YAAYtd,KAAKmB,GAI9B,IAAK,IAAIid,KAAY2R,EAAQ5oB,YAAa,CACtC,IAAIxK,EAAOyM,EAAa8O,SAASkG,GACjC,GAAY,MAARzhB,EAAc,MAAM,IAAItH,MAAM,mBAAqB+oB,GACvD,IAAIgR,EAAUW,EAAQ5oB,YAAYiX,GAClC,IAAK,IAAI4R,KAAaZ,EAAS,CAC3B,IAAI/wB,EAAa/I,KAAK0tB,eAAeoM,EAAQY,GAAY17B,EAAMqI,EAAK9E,MAAOm4B,EAAW5mB,GACpE,MAAd/K,GAAoB/J,EAAKiK,cAAc5B,EAAK9E,MAAOm4B,EAAW3xB,IAG1E+K,EAAawU,MAAM5d,KAAK1L,GACP,WAAbA,EAAKY,OAAmBkU,EAAauU,YAAcrpB,GAKtDkB,EAAI,EAAb,IAAK,IAAWa,EAAIf,KAAKoqB,aAAajqB,OAAQD,EAAIa,EAAGb,IAAK,CACtD,IAAI4sB,EAAa9sB,KAAKoqB,aAAalqB,GAEnC,GAAY,OADRlB,EAA0B,MAAnB8tB,EAAW9tB,KAAe8U,EAAauU,YAAcvU,EAAaoV,SAAS4D,EAAW9tB,OAC/E,MAAM,IAAIe,MAAM,mBAAqB+sB,EAAW9tB,MAClE,IAAI,EAASA,EAAKkK,cAAc4jB,EAAWjmB,UAAWimB,EAAW3T,QACjE,GAAc,MAAV,EAAgB,MAAM,IAAIpZ,MAAM,0BAA4B+sB,EAAW3T,QAC3E2T,EAAW9C,KAAKrgB,iBAAmBmjB,EAAWC,cAAkC,EAA2BD,EAAW9C,KACtH8C,EAAW9C,KAAKgD,cAA+B,GAMnD,GAHAhtB,KAAKoqB,aAAajqB,OAAS,EAGvBg5B,EAAKx4B,OACL,IAAK,IAAIg6B,KAAaxB,EAAKx4B,OAAQ,CAC/B,IAAIi6B,EAAWzB,EAAKx4B,OAAOg6B,IACvB/1B,EAAO,IAAI,EAAAoa,UAAU2b,IACpB1N,SAAWjtB,KAAK25B,SAASiB,EAAU,MAAO,GAC/Ch2B,EAAKsoB,WAAaltB,KAAK25B,SAASiB,EAAU,QAAS,GACnDh2B,EAAKuoB,YAAcntB,KAAK25B,SAASiB,EAAU,SAAU,IACrDh2B,EAAKymB,UAAYrrB,KAAK25B,SAASiB,EAAU,QAAS,MAC5B,MAAlBh2B,EAAKymB,YACLzmB,EAAKwoB,OAASptB,KAAK25B,SAASiB,EAAU,SAAU,GAChDh2B,EAAKyoB,QAAUrtB,KAAK25B,SAASiB,EAAU,UAAW,IAEtD9mB,EAAanT,OAAO+J,KAAK9F,GAKjC,GAAIu0B,EAAK7L,WACL,IAAK,IAAIzZ,KAAiBslB,EAAK7L,WAAY,CACvC,IAAIuN,EAAe1B,EAAK7L,WAAWzZ,GACnC7T,KAAKutB,cAAcsN,EAAchnB,EAAeC,GAIxD,OAAOA,GAGX,YAAA4Z,eAAA,SAAgBoN,EAAU97B,EAAY6H,EAAmBjH,EAAckU,GACnE,IAAIjO,EAAQ7F,KAAK6F,MAKjB,OAJAjG,EAAOI,KAAK25B,SAASmB,EAAK,OAAQl7B,GAEvBI,KAAK25B,SAASmB,EAAK,OAAQ,WAGlC,IAAK,SACD,IAAI3iB,EAAOnY,KAAK25B,SAASmB,EAAK,OAAQl7B,GAClCwY,EAASpY,KAAKmqB,iBAAiBjS,oBAAoBlZ,EAAMY,EAAMuY,GACnE,OAAc,MAAVC,EAAuB,MAC3BA,EAAOD,KAAOA,EACdC,EAAO7U,EAAIvD,KAAK25B,SAASmB,EAAK,IAAK,GAAKj1B,EACxCuS,EAAO5U,EAAIxD,KAAK25B,SAASmB,EAAK,IAAK,GAAKj1B,EACxCuS,EAAOtS,OAAS9F,KAAK25B,SAASmB,EAAK,SAAU,GAC7C1iB,EAAOrS,OAAS/F,KAAK25B,SAASmB,EAAK,SAAU,GAC7C1iB,EAAOzT,SAAW3E,KAAK25B,SAASmB,EAAK,WAAY,GACjD1iB,EAAO2S,MAAQ+P,EAAI/P,MAAQllB,EAC3BuS,EAAO4S,OAAS8P,EAAI9P,OAASnlB,EAGhB,OADTe,EAAgB5G,KAAK25B,SAASmB,EAAK,QAAS,QAC7B1iB,EAAOxR,MAAMmzB,cAAcnzB,GAGvCwR,GAEX,IAAK,cACD,IAAI6V,EAAMjuB,KAAKmqB,iBAAiB1R,yBAAyBzZ,EAAMY,GAC/D,OAAW,MAAPquB,EAAoB,MACxBjuB,KAAKguB,aAAa8M,EAAK7M,EAAK6M,EAAIjxB,aAAe,GAElC,OADTjD,EAAgB5G,KAAK25B,SAASmB,EAAK,QAAS,QAC7B7M,EAAIrnB,MAAMmzB,cAAcnzB,GACpCqnB,GAEX,IAAK,OACL,IAAK,aACG9V,EAAOnY,KAAK25B,SAASmB,EAAK,OAAQl7B,GAAtC,IACIoqB,EAAOhqB,KAAKmqB,iBAAiB5R,kBAAkBvZ,EAAMY,EAAMuY,GAC/D,GAAY,MAAR6R,EAAc,OAAO,KACzBA,EAAK7R,KAAOA,EAGC,OADTvR,EAAQ5G,KAAK25B,SAASmB,EAAK,QAAS,QACrB9Q,EAAKpjB,MAAMmzB,cAAcnzB,GAE5CojB,EAAKe,MAAQ/qB,KAAK25B,SAASmB,EAAK,QAAS,GAAKj1B,EAC9CmkB,EAAKgB,OAAShrB,KAAK25B,SAASmB,EAAK,SAAU,GAAKj1B,EAEhD,IAAI,EAAiB7F,KAAK25B,SAASmB,EAAK,SAAU,MAClD,GAAc,MAAV,EAEA,OADA96B,KAAKoqB,aAAa1f,KAAK,IAAIikB,EAAW3E,EAAehqB,KAAK25B,SAASmB,EAAK,OAAQ,MAAOj0B,EAAW,EAAQ7G,KAAK25B,SAASmB,EAAK,UAAU,KAChI9Q,EAGX,IAAImE,EAAqB2M,EAAI3M,IAQ7B,OAPAnuB,KAAKguB,aAAa8M,EAAK9Q,EAAMmE,EAAIhuB,QACjC6pB,EAAKqE,UAAYyM,EAAIzM,UACrBrE,EAAKyE,UAAY,IAAIC,aAAaP,GAGlCnE,EAAKwE,MAAQxuB,KAAK25B,SAASmB,EAAK,QAAS,MACzC9Q,EAAKuE,WAA6C,EAAhCvuB,KAAK25B,SAASmB,EAAK,OAAQ,GACtC9Q,EAEX,IAAK,OAED,GAAY,OADR7R,EAAOnY,KAAKmqB,iBAAiBxR,kBAAkB3Z,EAAMY,IACvC,OAAO,KACzBuY,EAAKsM,OAASzkB,KAAK25B,SAASmB,EAAK,UAAU,GAC3C3iB,EAAK4M,cAAgB/kB,KAAK25B,SAASmB,EAAK,iBAAiB,GAEzD,IAAIjxB,EAAcixB,EAAIjxB,YACtB7J,KAAKguB,aAAa8M,EAAK3iB,EAAMtO,GAAe,GAG5C,IADA,IAAI6Y,EAAyB,EAAA9gB,MAAMitB,SAAShlB,EAAc,EAAG,GACpD3J,EAAI,EAAGA,EAAI46B,EAAIpY,QAAQviB,OAAQD,IACpCwiB,EAAQxiB,GAAK46B,EAAIpY,QAAQxiB,GAAK2F,EAKlC,OAJAsS,EAAKuK,QAAUA,EAGF,OADT9b,EAAgB5G,KAAK25B,SAASmB,EAAK,QAAS,QAC7B3iB,EAAKvR,MAAMmzB,cAAcnzB,GACrCuR,EAEX,IAAK,QACD,IAAI4W,EAAQ/uB,KAAKmqB,iBAAiBtR,mBAAmB7Z,EAAMY,GAC3D,OAAa,MAATmvB,EAAsB,MAC1BA,EAAMxrB,EAAIvD,KAAK25B,SAASmB,EAAK,IAAK,GAAKj1B,EACvCkpB,EAAMvrB,EAAIxD,KAAK25B,SAASmB,EAAK,IAAK,GAAKj1B,EACvCkpB,EAAMpqB,SAAW3E,KAAK25B,SAASmB,EAAK,WAAY,GAGnC,OADTl0B,EAAQ5G,KAAK25B,SAASmB,EAAK,QAAS,QACrB/L,EAAMnoB,MAAMmzB,cAAcnzB,GACtCmoB,GAEX,IAAK,WACD,IAAIG,EAAOlvB,KAAKmqB,iBAAiBpR,sBAAsB/Z,EAAMY,GAC7D,GAAY,MAARsvB,EAAc,OAAO,KAEzB,IAAIvf,EAAM3P,KAAK25B,SAASmB,EAAK,MAAO,MACpC,GAAW,MAAPnrB,EAAa,CACb,IAAItI,EAAOyM,EAAa8O,SAASjT,GACjC,GAAY,MAARtI,EAAc,MAAM,IAAItH,MAAM,gCAAkC4P,GACpEuf,EAAKC,QAAU9nB,EAGnB,IAGIT,EAHAiD,EAAcixB,EAAIjxB,YAKtB,OAJA7J,KAAKguB,aAAa8M,EAAK5L,EAAMrlB,GAAe,GAG/B,OADTjD,EAAgB5G,KAAK25B,SAASmB,EAAK,QAAS,QAC7B5L,EAAKtoB,MAAMmzB,cAAcnzB,GACrCsoB,EAGf,OAAO,MAGX,YAAAlB,aAAA,SAAc8M,EAAU/xB,EAA8B2b,GAClD,IAAI7e,EAAQ7F,KAAK6F,MACjBkD,EAAW4b,oBAAsBD,EACjC,IAAInb,EAA0BuxB,EAAIvxB,SAClC,GAAImb,GAAkBnb,EAASpJ,OAA/B,CASA,IAAIkvB,EAAU,IAAIvmB,MACdtE,EAAQ,IAAIsE,MAChB,IAAS5I,EAAI,EAAGa,EAAIwI,EAASpJ,OAAQD,EAAIa,GAAI,CACzC,IAAIuiB,EAAY/Z,EAASrJ,KACzBsE,EAAMkG,KAAK4Y,GACX,IAAK,IAAI2G,EAAK/pB,EAAgB,EAAZojB,EAAepjB,EAAI+pB,EAAI/pB,GAAK,EAC1CsE,EAAMkG,KAAKnB,EAASrJ,IACpBmvB,EAAQ3kB,KAAKnB,EAASrJ,EAAI,GAAK2F,GAC/BwpB,EAAQ3kB,KAAKnB,EAASrJ,EAAI,GAAK2F,GAC/BwpB,EAAQ3kB,KAAKnB,EAASrJ,EAAI,IAGlC6I,EAAWvE,MAAQA,EACnBuE,EAAWQ,SAAW,EAAA3H,MAAM2tB,aAAaF,OAtBzC,CACI,IAAI0L,EAAiB,EAAAn5B,MAAM2tB,aAAahmB,GACxC,GAAa,GAAT1D,EACA,IAAK,IAAI3F,EAAI,EAAGa,EAAIwI,EAASpJ,OAAQD,EAAIa,EAAGb,IACxC66B,EAAe76B,IAAM2F,EAE7BkD,EAAWQ,SAAWwxB,IAmB9B,YAAAxN,cAAA,SAAeuN,EAAUl7B,EAAckU,GACnC,IAAIjO,EAAQ7F,KAAK6F,MACbhG,EAAY,IAAIiJ,MAChBhJ,EAAW,EAGf,GAAIg7B,EAAIxzB,MACJ,IAAK,IAAIwhB,KAAYgS,EAAIxzB,MAAO,CAC5B,IAAIwyB,EAAUgB,EAAIxzB,MAAMwhB,GAExB,IAAkB,IADdjiB,EAAYiN,EAAaiV,cAAcD,IACtB,MAAM,IAAI/oB,MAAM,mBAAqB+oB,GAC1D,IAAK,IAAIkS,KAAgBlB,EAAS,CAC9B,IAAImB,EAAcnB,EAAQkB,GAC1B,GAAoB,cAAhBA,EAA8B,EAC1BjqB,EAAW,IAAI,EAAA5H,mBAAmB8xB,EAAY96B,SACzC0G,UAAYA,EAGrB,IADA,IAAI3E,EAAa,EACRhC,EAAI,EAAGA,EAAI+6B,EAAY96B,OAAQD,IAAK,CACzC,IAAIg7B,EAAWD,EAAY/6B,GAC3B6Q,EAAS5M,SAASjC,IAAclC,KAAK25B,SAASuB,EAAU,OAAQ,GAAIA,EAASt7B,MAEjFC,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,OAAO+M,EAAS/O,gBAAkB,SACtE,GAAoB,SAAhBg5B,EAAyB,EAC5BjqB,EAAW,IAAI,EAAApK,cAAcs0B,EAAY96B,SACpC0G,UAAYA,EAGrB,IADI3E,EAAa,EACRhC,EAAI,EAAGA,EAAI+6B,EAAY96B,OAAQD,IAAK,CACrCg7B,EAAWD,EAAY/6B,GAA3B,IACI0G,EAAQ,IAAI,EAAA+X,MAChB/X,EAAMmzB,cAAcmB,EAASt0B,OAAS,YACtCmK,EAAS5M,SAASjC,EAAYlC,KAAK25B,SAASuB,EAAU,OAAQ,GAAIt0B,EAAMtB,EAAGsB,EAAME,EAAGF,EAAMG,EAAGH,EAAMI,GACnGhH,KAAK+vB,UAAUmL,EAAUnqB,EAAU7O,GACnCA,IAEJrC,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,QAAQ+M,EAAS/O,gBAAkB,GAAK,EAAA2E,cAAc7B,cAE1F,IAAoB,YAAhBk2B,EAmBP,MAAM,IAAIj7B,MAAM,qCAAuCi7B,EAAe,KAAOlS,EAAW,MAlBpF/X,EAAW,IAAI,EAAAlJ,iBAAiBozB,EAAY96B,SACvC0G,UAAYA,EAGrB,IADI3E,EAAa,EACRhC,EAAI,EAAGA,EAAI+6B,EAAY96B,OAAQD,IAAK,CACrCg7B,EAAWD,EAAY/6B,GAA3B,IACIoI,EAAQ,IAAI,EAAAqW,MACZpW,EAAO,IAAI,EAAAoW,MACfrW,EAAMyxB,cAAcmB,EAAS5yB,OAC7BC,EAAKwxB,cAAcmB,EAAS3yB,MAC5BwI,EAAS5M,SAASjC,EAAYlC,KAAK25B,SAASuB,EAAU,OAAQ,GAAI5yB,EAAMhD,EAAGgD,EAAMxB,EAAGwB,EAAMvB,EAAGuB,EAAMtB,EAAGuB,EAAKjD,EAAGiD,EAAKzB,EAAGyB,EAAKxB,GAC3H/G,KAAK+vB,UAAUmL,EAAUnqB,EAAU7O,GACnCA,IAEJrC,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,QAAQ+M,EAAS/O,gBAAkB,GAAK,EAAA6F,iBAAiB/C,YAShH,GAAIg2B,EAAIt2B,MACJ,IAAK,IAAIokB,KAAYkS,EAAIt2B,MAAO,CAC5B,IAAIi1B,EAAUqB,EAAIt2B,MAAMokB,GACpB1kB,EAAY4P,EAAa+U,cAAcD,GAC3C,IAAkB,GAAd1kB,EAAiB,MAAM,IAAInE,MAAM,mBAAqB6oB,GAC1D,IAAK,IAAIoS,KAAgBvB,EAAS,CAC1BwB,EAAcxB,EAAQuB,GAC1B,GAAqB,WAAjBA,EAA2B,EACvBjqB,EAAW,IAAI,EAAA1M,eAAe42B,EAAY96B,SACrC+D,UAAYA,EAGrB,IADIhC,EAAa,EACRhC,EAAI,EAAGA,EAAI+6B,EAAY96B,OAAQD,IAAK,CACrCg7B,EAAWD,EAAY/6B,GAC3B6Q,EAAS5M,SAASjC,EAAYlC,KAAK25B,SAASuB,EAAU,OAAQ,GAAIl7B,KAAK25B,SAASuB,EAAU,QAAS,IACnGl7B,KAAK+vB,UAAUmL,EAAUnqB,EAAU7O,GACnCA,IAEJrC,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,QAAQ+M,EAAS/O,gBAAkB,GAAK,EAAAqC,eAAeS,cAE3F,IAAqB,cAAjBk2B,GAAiD,UAAjBA,GAA6C,UAAjBA,EA0BnE,MAAM,IAAIj7B,MAAM,qCAAuCi7B,EAAe,KAAOpS,EAAW,KAzBxF,IAAI7X,EAA8B,KAC9Bsf,EAAgB,EAAG8K,EAAe,EACjB,UAAjBH,GACAjqB,EAAW,IAAI,EAAA/K,cAAci1B,EAAY96B,QACzCg7B,EAAe,GACS,UAAjBH,EACPjqB,EAAW,IAAI,EAAArK,cAAcu0B,EAAY96B,SAEzC4Q,EAAW,IAAI,EAAAxL,kBAAkB01B,EAAY96B,QAC7CkwB,EAAgBxqB,GAEpBkL,EAAS7M,UAAYA,EAGrB,IADIhC,EAAa,EACRhC,EAAI,EAAGA,EAAI+6B,EAAY96B,OAAQD,IAAK,CACrCg7B,EAAWD,EAAY/6B,GAA3B,IACIqD,EAAIvD,KAAK25B,SAASuB,EAAU,IAAKC,GAAe33B,EAAIxD,KAAK25B,SAASuB,EAAU,IAAKC,GACrFpqB,EAAS5M,SAASjC,EAAYlC,KAAK25B,SAASuB,EAAU,OAAQ,GAAI33B,EAAI8sB,EAAe7sB,EAAI6sB,GACzFrwB,KAAK+vB,UAAUmL,EAAUnqB,EAAU7O,GACnCA,IAEJrC,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,QAAQ+M,EAAS/O,gBAAkB,GAAK,EAAAuD,kBAAkBT,YASjH,GAAIg2B,EAAIb,GACJ,IAAK,IAAIzQ,KAAkBsR,EAAIb,GAAI,CAC/B,IAAIC,EAAgBY,EAAIb,GAAGzQ,GACvB3d,EAAaiI,EAAayV,iBAAiBC,IAC3CzY,EAAW,IAAI,EAAA/F,qBAAqBkvB,EAAc/5B,SAC7C+K,kBAAoB4I,EAAahI,cAAcyJ,QAAQ1J,GAEhE,IADI3J,EAAa,EACRhC,EAAI,EAAGA,EAAIg6B,EAAc/5B,OAAQD,IAAK,CACvCg7B,EAAWhB,EAAch6B,GAC7B6Q,EAAS5M,SAASjC,EAAYlC,KAAK25B,SAASuB,EAAU,OAAQ,GAAIl7B,KAAK25B,SAASuB,EAAU,MAAO,GAAIl7B,KAAK25B,SAASuB,EAAU,WAAY,GAAKr1B,EAC1I7F,KAAK25B,SAASuB,EAAU,gBAAgB,GAAQ,GAAK,EAAGl7B,KAAK25B,SAASuB,EAAU,YAAY,GAAQl7B,KAAK25B,SAASuB,EAAU,WAAW,IAC3Il7B,KAAK+vB,UAAUmL,EAAUnqB,EAAU7O,GACnCA,IAEJrC,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,QAAQ+M,EAAS/O,gBAAkB,GAAK,EAAAgJ,qBAAqBlG,UAK5G,GAAIg2B,EAAIT,UACJ,IAAK,IAAI7Q,KAAkBsR,EAAIT,UAAW,CAClCH,EAAgBY,EAAIT,UAAU7Q,GAC9B3d,EAAaiI,EAAa2V,wBAAwBD,IAClDzY,EAAW,IAAI,EAAA1E,4BAA4B6tB,EAAc/5B,SACpDoM,yBAA2BuH,EAAa9G,qBAAqBuI,QAAQ1J,GAE9E,IADI3J,EAAa,EACRhC,EAAI,EAAGA,EAAIg6B,EAAc/5B,OAAQD,IAAK,CACvCg7B,EAAWhB,EAAch6B,GAC7B6Q,EAAS5M,SAASjC,EAAYlC,KAAK25B,SAASuB,EAAU,OAAQ,GAAIl7B,KAAK25B,SAASuB,EAAU,YAAa,GACnGl7B,KAAK25B,SAASuB,EAAU,eAAgB,GAAIl7B,KAAK25B,SAASuB,EAAU,WAAY,GAAIl7B,KAAK25B,SAASuB,EAAU,WAAY,IAC5Hl7B,KAAK+vB,UAAUmL,EAAUnqB,EAAU7O,GACnCA,IAEJrC,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAChBiR,EAAS/M,QAAQ+M,EAAS/O,gBAAkB,GAAK,EAAAqK,4BAA4BvH,UAKzF,GAAIg2B,EAAI3iB,KACJ,IAAK,IAAIqR,KAAkBsR,EAAI3iB,KAAM,CAC7B+hB,EAAgBY,EAAI3iB,KAAKqR,GAA7B,IACIjnB,EAAQuR,EAAailB,wBAAwBvP,GACjD,IAAc,GAAVjnB,EAAa,MAAM,IAAIxC,MAAM,8BAAgCypB,GACjE,IAAI5kB,EAAOkP,EAAapG,gBAAgBnL,GACxC,IAAK,IAAIy4B,KAAgBd,EAAe,CAChCe,EAAcf,EAAcc,GAChC,GAAqB,aAAjBA,GAAgD,YAAjBA,EAA4B,CACvDjqB,EAA2C,KAC3Csf,EAAgB,EACC,YAAjB2K,GACAjqB,EAAW,IAAI,EAAAhD,8BAA8BktB,EAAY96B,QACrDyE,EAAKie,aAAe,EAAAE,YAAYC,QAAUpe,EAAKie,aAAe,EAAAE,YAAY6J,QAAOyD,EAAgBxqB,KAErGkL,EAAW,IAAI,EAAA1D,+BAA+B4tB,EAAY96B,QACtDyE,EAAKgf,cAAgB,EAAAC,aAAa+I,QAAOyD,EAAgBxqB,IAEjEkL,EAASxD,oBAAsBhL,EAE/B,IADIL,EAAa,EACRhC,EAAI,EAAGA,EAAI+6B,EAAY96B,OAAQD,IAAK,CACrCg7B,EAAWD,EAAY/6B,GAC3B6Q,EAAS5M,SAASjC,EAAYlC,KAAK25B,SAASuB,EAAU,OAAQ,GAAIl7B,KAAK25B,SAASuB,EAAUF,EAAc,GAAK3K,GAC7GrwB,KAAK+vB,UAAUmL,EAAUnqB,EAAU7O,GACnCA,IAEJrC,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAChBiR,EAAS/M,QAAQ+M,EAAS/O,gBAAkB,GAAK,EAAAqL,+BAA+BvI,eACjF,GAAqB,QAAjBk2B,EAAwB,EAC3BjqB,EAAW,IAAI,EAAA/C,0BAA0BitB,EAAY96B,SAChDoN,oBAAsBhL,EAE/B,IADIL,EAAa,EACRhC,EAAI,EAAGA,EAAI+6B,EAAY96B,OAAQD,IAAK,CACrCg7B,EAAWD,EAAY/6B,GAC3B6Q,EAAS5M,SAASjC,EAAYlC,KAAK25B,SAASuB,EAAU,OAAQ,GAAIl7B,KAAK25B,SAASuB,EAAU,YAAa,GACnGl7B,KAAK25B,SAASuB,EAAU,eAAgB,IAC5Cl7B,KAAK+vB,UAAUmL,EAAUnqB,EAAU7O,GACnCA,IAEJrC,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAChBiR,EAAS/M,QAAQ+M,EAAS/O,gBAAkB,GAAK,EAAAgM,0BAA0BlJ,YAO/F,GAAIg2B,EAAIxxB,OACJ,IAAK,IAAI8xB,KAAcN,EAAIxxB,OAAQ,CAC/B,IAAI+xB,EAAYP,EAAIxxB,OAAO8xB,GACvBp8B,EAAO8U,EAAaoV,SAASkS,GACjC,GAAY,MAARp8B,EAOJ,IAAK,IAAI8pB,KAAYuS,EAAW,CACxBvB,EAAUuB,EAAUvS,GAExB,IAAkB,IADdjiB,EAAYiN,EAAaiV,cAAcD,IACtB,MAAM,IAAI/oB,MAAM,mBAAqB+5B,EAAQl6B,MAClE,IAAK,IAAIo7B,KAAgBlB,EAAS,CAC1BmB,EAAcnB,EAAQkB,GAA1B,IACIjyB,EAA+B/J,EAAKkK,cAAcrC,EAAWm0B,GACjE,GAAkB,MAAdjyB,EAAoB,MAAM,IAAIhJ,MAAM,gCAAkCk7B,EAAYr7B,MACtF,IAAI+wB,EAA+B,MAApB5nB,EAAWvE,MACtB+E,EAAWR,EAAWQ,SACtBqnB,EAAeD,EAAWpnB,EAASpJ,OAAS,EAAI,EAAIoJ,EAASpJ,QAE7D4Q,EAAW,IAAI,EAAAzG,eAAe2wB,EAAY96B,SACrC0G,UAAYA,EACrBkK,EAAShI,WAAaA,EAElB7G,EAAa,EACjB,IADA,IACSi4B,EAAI,EAAGA,EAAIc,EAAY96B,OAAQg6B,IAAK,CACrCe,EAAWD,EAAYd,GAA3B,IACI7wB,OAAM,EACNgyB,EAA+Bt7B,KAAK25B,SAASuB,EAAU,WAAY,MACvE,GAAqB,MAAjBI,EACAhyB,EAASqnB,EAAW,EAAA/uB,MAAMC,cAAc+uB,GAAgBrnB,MACvD,CACDD,EAAS,EAAA1H,MAAMC,cAAc+uB,GAC7B,IAAI/sB,EAAgB7D,KAAK25B,SAASuB,EAAU,SAAU,GAEtD,GADA,EAAAt5B,MAAMsI,UAAUoxB,EAAe,EAAGhyB,EAAQzF,EAAOy3B,EAAcn7B,QAClD,GAAT0F,EACA,IAAK,IAAe9E,GAAXb,EAAI2D,GAAey3B,EAAcn7B,OAAQD,EAAIa,EAAGb,IACrDoJ,EAAOpJ,IAAM2F,EAErB,IAAK8qB,EACD,IAASzwB,EAAI,EAAGA,EAAI0wB,EAAc1wB,IAC9BoJ,EAAOpJ,IAAMqJ,EAASrJ,GAIlC6Q,EAAS5M,SAASjC,EAAYlC,KAAK25B,SAASuB,EAAU,OAAQ,GAAI5xB,GAClEtJ,KAAK+vB,UAAUmL,EAAUnqB,EAAU7O,GACnCA,IAEJrC,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,OAAO+M,EAAS/O,gBAAkB,UAhD9E,GAAI,EAAAi3B,0BACA,MAAM,IAAIl5B,MAAM,mBAAqBq7B,GAsDpD,IAAIG,EAAgBT,EAAIjwB,UAExB,GADqB,MAAjB0wB,IAAuBA,EAAgBT,EAAIU,WAC1B,MAAjBD,EAAuB,CACnBxqB,EAAW,IAAI,EAAAhG,kBAAkBwwB,EAAcp7B,QAAnD,IACIqtB,EAAY1Z,EAAaxM,MAAMnH,OAEnC,IADI+B,EAAa,EACRi4B,EAAI,EAAGA,EAAIoB,EAAcp7B,OAAQg6B,IAAK,CAC3C,IAAIsB,EAAeF,EAAcpB,GAC7BtvB,EAA2B,KAC3B6wB,EAAU17B,KAAK25B,SAAS8B,EAAc,UAAW,MACrD,GAAe,MAAXC,EAAiB,CACjB7wB,EAAY,EAAAjJ,MAAMitB,SAAiBrB,GAAY,GAC/C,IAAIyD,EAAY,EAAArvB,MAAMitB,SAAiBrB,EAAYkO,EAAQv7B,OAAQ,GAC/D+wB,EAAgB,EAAGC,EAAiB,EACxC,IAASjxB,EAAI,EAAGA,EAAIw7B,EAAQv7B,OAAQD,IAAK,CACrC,IACI2G,EADA80B,EAAYD,EAAQx7B,GAExB,IAAkB,IADd2G,EAAYiN,EAAaiV,cAAc4S,EAAUt0B,OAChC,MAAM,IAAItH,MAAM,mBAAqB47B,EAAUt0B,MAEpE,KAAO6pB,GAAiBrqB,GACpBoqB,EAAUE,KAAoBD,IAElCrmB,EAAUqmB,EAAgByK,EAAU/R,QAAUsH,IAGlD,KAAOA,EAAgB1D,GACnByD,EAAUE,KAAoBD,IAElC,IAAShxB,EAAIstB,EAAY,EAAGttB,GAAK,EAAGA,KACX,GAAjB2K,EAAU3K,KAAU2K,EAAU3K,GAAK+wB,IAAYE,IAE3DpgB,EAAS5M,SAASjC,IAAclC,KAAK25B,SAAS8B,EAAc,OAAQ,GAAI5wB,GAE5EhL,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,OAAO+M,EAAS/O,gBAAkB,IAI7E,GAAI84B,EAAIn6B,OAAQ,CAGZ,IAFIoQ,EAAW,IAAI,EAAApG,cAAcmwB,EAAIn6B,OAAOR,QACxC+B,EAAa,EACRhC,EAAI,EAAGA,EAAI46B,EAAIn6B,OAAOR,OAAQD,IAAK,CACxC,IAAI06B,EAAWE,EAAIn6B,OAAOT,GACtBmxB,EAAYvd,EAAa+kB,UAAU+B,EAASh7B,MAChD,GAAiB,MAAbyxB,EAAmB,MAAM,IAAItxB,MAAM,oBAAsB66B,EAASh7B,MACtE,IAAI,GAAQ,IAAI,EAAAmf,MAAM,EAAAnd,MAAMg6B,kBAAkB57B,KAAK25B,SAASiB,EAAU,OAAQ,IAAKvJ,GACnF,GAAMpE,SAAWjtB,KAAK25B,SAASiB,EAAU,MAAOvJ,EAAUpE,UAC1D,GAAMC,WAAaltB,KAAK25B,SAASiB,EAAU,QAASvJ,EAAUnE,YAC9D,GAAMC,YAAcntB,KAAK25B,SAASiB,EAAU,SAAUvJ,EAAUlE,aACpC,MAAxB,GAAMvoB,KAAKymB,YACX,GAAM+B,OAASptB,KAAK25B,SAASiB,EAAU,SAAU,GACjD,GAAMvN,QAAUrtB,KAAK25B,SAASiB,EAAU,UAAW,IAEvD7pB,EAAS5M,SAASjC,IAAc,IAEpCrC,EAAU6K,KAAKqG,GACfjR,EAAWsG,KAAKmM,IAAIzS,EAAUiR,EAAS/M,OAAO+M,EAAS/O,gBAAkB,IAG7E,GAAIkkB,MAAMpmB,GACN,MAAM,IAAIC,MAAM,kDAGpB+T,EAAawZ,WAAW5iB,KAAK,IAAI,EAAAjJ,UAAU7B,EAAMC,EAAWC,KAGhE,YAAAiwB,UAAA,SAAW+K,EAAU/pB,EAAyB7O,GAC1C,GAAK44B,EAAIe,eAAe,SACxB,GAAkB,YAAdf,EAAI7V,MACJlU,EAAS3O,WAAWF,OACnB,CACD,IAAI+iB,EAAgB6V,EAAI7V,MACxBlU,EAASrO,SAASR,EAAY+iB,EAAOjlB,KAAK25B,SAASmB,EAAK,KAAM,GAAI96B,KAAK25B,SAASmB,EAAK,KAAM,GAAI96B,KAAK25B,SAASmB,EAAK,KAAM,MAIhI,YAAAnB,SAAA,SAAUmB,EAAUgB,EAAcX,GAC9B,YAAqBnjB,IAAd8iB,EAAIgB,GAAsBhB,EAAIgB,GAAQX,GAG1C,EAAAnB,oBAAP,SAA4B+B,GAExB,GAAW,WADXA,EAAMA,EAAIC,eACW,OAAO,EAAA9iB,UAAUqC,OACtC,GAAW,YAAPwgB,EAAmB,OAAO,EAAA7iB,UAAUsY,SACxC,GAAW,YAAPuK,EAAmB,OAAO,EAAA7iB,UAAUuY,SACxC,GAAW,UAAPsK,EAAiB,OAAO,EAAA7iB,UAAUwY,OACtC,MAAM,IAAI3xB,MAAM,uBAAuBg8B,IAGpC,EAAAzB,uBAAP,SAA+ByB,GAE3B,GAAW,UADXA,EAAMA,EAAIC,eACU,OAAO,EAAAnY,aAAa+I,MACxC,GAAW,WAAPmP,EAAkB,OAAO,EAAAlY,aAAaC,QAC1C,MAAM,IAAI/jB,MAAM,0BAA0Bg8B,IAGvC,EAAAxB,sBAAP,SAA8BwB,GAE1B,GAAW,WADXA,EAAMA,EAAIC,eACW,OAAO,EAAAjZ,YAAYC,OACxC,GAAW,SAAP+Y,EAAgB,OAAO,EAAAhZ,YAAY6J,MACvC,GAAW,WAAPmP,EAAkB,OAAO,EAAAhZ,YAAYe,QACzC,MAAM,IAAI/jB,MAAM,0BAA0Bg8B,IAGvC,EAAAvB,qBAAP,SAA6BuB,GAEzB,GAAW,YADXA,EAAMA,EAAIC,eACY,OAAO,EAAA7Y,WAAWC,QACxC,GAAW,SAAP2Y,EAAgB,OAAO,EAAA5Y,WAAWgB,MACtC,GAAW,cAAP4X,EAAqB,OAAO,EAAA5Y,WAAWE,WAC3C,MAAM,IAAItjB,MAAM,wBAAwBg8B,IAGrC,EAAAlC,wBAAP,SAA+BkC,GAE3B,GAAW,WADXA,EAAMA,EAAIC,eACW,OAAO,EAAA1gB,cAAcC,OAC1C,GAAW,mBAAPwgB,EAA0B,OAAO,EAAAzgB,cAAcM,gBACnD,GAAW,0BAAPmgB,EAAiC,OAAO,EAAAzgB,cAAcO,uBAC1D,GAAW,WAAPkgB,EAAkB,OAAO,EAAAzgB,cAAcc,QAC3C,GAAW,uBAAP2f,EAA8B,OAAO,EAAAzgB,cAAce,oBACvD,MAAM,IAAItc,MAAM,2BAA2Bg8B,IAEnD,EA9yBA,GAAa,EAAAnC,aAAY,EAgzBzB,MAMI,SAAa5P,EAAsBhrB,EAAc6H,EAAmBsS,EAAgB4T,GAChF/sB,KAAKgqB,KAAOA,EACZhqB,KAAKhB,KAAOA,EACZgB,KAAK6G,UAAYA,EACjB7G,KAAKmZ,OAASA,EACdnZ,KAAK+sB,cAAgBA,GAl0BZ,GAAAvtB,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,MACI,SAAmBqH,EAA0BjH,EAAqBmJ,GAA/C,KAAAlC,YAA0B,KAAAjH,OAAqB,KAAAmJ,cADzD,EAAAkzB,UAAS,EAItB,iBAMI,WAAar8B,GACT,GALJ,KAAAiS,YAAc,IAAI/I,MAClB,KAAAtE,MAAQsE,QACR,KAAAkf,YAAc,IAAIlf,MAGF,MAARlJ,EAAc,MAAM,IAAIG,MAAM,wBAClCC,KAAKJ,KAAOA,EA+IpB,OA5II,YAAAqJ,cAAA,SAAepC,EAAmBjH,EAAcmJ,GAC5C,GAAkB,MAAdA,EAAoB,MAAM,IAAIhJ,MAAM,8BACxC,IAAI8R,EAAc7R,KAAK6R,YACnBhL,GAAagL,EAAY1R,SAAQ0R,EAAY1R,OAAS0G,EAAY,GACjEgL,EAAYhL,KAAYgL,EAAYhL,GAAa,IACtDgL,EAAYhL,GAAWjH,GAAQmJ,GAGnC,YAAAmzB,QAAA,SAASl9B,GACL,IAAI,IAAIkB,EAAI,EAAGA,EAAIlB,EAAKwF,MAAMrE,OAAQD,IAAK,CAGvC,IAFA,IAAIqE,EAAOvF,EAAKwF,MAAMtE,GAClBi8B,GAAY,EACPhC,EAAI,EAAGA,EAAIn6B,KAAKwE,MAAMrE,OAAQg6B,IACnC,GAAIn6B,KAAKwE,MAAM21B,IAAM51B,EAAM,CACvB43B,GAAY,EACZ,MAGHA,GAAWn8B,KAAKwE,MAAMkG,KAAKnG,GAGpC,IAAQrE,EAAI,EAAGA,EAAIlB,EAAKgpB,YAAY7nB,OAAQD,IAAK,CAC7C,IAAI2L,EAAa7M,EAAKgpB,YAAY9nB,GAElC,IADIi8B,GAAY,EACPhC,EAAI,EAAGA,EAAIn6B,KAAKgoB,YAAY7nB,OAAQg6B,IACzC,GAAIn6B,KAAKgoB,YAAYmS,IAAMtuB,EAAY,CACnCswB,GAAY,EACZ,MAGHA,GAAWn8B,KAAKgoB,YAAYtd,KAAKmB,GAG1C,IAAIgG,EAAc7S,EAAKo9B,iBACvB,IAASl8B,EAAI,EAAGA,EAAI2R,EAAY1R,OAAQD,IAAK,CACzC,IAAI6I,EAAa8I,EAAY3R,GAC7BF,KAAKiJ,cAAcF,EAAWlC,UAAWkC,EAAWnJ,KAAMmJ,EAAWA,cAI7E,YAAAszB,SAAA,SAAUr9B,GACN,IAAI,IAAIkB,EAAI,EAAGA,EAAIlB,EAAKwF,MAAMrE,OAAQD,IAAK,CAGvC,IAFA,IAAIqE,EAAOvF,EAAKwF,MAAMtE,GAClBi8B,GAAY,EACPhC,EAAI,EAAGA,EAAIn6B,KAAKwE,MAAMrE,OAAQg6B,IACnC,GAAIn6B,KAAKwE,MAAM21B,IAAM51B,EAAM,CACvB43B,GAAY,EACZ,MAGHA,GAAWn8B,KAAKwE,MAAMkG,KAAKnG,GAGpC,IAAQrE,EAAI,EAAGA,EAAIlB,EAAKgpB,YAAY7nB,OAAQD,IAAK,CAC7C,IAAI2L,EAAa7M,EAAKgpB,YAAY9nB,GAElC,IADIi8B,GAAY,EACPhC,EAAI,EAAGA,EAAIn6B,KAAKgoB,YAAY7nB,OAAQg6B,IACzC,GAAIn6B,KAAKgoB,YAAYmS,IAAMtuB,EAAY,CACnCswB,GAAY,EACZ,MAGHA,GAAWn8B,KAAKgoB,YAAYtd,KAAKmB,GAG1C,IAAIgG,EAAc7S,EAAKo9B,iBACvB,IAASl8B,EAAI,EAAGA,EAAI2R,EAAY1R,OAAQD,IAAK,CACzC,IAAI6I,EAAa8I,EAAY3R,GACA,MAAzB6I,EAAWA,aACXA,EAAWA,sBAAsB,EAAAyP,gBACjCzP,EAAWA,WAAaA,EAAWA,WAAWuzB,gBAC9Ct8B,KAAKiJ,cAAcF,EAAWlC,UAAWkC,EAAWnJ,KAAMmJ,EAAWA,cAErEA,EAAWA,WAAaA,EAAWA,WAAWwzB,OAC9Cv8B,KAAKiJ,cAAcF,EAAWlC,UAAWkC,EAAWnJ,KAAMmJ,EAAWA,gBAMjF,YAAAG,cAAA,SAAerC,EAAmBjH,GAC9B,IAAI48B,EAAax8B,KAAK6R,YAAYhL,GAClC,OAAO21B,EAAaA,EAAW58B,GAAQ,MAG3C,YAAA68B,iBAAA,SAAkB51B,EAAmBjH,GACjC,IAAI48B,EAAax8B,KAAK6R,YAAYhL,GAC9B21B,IAAYA,EAAW58B,GAAQ,OAGvC,YAAAw8B,eAAA,WAEI,IADA,IAAIM,EAAU,IAAI5zB,MACT5I,EAAI,EAAGA,EAAIF,KAAK6R,YAAY1R,OAAQD,IAAK,CAC9C,IAAIy8B,EAAkB38B,KAAK6R,YAAY3R,GACvC,GAAIy8B,EACA,IAAK,IAAI,KAAQA,EAAiB,CAC9B,IAAI5zB,EAAa4zB,EAAgB,GAC7B5zB,GAAY2zB,EAAQhyB,KAAK,IAAIuxB,EAAU/7B,EAAG,EAAM6I,KAIhE,OAAO2zB,GAGX,YAAAE,sBAAA,SAAuB/1B,EAAmBgL,GACtC,IAAI8qB,EAAkB38B,KAAK6R,YAAYhL,GACvC,GAAI81B,EACA,IAAK,IAAI,KAAQA,EAAiB,CAC9B,IAAI5zB,EAAa4zB,EAAgB,GAC7B5zB,GAAY8I,EAAYnH,KAAK,IAAIuxB,EAAUp1B,EAAW,EAAMkC,MAK5E,YAAA8L,MAAA,WACI7U,KAAK6R,YAAY1R,OAAS,EAC1BH,KAAKwE,MAAMrE,OAAS,EACpBH,KAAKgoB,YAAY7nB,OAAS,GAI9B,YAAAkpB,UAAA,SAAW7oB,EAAoBq8B,GAE3B,IADA,IAAIh2B,EAAY,EACP3G,EAAI,EAAGA,EAAIM,EAAS8G,MAAMnH,OAAQD,IAAK,CAC5C,IAAImH,EAAO7G,EAAS8G,MAAMpH,GACtBuJ,EAAiBpC,EAAK6B,gBAC1B,GAAIO,GAAkB5C,EAAYg2B,EAAQhrB,YAAY1R,OAAQ,CAC1D,IAAIq8B,EAAaK,EAAQhrB,YAAYhL,GACrC,IAAK,IAAIkR,KAAOykB,EAAY,CAExB,GAAI/yB,GAD4B+yB,EAAWzkB,GACL,CAClC,IAAIhP,EAAa/I,KAAKkJ,cAAcrC,EAAWkR,GAC7B,MAAdhP,GAAoB1B,EAAK4B,cAAcF,GAC3C,QAIZlC,MAGZ,EAvJA,GAAa,EAAA4mB,KAAI,EALA,GAAAjuB,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,iBA2BI,WAAaoF,EAAgBL,GACzB,GAHJ,KAAA+E,OAAS,IAAIR,MAGG,MAARlE,EAAc,MAAM,IAAI7E,MAAM,wBAClC,GAAY,MAARwE,EAAc,MAAM,IAAIxE,MAAM,wBAClCC,KAAK4E,KAAOA,EACZ5E,KAAKuE,KAAOA,EACZvE,KAAK4G,MAAQ,IAAI,EAAA+X,MACjB3e,KAAKqI,UAA8B,MAAlBzD,EAAKyD,UAAoB,KAAO,IAAI,EAAAsW,MACrD3e,KAAKia,iBAELja,KAAK+rB,UAAY/rB,KAAK4E,KAAKmnB,UAoCnC,OAhCI,YAAA7iB,cAAA,WACI,OAAOlJ,KAAK+I,YAKhB,YAAAE,cAAA,SAAeF,GACP/I,KAAK+I,YAAcA,IACvB/I,KAAK+I,WAAaA,EAClB/I,KAAK88B,eAAiB98B,KAAKuE,KAAK/D,SAASE,KACzCV,KAAKsJ,OAAOnJ,OAAS,IAGzB,YAAA48B,kBAAA,SAAmBr8B,GACfV,KAAK88B,eAAiB98B,KAAKuE,KAAK/D,SAASE,KAAOA,GAIpD,YAAAs8B,kBAAA,WACI,OAAOh9B,KAAKuE,KAAK/D,SAASE,KAAOV,KAAK88B,gBAG1C,YAAA7iB,eAAA,WACIja,KAAK4G,MAAMW,aAAavH,KAAK4E,KAAKgC,OACZ,MAAlB5G,KAAKqI,WAAmBrI,KAAKqI,UAAUd,aAAavH,KAAK4E,KAAKyD,WAClC,MAA5BrI,KAAK4E,KAAKoE,eACVhJ,KAAK+I,WAAa,MAElB/I,KAAK+I,WAAa,KAClB/I,KAAKiJ,cAAcjJ,KAAKuE,KAAK/D,SAAS0I,cAAclJ,KAAK4E,KAAKrC,MAAOvC,KAAK4E,KAAKoE,mBAG3F,EAxEA,GAAa,EAAAge,KAAI,EADA,GAAAxnB,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,MASI,SAAa+C,EAAe3C,EAAcknB,GACtC,GANJ,KAAAlgB,MAAQ,IAAI,EAAA+X,MAAM,EAAG,EAAG,EAAG,GAMnBpc,EAAQ,EAAG,MAAM,IAAIxC,MAAM,uBAC/B,GAAY,MAARH,EAAc,MAAM,IAAIG,MAAM,wBAClC,GAAgB,MAAZ+mB,EAAkB,MAAM,IAAI/mB,MAAM,4BACtCC,KAAKuC,MAAQA,EACbvC,KAAKJ,KAAOA,EACZI,KAAK8mB,SAAWA,GAfX,EAAA8E,SAAQ,EADJ,GAAApsB,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,IAuCYy9B,EAUAC,EAjDZ,aAGI,WAAaC,GACTn9B,KAAKo9B,OAASD,EAiCtB,OA9BI,YAAAE,SAAA,WACI,OAAOr9B,KAAKo9B,QAQF,EAAAE,iBAAd,SAAgCC,GAC5B,OAAQA,EAAKvB,eACT,IAAK,UAAW,OAAOiB,EAAcO,QACrC,IAAK,SAAU,OAAOP,EAAcQ,OACpC,IAAK,SAAU,OAAOR,EAAcS,OACpC,IAAK,uBAAwB,OAAOT,EAAcU,qBAClD,IAAK,sBAAuB,OAAOV,EAAcW,oBACjD,IAAK,sBAAuB,OAAOX,EAAcY,oBACjD,IAAK,qBAAsB,OAAOZ,EAAca,mBAChD,QAAS,MAAM,IAAI/9B,MAAM,0BAA0Bw9B,KAI7C,EAAAQ,eAAd,SAA8BR,GAC1B,OAAQA,EAAKvB,eACT,IAAK,iBAAkB,OAAOkB,EAAYc,eAC1C,IAAK,cAAe,OAAOd,EAAYe,YACvC,IAAK,SAAU,OAAOf,EAAYgB,OAClC,QAAS,MAAM,IAAIn+B,MAAM,wBAAwBw9B,KAG7D,EArCA,GAAsB,EAAAY,QAAO,EAuC7B,SAAYlB,GACR,4BACA,0BACA,0BACA,sDACA,oDACA,oDACA,kDAPJ,CAAYA,EAAA,EAAAA,gBAAA,EAAAA,cAAa,KAUzB,SAAYC,GACR,2CACA,qCACA,2BAHJ,CAAYA,EAAA,EAAAA,cAAA,EAAAA,YAAW,KAMvB,8BAII,KAAArT,KAAuB,KA6F3B,OA3FI,sBAAI,oBAAK,C,IAAT,WACI,IAAMuU,EAAMp+B,KAAKq+B,QACjB,MAAuB,KAAnBhlB,KAAKilB,QAAQ,GACLF,EAAYG,KAAKxT,MAEzBqT,EAAII,KACGJ,EAAII,KAAKzT,MAEbqT,EAAIK,KAAK1T,O,gCAGpB,sBAAI,qBAAM,C,IAAV,WACI,IAAMqT,EAAMp+B,KAAKq+B,QACjB,MAAuB,KAAnBhlB,KAAKilB,QAAQ,GACLF,EAAYG,KAAKvT,OAEzBoT,EAAII,KACGJ,EAAII,KAAKxT,OAEboT,EAAIK,KAAKzT,Q,gCAGpB,sBAAI,gBAAC,C,IAAL,WACI,OAAQhrB,KAAKq+B,QAAgBK,KAAKC,I,gCAGtC,sBAAI,gBAAC,C,IAAL,WACI,OAAQ3+B,KAAKq+B,QAAgBK,KAAKE,I,gCAGtC,sBAAI,iBAAE,C,IAAN,WACI,OAAQ5+B,KAAKq+B,QAAgBK,KAAK9Y,I,gCAGtC,sBAAI,iBAAE,C,IAAN,WACI,OAAQ5lB,KAAKq+B,QAAgBK,KAAK7Y,I,gCAGtC,sBAAI,sBAAO,C,IAAX,WACI,IAAMuY,EAAMp+B,KAAKq+B,QACjB,OAAOD,EAAII,KAAOJ,EAAII,KAAKj7B,EAAI,G,gCAGnC,sBAAI,sBAAO,C,IAAX,WAEI,OADAsS,QAAQC,KAAK,0JACN9V,KAAK6+B,c,gCAGhB,sBAAI,0BAAW,C,IAAf,WACI,IAAMT,EAAMp+B,KAAKq+B,QACjB,OAAOD,EAAII,KAAOJ,EAAII,KAAKh7B,EAAI,G,gCAGnC,sBAAI,2BAAY,C,IAAhB,WACI,IAAI46B,EAAMp+B,KAAKq+B,QACf,OAAOr+B,KAAK8+B,eAAiB9+B,KAAKgrB,QAAUoT,EAAII,KAAOJ,EAAII,KAAKh7B,EAAI,I,gCAGxE,sBAAI,4BAAa,C,IAAjB,WACI,IAAI46B,EAAMp+B,KAAKq+B,QACf,MAAuB,KAAnBhlB,KAAKilB,QAAQ,GACTF,EAAII,KACGJ,EAAII,KAAKzT,MAEZqT,EAAYG,KAAKxT,MAEtBqT,EAAIK,KAAK1T,O,gCAGpB,sBAAI,6BAAc,C,IAAlB,WACI,IAAMqT,EAAMp+B,KAAKq+B,QACjB,MAAuB,KAAnBhlB,KAAKilB,QAAQ,GACTF,EAAII,KACGJ,EAAII,KAAKxT,OAEZoT,EAAYG,KAAKvT,OAEtBoT,EAAIK,KAAKzT,Q,gCAGpB,sBAAI,gBAAC,C,IAAL,WACI,OAAOhrB,KAAKq+B,QAAQn5B,MAAM3B,G,gCAG9B,sBAAI,gBAAC,C,IAAL,WACI,OAAOvD,KAAKq+B,QAAQn5B,MAAM1B,G,gCAG9B,sBAAI,qBAAM,C,IAAV,WACI,OAA+B,IAAxBxD,KAAKq+B,QAAQp6B,Q,gCAE5B,EAjGA,GAAa,EAAA86B,cAAa,EAxDT,GAAAv/B,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,iBAII,WAAYw/B,EAAoBC,EAAuFC,GAHvH,KAAAC,MAAQ,IAAIr2B,MACZ,KAAAs2B,QAAU,IAAIt2B,MAGNk2B,GACAh/B,KAAKq/B,cAAcL,EAAWC,EAAeC,GA0MzD,OAtMI,YAAAI,WAAA,SAAW1/B,EAAcy+B,GAGrB,IAFA,IAAIc,EAAQn/B,KAAKm/B,MACbI,EAAyB,KACpBr/B,EAAI,EAAGA,EAAIi/B,EAAMh/B,OAAQD,IAC9B,GAAIi/B,EAAMj/B,GAAGs/B,cAAgBnB,EAAQmB,YAAa,CAC9CD,EAAOJ,EAAMj/B,GACb,MAGR,GAAa,OAATq/B,EAAe,EACfA,EAAO,IAAIE,GACN7/B,KAAO,cACZ,IAAI4/B,EAAcnB,EAAQmB,YAC1BD,EAAKxU,MAAQyU,EAAYE,UACzBH,EAAKvU,OAASwU,EAAYG,WAC1BJ,EAAKC,YAAcA,EAEnBD,EAAKK,UAAYL,EAAKM,UAAY,EAAA5C,cAAcO,QAChD+B,EAAKO,MAAQ,EAAA5C,YAAYe,YACzBsB,EAAKQ,MAAQ,EAAA7C,YAAYe,YACzBkB,EAAMz0B,KAAK60B,GAEf,IAAInnB,EAAS,IAAI4nB,EAMjB,OALA5nB,EAAOxY,KAAOA,EACdwY,EAAOmnB,KAAOA,EACdnnB,EAAOimB,QAAUA,EACjBjmB,EAAO7V,OAAS,EAChBvC,KAAKo/B,QAAQ10B,KAAK0N,GACXA,GAGX,YAAA6nB,eAAA,SAAeC,EAA6BC,GACxC,IAAK,IAAIpoB,KAAOmoB,EACRA,EAASrE,eAAe9jB,IACxB/X,KAAKs/B,WAAWa,IAAwC,IAAtBpoB,EAAIxC,QAAQ,KAAcwC,EAAIwhB,OAAO,EAAGxhB,EAAIqoB,YAAY,MAAQroB,EAAKmoB,EAASnoB,KAKrH,YAAAsnB,cAAP,SAAqBL,EAAmBC,EAAuFC,GAC3H,OAAOl/B,KAAKqgC,KAAKrB,EAAWC,EAAeC,IAGvC,YAAAmB,KAAR,SAAarB,EAAmBC,EAAsFC,GAAtH,WACI,GAAqB,MAAjBD,EACA,MAAM,IAAIl/B,MAAM,iCAEpB,IAAIugC,EAAS,IAAIC,EAAmBvB,GAChCwB,EAAQ,IAAI13B,MAAc,GAC1By2B,EAAyB,MAET,SAAhBkB,IACA,OAAa,CACT,IAAIC,EAAOJ,EAAOK,WAClB,GAAY,MAARD,EACA,OAAOxB,GAAYA,EAAS,GAGhC,GAAmB,IADnBwB,EAAOA,EAAKlC,QACHr+B,OACLo/B,EAAO,SACN,KAAKA,EAAM,EACZA,EAAO,IAAIE,GACN7/B,KAAO8gC,EAEmB,GAA3BJ,EAAOM,UAAUJ,KACjBjB,EAAKxU,MAAQ8V,SAASL,EAAM,IAC5BjB,EAAKvU,OAAS6V,SAASL,EAAM,IAC7BF,EAAOM,UAAUJ,IAIrBF,EAAOM,UAAUJ,GACjBjB,EAAKK,UAAY,EAAAzB,QAAQb,iBAAiBkD,EAAM,IAChDjB,EAAKM,UAAY,EAAA1B,QAAQb,iBAAiBkD,EAAM,IAEhD,IAAI1/B,EAAYw/B,EAAOQ,YACvBvB,EAAKO,MAAQ,EAAA5C,YAAYe,YACzBsB,EAAKQ,MAAQ,EAAA7C,YAAYe,YACR,KAAbn9B,EACAy+B,EAAKO,MAAQ,EAAA5C,YAAYgB,OACP,KAAbp9B,EACLy+B,EAAKQ,MAAQ,EAAA7C,YAAYgB,OACP,MAAbp9B,IACLy+B,EAAKO,MAAQP,EAAKQ,MAAQ,EAAA7C,YAAYgB,QAE1Ce,EAAcyB,GAAM,SAACrC,GACjB,GAAgB,OAAZA,EAEA,OADA,EAAKc,MAAM3pB,OAAO,EAAK2pB,MAAM5pB,QAAQgqB,GAAO,GACrCL,GAAYA,EAAS,MAEhCK,EAAKC,YAAcnB,EACdA,EAAQ0C,OACT1C,EAAQ2C,QAAQzB,EAAKxU,MAAOwU,EAAKvU,QAErC,EAAKmU,MAAMz0B,KAAK60B,GAChBA,EAAK0B,aAEA1B,EAAKxU,OAAUwU,EAAKvU,SACrBuU,EAAKxU,MAAQsT,EAAQqB,UACrBH,EAAKvU,OAASqT,EAAQsB,WACjBJ,EAAKxU,OAAUwU,EAAKvU,QACrBnV,QAAQqrB,IAAI,0BAA4B3B,EAAK3/B,KAAO,qIAG5D6gC,OAEJ,EAAKtB,MAAMz0B,KAAK60B,GAChB,MAEA,IAAInnB,EAA6B,IAAI4nB,EACrC5nB,EAAOxY,KAAO8gC,EACdtoB,EAAOmnB,KAAOA,EAEd,IAAI4B,EAAcb,EAAOQ,YACrB78B,EAAS,EAETA,EADmC,QAAnCk9B,EAAYC,oBACH,EACiC,SAAnCD,EAAYC,oBACV,GAEE,IAAMC,WAAWF,IAAe,IAAO,GAGtDb,EAAOM,UAAUJ,GACjB,IAAIj9B,EAAIs9B,SAASL,EAAM,IACnBh9B,EAAIq9B,SAASL,EAAM,IAEvBF,EAAOM,UAAUJ,GACjB,IAAIzV,EAAQ8V,SAASL,EAAM,IACvBxV,EAAS6V,SAASL,EAAM,IAExBc,EAAa/B,EAAKC,YAAY8B,WAClC/9B,GAAK+9B,EACL99B,GAAK89B,EACLvW,GAASuW,EACTtW,GAAUsW,EAEV,IAAMC,EAASt9B,EAAS,GAAK,EACzBiB,EAAQ,IAAImU,KAAKmoB,UAAUj+B,EAAGC,EAAG+9B,EAASvW,EAASD,EAAOwW,EAASxW,EAAQC,GAEhD,GAA3BsV,EAAOM,UAAUJ,IAGc,GAA3BF,EAAOM,UAAUJ,IAGjBF,EAAOM,UAAUJ,GAIzB,IAAIiB,EAAgBZ,SAASL,EAAM,IAAMc,EACrCxC,EAAiB+B,SAASL,EAAM,IAAMc,EAC1ChB,EAAOM,UAAUJ,GACjB,IAAIpU,EAAUyU,SAASL,EAAM,IAAMc,EAC/BjV,EAAUwU,SAASL,EAAM,IAAMc,EAE/B7C,EAAO,IAAIplB,KAAKmoB,UAAU,EAAG,EAAGC,EAAe3C,GAC/CN,EAAO,IAAInlB,KAAKmoB,UAAUpV,EAAS0S,EAAiB9T,EAASqB,EAAStB,EAAOC,GAIjF,GAAuB,KAAnB3R,KAAKilB,QAAQ,GAEblmB,EAAOimB,QAAU,IAAIhlB,KAAK8kB,QAAQ/lB,EAAOmnB,KAAKC,YAAat6B,EAAOu5B,EAAMD,EAAMv6B,OAC3E,CAEH,IAAIy9B,EAAS,IAAIroB,KAAKmoB,UAAUj+B,EAAGC,EAAGunB,EAAOC,GACzCuT,EAAOmD,EAAOC,QAClBnD,EAAKzT,MAAQ0W,EACbjD,EAAKxT,OAAS8T,EACd1mB,EAAOimB,QAAU,IAAIhlB,KAAK8kB,QAAQ/lB,EAAOmnB,KAAKC,YAAakC,EAAQnD,EAAMC,EAAMv6B,GAGnFmU,EAAO7V,MAAQs+B,SAASP,EAAOQ,aAC/B1oB,EAAOimB,QAAQuD,YAEf,EAAKxC,QAAQ10B,KAAK0N,KAK9BqoB,IAGJ,YAAApoB,WAAA,SAAWzY,GACP,IAAK,IAAIM,EAAI,EAAGA,EAAIF,KAAKo/B,QAAQj/B,OAAQD,IACrC,GAAIF,KAAKo/B,QAAQl/B,GAAGN,MAAQA,EACxB,OAAOI,KAAKo/B,QAAQl/B,GAG5B,OAAO,MAGX,YAAA0U,QAAA,WACI,IAAK,IAAI1U,EAAI,EAAGA,EAAIF,KAAKm/B,MAAMh/B,OAAQD,IACnCF,KAAKm/B,MAAMj/B,GAAGs/B,YAAY5qB,WAGtC,EAhNA,GAAa,EAAAitB,aAAY,EAkNzB,iBAII,WAAYtE,GAFZ,KAAAh7B,MAAgB,EAGZvC,KAAK8hC,MAAQvE,EAAKwE,MAAM,cAgChC,OA7BI,YAAApB,SAAA,WACI,OAAI3gC,KAAKuC,OAASvC,KAAK8hC,MAAM3hC,OAClB,KACJH,KAAK8hC,MAAM9hC,KAAKuC,UAG3B,YAAAu+B,UAAA,WACI,IAAIJ,EAAO1gC,KAAK2gC,WACZqB,EAAQtB,EAAKnrB,QAAQ,KACzB,IAAc,GAAVysB,EACA,MAAM,IAAIjiC,MAAM,iBAAmB2gC,GACvC,OAAOA,EAAKuB,UAAUD,EAAQ,GAAGxD,QAGrC,YAAAoC,UAAA,SAAUJ,GACN,IAAIE,EAAO1gC,KAAK2gC,WACZqB,EAAQtB,EAAKnrB,QAAQ,KACzB,IAAc,GAAVysB,EACA,MAAM,IAAIjiC,MAAM,iBAAmB2gC,GAEvC,IADA,IAAIxgC,EAAI,EAAGgiC,EAAYF,EAAQ,EACxB9hC,EAAI,EAAGA,IAAK,CACf,IAAIiiC,EAAQzB,EAAKnrB,QAAQ,IAAK2sB,GAC9B,IAAc,GAAVC,EAAa,MACjB3B,EAAMtgC,GAAKwgC,EAAKnH,OAAO2I,EAAWC,EAAQD,GAAW1D,OACrD0D,EAAYC,EAAQ,EAGxB,OADA3B,EAAMtgC,GAAKwgC,EAAKuB,UAAUC,GAAW1D,OAC9Bt+B,EAAI,GAEnB,EArCA,GAuCA,2BA0BA,OAhBW,YAAA+gC,WAAP,WACI,IAAI7C,EAAMp+B,KAAKw/B,YACX4C,EAASpiC,KAAK4/B,UACdwC,GAAU,EAAAnF,cAAcQ,OACxBW,EAAIiE,UAAYhpB,KAAKipB,YAAYngC,OAC1BnC,KAAK4/B,WAAa,EAAA3C,cAAcO,QACvCY,EAAIiE,UAAYhpB,KAAKipB,YAAYC,SAEjCnE,EAAIoE,OAASnpB,KAAKopB,aAAaC,KAC3BN,GAAU,EAAAnF,cAAcU,qBACxBS,EAAIiE,UAAYhpB,KAAKipB,YAAYC,QAEjCnE,EAAIiE,UAAYhpB,KAAKipB,YAAYngC,SAIjD,EA1BA,GAAa,EAAAs9B,iBAAgB,EA4B7B,+B,+CAIA,OAJwC,OAIxC,EAJA,CAAwC,EAAAV,eAA3B,EAAAiB,mBAAkB,EAtRd,GAAAxgC,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,iBAWI,WAAYoF,EAA+BpE,GACvC,GARJ,KAAAgM,UAAY,EACZ,KAAAC,aAAe,EACf,KAAAC,SAAW,EACX,KAAAC,SAAW,EACX,KAAAsZ,KAAO,IAAI,EAAA0c,QACX,KAAAl+B,QAAS,EAGO,MAARG,EAAc,MAAM,IAAI7E,MAAM,wBAClC,GAAgB,MAAZS,EAAkB,MAAM,IAAIT,MAAM,4BACtCC,KAAK4E,KAAOA,EACZ5E,KAAKwM,UAAY5H,EAAK4H,UACtBxM,KAAKyM,aAAe7H,EAAK6H,aACzBzM,KAAK0M,SAAW9H,EAAK8H,SACrB1M,KAAK2M,SAAW/H,EAAK+H,SACrB3M,KAAKwE,MAAQ,IAAIsE,MACjB,IAAK,IAAI5I,EAAI,EAAGA,EAAI0E,EAAKJ,MAAMrE,OAAQD,IACnCF,KAAKwE,MAAMkG,KAAKlK,EAASye,SAASra,EAAKJ,MAAMtE,GAAGN,OACpDI,KAAKkB,OAASV,EAASye,SAASra,EAAK1D,OAAOtB,MA0OpD,OAvOI,YAAAwa,SAAA,WACI,OAAOpa,KAAKyE,QAGhB,YAAAlE,MAAA,WACIP,KAAK5B,UAGT,YAAAA,OAAA,WACQ4B,KAAK4E,KAAKuZ,MACNne,KAAK4E,KAAKunB,SACVnsB,KAAK4iC,qBAEL5iC,KAAK6iC,qBAGL7iC,KAAK4E,KAAKunB,SACVnsB,KAAK8iC,qBAEL9iC,KAAK+iC,sBAIjB,YAAAA,mBAAA,WAUI,IATA,IAAIv2B,EAAYxM,KAAKwM,UAAWC,EAAezM,KAAKyM,aAAcC,EAAW1M,KAAK0M,SAC9EC,EAAW3M,KAAK2M,SAChBzL,EAASlB,KAAKkB,OACd8hC,EAAY9hC,EAAOkY,OACnBoI,EAAKwhB,EAAUh8B,EAAGi8B,EAAKD,EAAUloB,EAAGooB,EAAKF,EAAUj8B,EAAGoa,EAAK6hB,EAAUhoB,EACrEmoB,EAAgB3hB,EAAKL,EAAK8hB,EAAKC,EAAK,EAAI,EAAAv/B,UAAUygB,QAAU,EAAAzgB,UAAUygB,OACtEH,EAAiBjkB,KAAK4E,KAAKqf,eAAiBkf,EAC5C3W,EAAexsB,KAAK4E,KAAK4nB,aAAe2W,EACxC3+B,EAAQxE,KAAKwE,MACRtE,EAAI,EAAGa,EAAIyD,EAAMrE,OAAQD,EAAIa,EAAGb,IAAK,CAC1C,IAAIqE,EAAOC,EAAMtE,GACbkjC,GAAW,EACX9kB,EAAM/Z,EAAK6U,OAEf,GAAiB,GAAb5M,EAAgB,CAChB,IAAIxF,EAAIsX,EAAItX,EAAGD,EAAIuX,EAAIxD,EAAGA,EAAIwD,EAAIvX,EAAGiU,EAAIsD,EAAItD,GACzC1V,EAAIc,KAAK4V,MAAMknB,EAAI1hB,GAAMpb,KAAK4V,MAAMlB,EAAG9T,GAAKid,GACxC,EAAAtgB,UAAUgZ,GACdrX,GAAK,EAAA3B,UAAU0gB,IACV/e,GAAK,EAAA3B,UAAUgZ,KACpBrX,GAAK,EAAA3B,UAAU0gB,KACnB/e,GAAKkH,EACL,IAAI8P,EAAMlW,KAAKkW,IAAIhX,GAAIiX,EAAMnW,KAAKmW,IAAIjX,GACtCgZ,EAAItX,EAAIsV,EAAMtV,EAAIuV,EAAMzB,EACxBwD,EAAIxD,EAAIwB,EAAMvV,EAAIwV,EAAMvB,EACxBsD,EAAIvX,EAAIwV,EAAMvV,EAAIsV,EAAMxB,EACxBwD,EAAItD,EAAIuB,EAAMxV,EAAIuV,EAAMtB,EACxBooB,GAAW,EAGf,GAAoB,GAAhB32B,EAAmB,CACnB,IAAIwZ,EAAOjmB,KAAKimB,KAChB/kB,EAAOgd,aAAa+H,EAAKre,IAAI5H,KAAK4E,KAAKwnB,QAASpsB,KAAK4E,KAAKynB,UAC1D/N,EAAIpE,KAAO+L,EAAK1iB,EAAI+a,EAAIpE,IAAMzN,EAC9B6R,EAAInE,KAAO8L,EAAKziB,EAAI8a,EAAInE,IAAM1N,EAC9B22B,GAAW,EAGf,GAAI12B,EAAW,EAAG,CACd,IAAIqP,EAAI3V,KAAKsW,KAAK4B,EAAItX,EAAIsX,EAAItX,EAAIsX,EAAIvX,EAAIuX,EAAIvX,GAC1Cs8B,EAAKj9B,KAAKsW,KAAK8E,EAAKA,EAAK0hB,EAAKA,GAC9BnnB,EAAI,OAASA,GAAKA,GAAKsnB,EAAKtnB,EAAI/b,KAAK4E,KAAK0nB,cAAgB5f,GAAYqP,GAC1EuC,EAAItX,GAAK+U,EACTuC,EAAIvX,GAAKgV,EACTA,EAAI3V,KAAKsW,KAAK4B,EAAIxD,EAAIwD,EAAIxD,EAAIwD,EAAItD,EAAIsD,EAAItD,GAC1CqoB,EAAKj9B,KAAKsW,KAAKumB,EAAKA,EAAK9hB,EAAKA,GAC1BpF,EAAI,OAASA,GAAKA,GAAKsnB,EAAKtnB,EAAI/b,KAAK4E,KAAK2nB,cAAgB7f,GAAYqP,GAC1EuC,EAAIxD,GAAKiB,EACTuC,EAAItD,GAAKe,EACTqnB,GAAW,EAGf,GAAIz2B,EAAW,EAAG,CACV5F,EAAIuX,EAAIxD,EAAGE,EAAIsD,EAAItD,EAAvB,IAEI1V,EADAY,EAAKE,KAAK4V,MAAMhB,EAAGjU,IACnBzB,EAAIc,KAAK4V,MAAMmF,EAAI8hB,GAAM78B,KAAK4V,MAAMknB,EAAI1hB,IAAOtb,EAAKE,KAAK4V,MAAMsC,EAAIvX,EAAGuX,EAAItX,KACtE,EAAArD,UAAUgZ,GACdrX,GAAK,EAAA3B,UAAU0gB,IACV/e,GAAK,EAAA3B,UAAUgZ,KACpBrX,GAAK,EAAA3B,UAAU0gB,KACnB/e,EAAIY,GAAMZ,EAAIknB,GAAgB7f,EAC1BoP,EAAI3V,KAAKsW,KAAK3V,EAAIA,EAAIiU,EAAIA,GAC9BsD,EAAIxD,EAAI1U,KAAKkW,IAAIhX,GAAKyW,EACtBuC,EAAItD,EAAI5U,KAAKmW,IAAIjX,GAAKyW,EACtBqnB,GAAW,EAGXA,IAAU7+B,EAAKwV,cAAe,KAI1C,YAAA+oB,mBAAA,WAUI,IATA,IAAIt2B,EAAYxM,KAAKwM,UAAWC,EAAezM,KAAKyM,aAAcC,EAAW1M,KAAK0M,SAC9EC,EAAW3M,KAAK2M,SAChBzL,EAASlB,KAAKkB,OACd8hC,EAAY9hC,EAAOkY,OACnBoI,EAAKwhB,EAAUh8B,EAAGi8B,EAAKD,EAAUloB,EAAGooB,EAAKF,EAAUj8B,EAAGoa,EAAK6hB,EAAUhoB,EACrEmoB,EAAgB3hB,EAAKL,EAAK8hB,EAAKC,EAAK,EAAI,EAAAv/B,UAAUygB,QAAU,EAAAzgB,UAAUygB,OACtEH,EAAiBjkB,KAAK4E,KAAKqf,eAAiBkf,EAC5C3W,EAAexsB,KAAK4E,KAAK4nB,aAAe2W,EACxC3+B,EAAQxE,KAAKwE,MACRtE,EAAI,EAAGa,EAAIyD,EAAMrE,OAAQD,EAAIa,EAAGb,IAAK,CAC1C,IAAIqE,EAAOC,EAAMtE,GACbkjC,GAAW,EACX9kB,EAAM/Z,EAAK6U,OAEf,GAAiB,GAAb5M,EAAgB,CAChB,IAAIxF,EAAIsX,EAAItX,EAAGD,EAAIuX,EAAIxD,EAAGA,EAAIwD,EAAIvX,EAAGiU,EAAIsD,EAAItD,GACzC1V,EAAIc,KAAK4V,MAAMknB,EAAI1hB,GAAMyC,GACrB,EAAAtgB,UAAUgZ,GACdrX,GAAK,EAAA3B,UAAU0gB,IACV/e,GAAK,EAAA3B,UAAUgZ,KAAIrX,GAAK,EAAA3B,UAAU0gB,KAC3C/e,GAAKkH,EACL,IAAI8P,EAAMlW,KAAKkW,IAAIhX,GAAIiX,EAAMnW,KAAKmW,IAAIjX,GACtCgZ,EAAItX,EAAIsV,EAAMtV,EAAIuV,EAAMzB,EACxBwD,EAAIxD,EAAIwB,EAAMvV,EAAIwV,EAAMvB,EACxBsD,EAAIvX,EAAIwV,EAAMvV,EAAIsV,EAAMxB,EACxBwD,EAAItD,EAAIuB,EAAMxV,EAAIuV,EAAMtB,EACxBooB,GAAW,EAGf,GAAoB,GAAhB32B,EAAmB,CACnB,IAAIwZ,EAAOjmB,KAAKimB,KAChB/kB,EAAOgd,aAAa+H,EAAKre,IAAI5H,KAAK4E,KAAKwnB,QAASpsB,KAAK4E,KAAKynB,UAC1D/N,EAAIpE,IAAM+L,EAAK1iB,EAAIkJ,EACnB6R,EAAInE,IAAM8L,EAAKziB,EAAIiJ,EACnB22B,GAAW,EAGf,GAAI12B,EAAW,EAAG,CACd,IAAIqP,GAAK3V,KAAKsW,KAAK8E,EAAKA,EAAK0hB,EAAKA,GAAM,EAAIljC,KAAK4E,KAAK0nB,cAAgB5f,EAAW,EACjF4R,EAAItX,GAAK+U,EACTuC,EAAIvX,GAAKgV,EACTA,GAAK3V,KAAKsW,KAAKumB,EAAKA,EAAK9hB,EAAKA,GAAM,EAAInhB,KAAK4E,KAAK2nB,cAAgB7f,EAAW,EAC7E4R,EAAIxD,GAAKiB,EACTuC,EAAItD,GAAKe,EACTqnB,GAAW,EAGf,GAAIz2B,EAAW,EAAG,CACd,IAAIrH,KAAIc,KAAK4V,MAAMmF,EAAI8hB,GAAM78B,KAAK4V,MAAMknB,EAAI1hB,IACpC,EAAA7d,UAAUgZ,GACdrX,GAAK,EAAA3B,UAAU0gB,IACV/e,GAAK,EAAA3B,UAAUgZ,KAAIrX,GAAK,EAAA3B,UAAU0gB,KACvCtd,EAAIuX,EAAIxD,EAAGE,EAAIsD,EAAItD,EACvB1V,EAAIc,KAAK4V,MAAMhB,EAAGjU,IAAMzB,EAAI,EAAA3B,UAAUgZ,GAAK,EAAI6P,GAAgB7f,EAC3DoP,EAAI3V,KAAKsW,KAAK3V,EAAIA,EAAIiU,EAAIA,GAC9BsD,EAAIxD,EAAI1U,KAAKkW,IAAIhX,GAAKyW,EACtBuC,EAAItD,EAAI5U,KAAKmW,IAAIjX,GAAKyW,EACtBqnB,GAAW,EAGXA,IAAU7+B,EAAKwV,cAAe,KAI1C,YAAA8oB,mBAAA,WACI,IAAIr2B,EAAYxM,KAAKwM,UAAWC,EAAezM,KAAKyM,aAAcC,EAAW1M,KAAK0M,SAC9EC,EAAW3M,KAAK2M,SAChBzL,EAASlB,KAAKkB,OACbA,EAAO6Y,cAAc7Y,EAAOgc,yBAEjC,IADA,IAAI1Y,EAAQxE,KAAKwE,MACRtE,EAAI,EAAGa,EAAIyD,EAAMrE,OAAQD,EAAIa,EAAGb,IAAK,CAC1C,IAAIqE,EAAOC,EAAMtE,GACZqE,EAAKwV,cAAcxV,EAAK2Y,yBAE7B,IAAIvY,EAAWJ,EAAKmV,UACpB,GAAiB,GAAblN,EAAgB,CAChB,IAAIlH,EAAIpE,EAAOwY,UAAY/U,EAAW3E,KAAK4E,KAAKqf,eAEhDtf,IADAW,GAAsD,KAAhD,OAAU,mBAAqBA,EAAI,IAAO,KAChCkH,EAGpB,IAAIjJ,EAAIgB,EAAKiV,GAAIhW,EAAIe,EAAKkV,GACN,GAAhBhN,IACAlJ,IAAMrC,EAAOsY,GAAKjW,EAAIvD,KAAK4E,KAAKwnB,SAAW3f,EAC3CjJ,IAAMtC,EAAOuY,GAAKjW,EAAIxD,KAAK4E,KAAKynB,SAAW5f,GAG/C,IAAI3G,EAASvB,EAAKoV,QAAS5T,EAASxB,EAAKqV,QACrClN,EAAW,IACP5G,EAAS,OAASA,GAAUA,GAAU5E,EAAOyY,QAAU7T,EAAS9F,KAAK4E,KAAK0nB,cAAgB5f,GAAY5G,GACtGC,EAAS,OAASA,GAAUA,GAAU7E,EAAO0Y,QAAU7T,EAAS/F,KAAK4E,KAAK2nB,cAAgB7f,GAAY3G,IAG9G,IAAIU,EAASlC,EAAKuV,QAClB,GAAInN,EAAW,EAAG,CACVrH,EAAIpE,EAAO4Y,QAAUrT,EAASzG,KAAK4E,KAAK4nB,aAC5ClnB,GAAsD,KAAhD,OAAU,mBAAqBA,EAAI,IAAO,IAChDf,EAAKkC,QAAUnB,EAAIqH,EAGvBpI,EAAK8V,yBAAyB9W,EAAGC,EAAGmB,EAAUmB,EAAQC,EAAQxB,EAAKsV,QAASpT,KAIpF,YAAAm8B,mBAAA,WACI,IAAIp2B,EAAYxM,KAAKwM,UAAWC,EAAezM,KAAKyM,aAAcC,EAAW1M,KAAK0M,SAC9EC,EAAW3M,KAAK2M,SAChBzL,EAASlB,KAAKkB,OACbA,EAAO6Y,cAAc7Y,EAAOgc,yBAEjC,IADA,IAAI1Y,EAAQxE,KAAKwE,MACRtE,EAAI,EAAGa,EAAIyD,EAAMrE,OAAQD,EAAIa,EAAGb,IAAK,CAC1C,IAAIqE,EAAOC,EAAMtE,GACZqE,EAAKwV,cAAcxV,EAAK2Y,yBAE7B,IAAIvY,EAAWJ,EAAKmV,UACH,GAAblN,IAAgB7H,IAAazD,EAAOwY,UAAY1Z,KAAK4E,KAAKqf,gBAAkBzX,GAEhF,IAAIjJ,EAAIgB,EAAKiV,GAAIhW,EAAIe,EAAKkV,GACN,GAAhBhN,IACAlJ,IAAMrC,EAAOsY,GAAKxZ,KAAK4E,KAAKwnB,SAAW3f,EACvCjJ,IAAMtC,EAAOuY,GAAKzZ,KAAK4E,KAAKynB,SAAW5f,GAG3C,IAAI3G,EAASvB,EAAKoV,QAAS5T,EAASxB,EAAKqV,QACrClN,EAAW,IACP5G,EAAS,OAASA,IAAY5E,EAAOyY,QAAU,EAAI3Z,KAAK4E,KAAK0nB,cAAgB5f,EAAY,GACzF3G,EAAS,OAASA,IAAY7E,EAAO0Y,QAAU,EAAI5Z,KAAK4E,KAAK2nB,cAAgB7f,EAAY,IAGjG,IAAIjG,EAASlC,EAAKuV,QACdnN,EAAW,IAAGlG,IAAWvF,EAAO4Y,QAAU9Z,KAAK4E,KAAK4nB,cAAgB7f,GAExEpI,EAAK8V,yBAAyB9W,EAAGC,EAAGmB,EAAUmB,EAAQC,EAAQxB,EAAKsV,QAASpT,KAGxF,EAhQA,GAAa,EAAA0gB,oBAAmB,EADf,GAAA3nB,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,kBAQI,WAAaI,GAAb,MACI,YAAMA,EAAM,GAAG,IAAM,K,OARzB,EAAA4E,MAAQ,IAAIsE,MAEZ,EAAA0D,UAAY,EAAG,EAAAC,aAAe,EAAG,EAAAC,SAAW,EAAG,EAAAC,SAAW,EAC1D,EAAAsX,eAAiB,EAAG,EAAAmI,QAAU,EAAG,EAAAC,QAAU,EAAG,EAAAC,aAAe,EAAG,EAAAC,aAAe,EAAG,EAAAC,aAAe,EACjG,EAAAL,UAAW,EACX,EAAAhO,OAAQ,E,EAKZ,OAX6C,OAW7C,EAXA,CAA6C,EAAAW,gBAAhC,EAAAoN,wBAAuB,EADnB,GAAA1sB,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCDpB,SAAUA,IAAW,SAAAC,GACpB,8BACS,KAAA8jC,eAAiB,IAAIx6B,MACrB,KAAAy6B,sBAAwB,IAAIz6B,MAE5B,KAAA06B,aAAe,IAAI16B,MACnB,KAAA26B,eAAiB,IAAI36B,MACrB,KAAAulB,UAAY,IAAIvlB,MAEhB,KAAA4pB,YAAc,IAAI,EAAA9jB,MAAoB,WAC7C,OAAO,IAAI9F,SAGJ,KAAA46B,mBAAqB,IAAI,EAAA90B,MAAoB,WACpD,OAAO,IAAI9F,SAgOb,OA7NQ,YAAA0sB,YAAP,SAAoBmO,GACnB,IAAIp6B,EAAWo6B,EACX95B,EAAc85B,EAAcxjC,QAAU,EAEtCyjC,EAAU5jC,KAAKwjC,aACnBI,EAAQzjC,OAAS,EACjB,IAAK,IAAID,EAAI,EAAGA,EAAI2J,EAAa3J,IAChC0jC,EAAQ1jC,GAAKA,EAEd,IAAI2jC,EAAY7jC,KAAKyjC,eACrBI,EAAU1jC,OAAS,EACVD,EAAI,EAAb,IAAK,IAAWa,EAAI8I,EAAa3J,EAAIa,IAAKb,EACzC2jC,EAAU3jC,GAAK00B,EAAaiP,UAAU3jC,EAAG2J,EAAaN,EAAUq6B,GAEjE,IAAIvV,EAAYruB,KAAKquB,UAGrB,IAFAA,EAAUluB,OAAS,EAEZ0J,EAAc,GAAG,CAGvB,IADA,IAAIi6B,EAAWj6B,EAAc,EAAUuF,GAAPlP,EAAI,EAAU,KACjC,CACZ+U,EACA,IAAK4uB,EAAU3jC,GAAI,CAKlB,IAJA,IAAI6jC,EAAKH,EAAQE,IAAa,EAAGE,EAAKJ,EAAQ1jC,IAAM,EAAG+jC,EAAKL,EAAQx0B,IAAS,EACzEopB,EAAMjvB,EAASw6B,GAAKtL,EAAMlvB,EAASw6B,EAAK,GACxCrL,EAAMnvB,EAASy6B,GAAKE,EAAM36B,EAASy6B,EAAK,GACxCG,EAAM56B,EAAS06B,GAAKG,EAAM76B,EAAS06B,EAAK,GACnCpzB,GAAMzB,EAAO,GAAKvF,EAAagH,GAAMizB,EAAUjzB,GAAMA,EAAK,GAAKhH,EACvE,GAAKg6B,EAAUhzB,GAAf,CACA,IAAIggB,EAAI+S,EAAQ/yB,IAAO,EACnBwzB,EAAK96B,EAASsnB,GAAIyT,EAAK/6B,EAASsnB,EAAI,GACxC,GAAI+D,EAAa2P,aAAaJ,EAAKC,EAAK5L,EAAKC,EAAK4L,EAAIC,IACjD1P,EAAa2P,aAAa/L,EAAKC,EAAKC,EAAKwL,EAAKG,EAAIC,IACjD1P,EAAa2P,aAAa7L,EAAKwL,EAAKC,EAAKC,EAAKC,EAAIC,GAAK,MAAMrvB,EAIpE,MAGD,GAAY,GAAR7F,EAAW,CACd,EAAG,CACF,IAAKy0B,EAAU3jC,GAAI,MACnBA,UACQA,EAAI,GACb,MAGD4jC,EAAW5jC,EACXA,EAAIkP,EACJA,GAAQA,EAAO,GAAKvF,EAIrBwkB,EAAU3jB,KAAKk5B,GAAS/5B,EAAc3J,EAAI,GAAK2J,IAC/CwkB,EAAU3jB,KAAKk5B,EAAQ1jC,IACvBmuB,EAAU3jB,KAAKk5B,GAAS1jC,EAAI,GAAK2J,IACjC+5B,EAAQpuB,OAAOtV,EAAG,GAClB2jC,EAAUruB,OAAOtV,EAAG,GAGpB,IAAIskC,KAFJ36B,EAEmC3J,EAAI,GAAK2J,EACxC46B,EAAYvkC,GAAK2J,EAAc,EAAI3J,EACvC2jC,EAAUW,GAAiB5P,EAAaiP,UAAUW,EAAe36B,EAAaN,EAAUq6B,GACxFC,EAAUY,GAAa7P,EAAaiP,UAAUY,EAAW56B,EAAaN,EAAUq6B,GASjF,OANmB,GAAf/5B,IACHwkB,EAAU3jB,KAAKk5B,EAAQ,IACvBvV,EAAU3jB,KAAKk5B,EAAQ,IACvBvV,EAAU3jB,KAAKk5B,EAAQ,KAGjBvV,GAGR,YAAAkH,UAAA,SAAWoO,EAA8BtV,GACxC,IAAI9kB,EAAWo6B,EACXL,EAAiBtjC,KAAKsjC,eAC1BtjC,KAAK0yB,YAAYE,QAAQ0Q,GACzBA,EAAenjC,OAAS,EAExB,IAAIojC,EAAwBvjC,KAAKujC,sBACjCvjC,KAAK0jC,mBAAmB9Q,QAAQ2Q,GAChCA,EAAsBpjC,OAAS,EAE/B,IAAIukC,EAAiB1kC,KAAK0jC,mBAAmBhvB,SAC7CgwB,EAAevkC,OAAS,EAExB,IAAI2yB,EAAU9yB,KAAK0yB,YAAYhe,SAC/Boe,EAAQ3yB,OAAS,EAIjB,IADA,IAAIwkC,GAAgB,EAAGC,EAAc,EAC5B1kC,EAAI,EAAGa,EAAIstB,EAAUluB,OAAQD,EAAIa,EAAGb,GAAK,EAAG,CACpD,IAAI2kC,EAAKxW,EAAUnuB,IAAM,EAAG4kC,EAAKzW,EAAUnuB,EAAI,IAAM,EAAG6kC,EAAK1W,EAAUnuB,EAAI,IAAM,EAC7EwlB,EAAKnc,EAASs7B,GAAKlf,EAAKpc,EAASs7B,EAAK,GACtCjf,EAAKrc,EAASu7B,GAAKjf,EAAKtc,EAASu7B,EAAK,GACtC/Q,EAAKxqB,EAASw7B,GAAK/Q,EAAKzqB,EAASw7B,EAAK,GAGtCC,GAAS,EACb,GAAIL,GAAgBE,EAAI,CACvB,IAAI7f,EAAI8N,EAAQ3yB,OAAS,EACrB8kC,EAAWrQ,EAAasQ,QAAQpS,EAAQ9N,GAAI8N,EAAQ9N,EAAI,GAAI8N,EAAQ9N,EAAI,GAAI8N,EAAQ9N,EAAI,GAAI+O,EAAIC,GAChGmR,EAAWvQ,EAAasQ,QAAQnR,EAAIC,EAAIlB,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,IACpFmS,GAAYL,GAAeO,GAAYP,IAC1C9R,EAAQpoB,KAAKqpB,GACbjB,EAAQpoB,KAAKspB,GACb0Q,EAAeh6B,KAAKq6B,GACpBC,GAAS,GAKNA,IACAlS,EAAQ3yB,OAAS,GACpBmjC,EAAe54B,KAAKooB,GACpByQ,EAAsB74B,KAAKg6B,KAE3B1kC,KAAK0yB,YAAYzb,KAAK6b,GACtB9yB,KAAK0jC,mBAAmBzsB,KAAKytB,KAE9B5R,EAAU9yB,KAAK0yB,YAAYhe,UACnBvU,OAAS,EACjB2yB,EAAQpoB,KAAKgb,GACboN,EAAQpoB,KAAKib,GACbmN,EAAQpoB,KAAKkb,GACbkN,EAAQpoB,KAAKmb,GACbiN,EAAQpoB,KAAKqpB,GACbjB,EAAQpoB,KAAKspB,IACb0Q,EAAiB1kC,KAAK0jC,mBAAmBhvB,UAC1BvU,OAAS,EACxBukC,EAAeh6B,KAAKm6B,GACpBH,EAAeh6B,KAAKo6B,GACpBJ,EAAeh6B,KAAKq6B,GACpBH,EAAchQ,EAAasQ,QAAQxf,EAAIC,EAAIC,EAAIC,EAAIkO,EAAIC,GACvD2Q,EAAeE,GAIb/R,EAAQ3yB,OAAS,IACpBmjC,EAAe54B,KAAKooB,GACpByQ,EAAsB74B,KAAKg6B,IAI5B,IAASxkC,EAAI,EAAGa,EAAIuiC,EAAenjC,OAAQD,EAAIa,EAAGb,IAEjD,GAA6B,IAD7BwkC,EAAiBnB,EAAsBrjC,IACpBC,OAYnB,IAXA,IAAIilC,EAAaV,EAAe,GAC5BW,EAAYX,EAAeA,EAAevkC,OAAS,GAInDmlC,GAFJxS,EAAUwQ,EAAepjC,IACrB8kB,EAAI8N,EAAQ3yB,OAAS,GACGolC,EAAYzS,EAAQ9N,EAAI,GAChDlhB,EAAQgvB,EAAQ9N,EAAI,GAAIjhB,EAAQ+uB,EAAQ9N,EAAI,GAC5CwgB,EAAS1S,EAAQ,GAAI2S,EAAS3S,EAAQ,GACtC4S,EAAU5S,EAAQ,GAAI6S,EAAU7S,EAAQ,GACxCoS,EAAUtQ,EAAasQ,QAAQI,EAAWC,EAAWzhC,EAAOC,EAAOyhC,EAAQC,GAEtE50B,EAAK,EAAGA,EAAK9P,EAAG8P,IACxB,GAAIA,GAAM3Q,EAAV,CACA,IAAI0lC,EAAerC,EAAsB1yB,GACzC,GAA2B,GAAvB+0B,EAAazlC,OAAjB,CACA,IAAI0lC,EAAkBD,EAAa,GAC/BE,EAAmBF,EAAa,GAChCG,EAAiBH,EAAa,GAE9BI,EAAY1C,EAAezyB,GAC3BkjB,EAAKiS,EAAUA,EAAU7lC,OAAS,GAAI6zB,EAAKgS,EAAUA,EAAU7lC,OAAS,GAE5E,GAAI0lC,GAAmBT,GAAcU,GAAoBT,EAAzD,CACIJ,EAAWrQ,EAAasQ,QAAQI,EAAWC,EAAWzhC,EAAOC,EAAOgwB,EAAIC,GACxEmR,EAAWvQ,EAAasQ,QAAQnR,EAAIC,EAAIwR,EAAQC,EAAQC,EAASC,GACjEV,GAAYC,GAAWC,GAAYD,IACtCc,EAAU7lC,OAAS,EACnBylC,EAAazlC,OAAS,EACtB2yB,EAAQpoB,KAAKqpB,GACbjB,EAAQpoB,KAAKspB,GACb0Q,EAAeh6B,KAAKq7B,GACpBT,EAAYxhC,EACZyhC,EAAYxhC,EACZD,EAAQiwB,EACRhwB,EAAQiwB,EACRnjB,EAAK,KAMR,IAAS3Q,EAAIojC,EAAenjC,OAAS,EAAGD,GAAK,EAAGA,IAEzB,IADtB4yB,EAAUwQ,EAAepjC,IACbC,SACXmjC,EAAe9tB,OAAOtV,EAAG,GACzBF,KAAK0yB,YAAYzb,KAAK6b,GACtB4R,EAAiBnB,EAAsBrjC,GACvCqjC,EAAsB/tB,OAAOtV,EAAG,GAChCF,KAAK0jC,mBAAmBzsB,KAAKytB,IAI/B,OAAOpB,GAGO,EAAAO,UAAf,SAA0BthC,EAAesH,EAAqBN,EAA6Bq6B,GAC1F,IAAIE,EAAWF,GAAS/5B,EAActH,EAAQ,GAAKsH,IAAgB,EAC/DvI,EAAUsiC,EAAQrhC,IAAU,EAC5B6M,EAAOw0B,GAASrhC,EAAQ,GAAKsH,IAAgB,EACjD,OAAQ7J,KAAKukC,aAAah7B,EAASu6B,GAAWv6B,EAASu6B,EAAW,GAAIv6B,EAASjI,GAAUiI,EAASjI,EAAU,GAAIiI,EAAS6F,GACxH7F,EAAS6F,EAAO,KAGH,EAAAm1B,aAAf,SAA6B/L,EAAaC,EAAaC,EAAawL,EAAaC,EAAaC,GAC7F,OAAO5L,GAAO4L,EAAMF,GAAOxL,GAAOD,EAAM2L,GAAOD,GAAOD,EAAMzL,IAAQ,GAGtD,EAAAyM,QAAf,SAAwB1M,EAAaC,EAAaC,EAAawL,EAAaC,EAAaC,GACxF,IAAIpkB,EAAK0Y,EAAMF,EAAKvY,EAAKikB,EAAMzL,EAC/B,OAAO0L,EAAMlkB,EAAKmkB,EAAMpkB,EAAKA,EAAKyY,EAAMD,EAAMvY,GAAM,EAAI,GAAK,GAE/D,EA7OA,GAAa,EAAA2U,aAAY,EADL,GAAAp1B,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GAKjB,8BACI,KAAAgwB,MAAQ,IAAI1mB,MAmBhB,OAjBI,YAAA7D,IAAA,SAAKuI,GACD,IAAIua,EAAW/nB,KAAK+nB,SAASva,GAE7B,OADAxN,KAAKwvB,MAAc,EAARhiB,GAAqB,EAARA,GAChBua,GAGZ,YAAAA,SAAA,SAAUva,GACN,YAAgCwK,GAAzBhY,KAAKwvB,MAAc,EAARhiB,IAGtB,YAAAy4B,OAAA,SAAQz4B,GACJxN,KAAKwvB,MAAc,EAARhiB,QAAawK,GAG5B,YAAAnD,MAAA,WACI7U,KAAKwvB,MAAMrvB,OAAS,GAE5B,EApBA,GAAa,EAAAsO,OAAM,EA8BnB,iBAOI,WAAoBnJ,EAAsBwB,EAAsBC,EAAsBC,QAAlE,IAAA1B,MAAA,QAAsB,IAAAwB,MAAA,QAAsB,IAAAC,MAAA,QAAsB,IAAAC,MAAA,GAAlE,KAAA1B,IAAsB,KAAAwB,IAAsB,KAAAC,IAAsB,KAAAC,IAiE1F,OA9DI,YAAAY,IAAA,SAAKtC,EAAWwB,EAAWC,EAAWC,GAMlC,OALAhH,KAAKsF,EAAIA,EACTtF,KAAK8G,EAAIA,EACT9G,KAAK+G,EAAIA,EACT/G,KAAKgH,EAAIA,EACThH,KAAK4D,QACE5D,MAGX,YAAAuH,aAAA,SAAcuT,GAKV,OAJA9a,KAAKsF,EAAIwV,EAAExV,EACXtF,KAAK8G,EAAIgU,EAAEhU,EACX9G,KAAK+G,EAAI+T,EAAE/T,EACX/G,KAAKgH,EAAI8T,EAAE9T,EACJhH,MAGX,YAAA+5B,cAAA,SAAemM,GAMX,OALAA,EAAuB,KAAjBA,EAAIC,OAAO,GAAYD,EAAI3M,OAAO,GAAK2M,EAC7ClmC,KAAKsF,EAAIu7B,SAASqF,EAAI3M,OAAO,EAAG,GAAI,IAAM,IAC1Cv5B,KAAK8G,EAAI+5B,SAASqF,EAAI3M,OAAO,EAAG,GAAI,IAAM,IAC1Cv5B,KAAK+G,EAAI85B,SAASqF,EAAI3M,OAAO,EAAG,GAAI,IAAM,IAC1Cv5B,KAAKgH,GAAmB,GAAdk/B,EAAI/lC,OAAc,IAAM0gC,SAASqF,EAAI3M,OAAO,EAAG,GAAI,KAAO,IAC7Dv5B,MAGX,YAAAiF,IAAA,SAAKK,EAAWwB,EAAWC,EAAWC,GAMlC,OALAhH,KAAKsF,GAAKA,EACVtF,KAAK8G,GAAKA,EACV9G,KAAK+G,GAAKA,EACV/G,KAAKgH,GAAKA,EACVhH,KAAK4D,QACE5D,MAGX,YAAA4D,MAAA,WAYI,OAXI5D,KAAKsF,EAAI,EAAGtF,KAAKsF,EAAI,EAChBtF,KAAKsF,EAAI,IAAGtF,KAAKsF,EAAI,GAE1BtF,KAAK8G,EAAI,EAAG9G,KAAK8G,EAAI,EAChB9G,KAAK8G,EAAI,IAAG9G,KAAK8G,EAAI,GAE1B9G,KAAK+G,EAAI,EAAG/G,KAAK+G,EAAI,EAChB/G,KAAK+G,EAAI,IAAG/G,KAAK+G,EAAI,GAE1B/G,KAAKgH,EAAI,EAAGhH,KAAKgH,EAAI,EAChBhH,KAAKgH,EAAI,IAAGhH,KAAKgH,EAAI,GACvBhH,MAGJ,EAAA0rB,gBAAP,SAAuB9kB,EAAc4G,GACjC5G,EAAMtB,IAAc,WAARkI,KAAwB,IAAM,IAC1C5G,EAAME,IAAc,SAAR0G,KAAwB,IAAM,IAC1C5G,EAAMG,IAAc,MAARyG,KAAwB,GAAK,IACzC5G,EAAMI,GAAc,IAARwG,GAAuB,KAGhC,EAAAqe,cAAP,SAAsBjlB,EAAc4G,GAChC5G,EAAMtB,IAAc,SAARkI,KAAwB,IAAM,IAC1C5G,EAAME,IAAc,MAAR0G,KAAwB,GAAK,IACzC5G,EAAMG,GAAc,IAARyG,GAAuB,KArEzB,EAAA44B,MAAQ,IAAIznB,EAAM,EAAG,EAAG,EAAG,GAC3B,EAAA0nB,IAAM,IAAI1nB,EAAM,EAAG,EAAG,EAAG,GACzB,EAAA2nB,MAAQ,IAAI3nB,EAAM,EAAG,EAAG,EAAG,GAC3B,EAAA4nB,KAAO,IAAI5nB,EAAM,EAAG,EAAG,EAAG,GAC1B,EAAA6nB,QAAU,IAAI7nB,EAAM,EAAG,EAAG,EAAG,GAmE/C,EAxEA,GAAa,EAAAA,MAAK,EA0ElB,+BA6CA,OArCW,EAAA/a,MAAP,SAAc4J,EAAemG,EAAapB,GACtC,OAAI/E,EAAQmG,EAAYA,EACpBnG,EAAQ+E,EAAYA,EACjB/E,GAGJ,EAAAqN,OAAP,SAAezW,GACX,OAAOgC,KAAKkW,IAAIlY,EAAUT,EAAUygB,SAGjC,EAAArJ,OAAP,SAAe3W,GACX,OAAOgC,KAAKmW,IAAInY,EAAUT,EAAUygB,SAGjC,EAAA9d,OAAP,SAAekH,GACX,OAAOA,EAAQ,EAAI,EAAIA,EAAQ,GAAK,EAAI,GAGrC,EAAA2J,MAAP,SAAc5T,GACV,OAAOA,EAAI,EAAI6C,KAAKsQ,MAAMnT,GAAK6C,KAAKqgC,KAAKljC,IAGtC,EAAAmjC,KAAP,SAAanjC,GACT,IAAIC,EAAI4C,KAAKugC,IAAIvgC,KAAKC,IAAI9C,GAAI,EAAE,GAChC,OAAOA,EAAI,GAAKC,EAAIA,GAGjB,EAAAojC,iBAAP,SAAyBjzB,EAAapB,GAClC,OAAO5O,EAAUkjC,qBAAqBlzB,EAAKpB,EAAmB,IAAboB,EAAMpB,KAGpD,EAAAs0B,qBAAP,SAA6BlzB,EAAapB,EAAau0B,GACnD,IAAIjmB,EAAIza,KAAK2gC,SACT/rB,EAAIzI,EAAMoB,EACd,OAAIkN,IAAMimB,EAAOnzB,GAAOqH,EAAUrH,EAAMvN,KAAKsW,KAAKmE,EAAI7F,GAAK8rB,EAAOnzB,IAC3DpB,EAAMnM,KAAKsW,MAAM,EAAImE,GAAK7F,GAAKzI,EAAMu0B,KA1CzC,EAAAnqB,GAAK,UACL,EAAA0H,IAAqB,EAAf1gB,EAAUgZ,GAChB,EAAAqqB,iBAAmB,IAAMrjC,EAAUgZ,GACnC,EAAAV,OAAStY,EAAUqjC,iBACnB,EAAAC,iBAAmBtjC,EAAUgZ,GAAK,IAClC,EAAAyH,OAASzgB,EAAUsjC,iBAuC9B,EA7CA,GAAa,EAAAtjC,UAAS,EA+CtB,+BAKA,OAHI,YAAApD,MAAA,SAAMsD,EAAe8L,EAAa3I,GAC9B,OAAOnD,GAAS8L,EAAM9L,GAAS7D,KAAKknC,cAAclgC,IAE1D,EALA,GAAsB,EAAAmgC,cAAa,EAOnC,kBAGI,WAAaC,GAAb,MACI,cAAO,K,OAHD,EAAAA,MAAQ,EAId,EAAKA,MAAQA,E,EAOrB,OAZyB,OAQrB,YAAAF,cAAA,SAAelgC,GACX,OAAIA,GAAK,GAAYZ,KAAKugC,IAAQ,EAAJ3/B,EAAOhH,KAAKonC,OAAS,EAC5ChhC,KAAKugC,IAAc,GAAT3/B,EAAI,GAAQhH,KAAKonC,QAAUpnC,KAAKonC,MAAQ,GAAK,GAAK,EAAI,GAAK,GAEpF,EAZA,CAAyBD,GAAZ,EAAAE,IAAG,EAchB,kBACI,WAAaD,G,OACT,YAAMA,IAAM,KAMpB,OAR4B,OAKxB,YAAAF,cAAA,SAAelgC,GACX,OAAOZ,KAAKugC,IAAI3/B,EAAI,EAAGhH,KAAKonC,QAAUpnC,KAAKonC,MAAQ,GAAK,GAAK,EAAI,GAAK,GAE9E,EARA,CAA4BC,GAAf,EAAAC,OAAM,EAUnB,+BAqEA,OAlEW,EAAAp9B,UAAP,SAAqBq9B,EAAsBC,EAAqBC,EAAoBC,EAAmBC,GACnG,IAAK,IAAIznC,EAAIsnC,EAAarN,EAAIuN,EAAWxnC,EAAIsnC,EAAcG,EAAaznC,IAAKi6B,IACzEsN,EAAKtN,GAAKoN,EAAOrnC,IAIlB,EAAA6J,aAAP,SAAwBylB,EAAiB3F,EAAcrc,QAAA,IAAAA,MAAA,GACnD,IAAIo6B,EAAUpY,EAAMrvB,OACpB,GAAIynC,GAAW/d,EAAM,OAAO2F,EAE5B,GADAA,EAAMrvB,OAAS0pB,EACX+d,EAAU/d,EACV,IAAK,IAAI3pB,EAAI0nC,EAAS1nC,EAAI2pB,EAAM3pB,IAAKsvB,EAAMtvB,GAAKsN,EAEpD,OAAOgiB,GAGJ,EAAA/a,oBAAP,SAA+B+a,EAAiB3F,EAAcrc,GAC1D,YAD0D,IAAAA,MAAA,GACtDgiB,EAAMrvB,QAAU0pB,EAAa2F,EAC1B5tB,EAAMmI,aAAaylB,EAAO3F,EAAMrc,IAGpC,EAAAqhB,SAAP,SAAoBhF,EAAcsR,GAE9B,IADA,IAAI3L,EAAQ,IAAI1mB,MAAS+gB,GAChB3pB,EAAI,EAAGA,EAAI2pB,EAAM3pB,IAAKsvB,EAAMtvB,GAAKi7B,EAC1C,OAAO3L,GAGJ,EAAA3tB,cAAP,SAAsBgoB,GAClB,GAAIjoB,EAAMimC,sBACN,OAAO,IAAInZ,aAAa7E,GAGxB,IADA,IAAI2F,EAAQ,IAAI1mB,MAAc+gB,GACrB3pB,EAAI,EAAGA,EAAIsvB,EAAMrvB,OAAQD,IAAKsvB,EAAMtvB,GAAK,EAClD,OAAOsvB,GAIR,EAAAsY,cAAP,SAAsBje,GAClB,GAAIjoB,EAAMimC,sBACN,OAAO,IAAIE,WAAWle,GAGtB,IADA,IAAI2F,EAAQ,IAAI1mB,MAAc+gB,GACrB3pB,EAAI,EAAGA,EAAIsvB,EAAMrvB,OAAQD,IAAKsvB,EAAMtvB,GAAK,EAClD,OAAOsvB,GAIR,EAAAD,aAAP,SAAqBC,GACjB,OAAO5tB,EAAMimC,sBAAwB,IAAInZ,aAAac,GAASA,GAG5D,EAAAoM,kBAAP,SAA0BpuB,GACtB,OAAO5L,EAAMimC,sBAAwBzhC,KAAK4hC,OAAOx6B,GAASA,GAIvD,EAAAsD,sBAAP,SAA8BlQ,EAAeC,KAItC,EAAAknB,SAAP,SAAoByH,EAAiB1xB,EAAYmqC,QAAA,IAAAA,OAAA,GAC7C,IAAK,IAAI/nC,EAAI,EAAGA,EAAIsvB,EAAMrvB,OAAQD,IAC9B,GAAIsvB,EAAMtvB,IAAMpC,EAAS,OAAO,EAEpC,OAAO,GAlEJ,EAAA+pC,sBAAiD,qBAAlBnZ,aAoE1C,EArEA,GAAa,EAAA9sB,MAAK,EAuElB,+BAQA,OAPW,EAAAsmC,SAAP,SAAgB1nC,GACZ,IAAK,IAAIN,EAAI,EAAGA,EAAIM,EAASgE,MAAMrE,OAAQD,IAAK,CAC5C,IAAIqE,EAAO/D,EAASgE,MAAMtE,GACtBoe,EAAM/Z,EAAK6U,OACfvD,QAAQqrB,IAAI38B,EAAKK,KAAKhF,KAAO,KAAO0e,EAAItX,EAAI,KAAOsX,EAAIvX,EAAI,KAAOuX,EAAIxD,EAAI,KAAOwD,EAAItD,EAAI,KAAOsD,EAAIpE,GAAK,KAAOoE,EAAInE,MAGhI,EARA,GAAa,EAAAguB,WAAU,EAUvB,iBAII,WAAaC,GAHL,KAAAC,MAAQ,IAAIv/B,MAIhB9I,KAAKooC,aAAeA,EAqB5B,OAlBI,YAAA1zB,OAAA,WACI,OAAO1U,KAAKqoC,MAAMloC,OAAS,EAAIH,KAAKqoC,MAAMC,MAAQtoC,KAAKooC,gBAG3D,YAAAnxB,KAAA,SAAM3X,GACGA,EAAa8W,OAAQ9W,EAAa8W,QACvCpW,KAAKqoC,MAAM39B,KAAKpL,IAGpB,YAAAszB,QAAA,SAASyV,GACL,IAAK,IAAInoC,EAAI,EAAGA,EAAImoC,EAAMloC,OAAQD,IAC9BF,KAAKiX,KAAKoxB,EAAMnoC,KAIxB,YAAA2U,MAAA,WACI7U,KAAKqoC,MAAMloC,OAAS,GAE5B,EA1BA,GAAa,EAAAyO,KAAI,EA4BjB,iBACI,WAAoBrL,EAAcC,QAAd,IAAAD,MAAA,QAAc,IAAAC,MAAA,GAAd,KAAAD,IAAc,KAAAC,IAuBtC,OApBI,YAAAoE,IAAA,SAAKrE,EAAWC,GAGZ,OAFAxD,KAAKuD,EAAIA,EACTvD,KAAKwD,EAAIA,EACFxD,MAGX,YAAAG,OAAA,WACI,IAAIoD,EAAIvD,KAAKuD,EACTC,EAAIxD,KAAKwD,EACb,OAAO4C,KAAKsW,KAAKnZ,EAAIA,EAAIC,EAAIA,IAGjC,YAAA+kC,UAAA,WACI,IAAIC,EAAMxoC,KAAKG,SAKf,OAJW,GAAPqoC,IACAxoC,KAAKuD,GAAKilC,EACVxoC,KAAKwD,GAAKglC,GAEPxoC,MAEf,EAxBA,GAAa,EAAA2iC,QAAO,EA0BpB,8BACI,KAAA8F,SAAW,KACX,KAAAC,gBAAkB,EAClB,KAAA75B,MAAQ,EACR,KAAA85B,UAAY,EAEJ,KAAAloC,SAAWmoC,KAAKC,MAAQ,IACxB,KAAAnnC,WAAa,EACb,KAAA0D,UAAY,EAiBxB,OAfI,YAAAhH,OAAA,WACI,IAAIyqC,EAAMD,KAAKC,MAAQ,IACvB7oC,KAAK6O,MAAQg6B,EAAM7oC,KAAKS,SACxBT,KAAKoF,WAAapF,KAAK6O,MACvB7O,KAAK2oC,WAAa3oC,KAAK6O,MACnB7O,KAAK6O,MAAQ7O,KAAKyoC,WAAUzoC,KAAK6O,MAAQ7O,KAAKyoC,UAClDzoC,KAAKS,SAAWooC,EAEhB7oC,KAAK0B,aACD1B,KAAKoF,UAAY,IACjBpF,KAAK0oC,gBAAkB1oC,KAAK0B,WAAa1B,KAAKoF,UAC9CpF,KAAKoF,UAAY,EACjBpF,KAAK0B,WAAa,IAG9B,EAzBA,GAAa,EAAAonC,WAAU,EAgCvB,iBAOI,WAAaC,QAAA,IAAAA,MAAA,IALb,KAAAC,YAAc,EACd,KAAAC,UAAY,EACZ,KAAAC,KAAO,EACP,KAAAC,OAAQ,EAGJnpC,KAAKiB,OAAS,IAAI6H,MAAcigC,GA8BxC,OA3BI,YAAAK,cAAA,WACI,OAAOppC,KAAKgpC,aAAehpC,KAAKiB,OAAOd,QAG3C,YAAAkpC,SAAA,SAAU77B,GACFxN,KAAKgpC,YAAchpC,KAAKiB,OAAOd,QAC/BH,KAAKgpC,cACThpC,KAAKiB,OAAOjB,KAAKipC,aAAez7B,EAC5BxN,KAAKipC,UAAYjpC,KAAKiB,OAAOd,OAAS,IAAGH,KAAKipC,UAAY,GAC9DjpC,KAAKmpC,OAAQ,GAGjB,YAAAG,QAAA,WACI,GAAItpC,KAAKopC,gBAAiB,CACtB,GAAIppC,KAAKmpC,MAAO,CAEZ,IADA,IAAID,EAAO,EACFhpC,EAAI,EAAGA,EAAIF,KAAKiB,OAAOd,OAAQD,IACpCgpC,GAAQlpC,KAAKiB,OAAOf,GAExBF,KAAKkpC,KAAOA,EAAOlpC,KAAKiB,OAAOd,OAC/BH,KAAKmpC,OAAQ,EAEjB,OAAOnpC,KAAKkpC,KAEZ,OAAO,GAGnB,EAtCA,GAAa,EAAAK,aAAY,EAlWR,GAAA/pC,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCCpB,SAAUA,IAAW,SAAAC,GACjB,MAGI,SAAYI,GACR,GAAY,MAARA,EAAc,MAAM,IAAIG,MAAM,wBAClCC,KAAKJ,KAAOA,GALE,EAAA4pC,WAAU,EAWhC,kBASI,WAAY5pC,GAAZ,MACI,YAAMA,IAAK,K,OAPf,EAAAU,IAAkC,MAA5BoJ,EAAiB+/B,WAAqB,GAG5C,EAAA9kB,oBAAsB,EACtB,EAAAhb,iBAAqC,E,EAyFzC,OAhG+C,OAa3C,YAAA+/B,wBAAA,SAAwBriC,EAAYsiC,GAChC3pC,KAAKolB,qBAAqB/d,EAAM,EAAGrH,KAAK2kB,oBAAqBglB,EAAe,EAAG,IAQnF,YAAAvkB,qBAAA,SAAsB/d,EAAYxD,EAAeqT,EAAeyyB,EAAkC/f,EAAgBggB,GAC9G1yB,EAAQ0S,GAAU1S,GAAS,GAAK0yB,EAChC,IAAIppC,EAAW6G,EAAK9C,KAAK/D,SACrBoJ,EAAcvC,EAAKiC,OACnBC,EAAWvJ,KAAKuJ,SAChB/E,EAAQxE,KAAKwE,MACjB,GAAa,MAATA,EAAJ,CAcA,IADA,IAAIqsB,EAAI,EAAGgZ,EAAO,EACT3pC,EAAI,EAAGA,EAAI2D,EAAO3D,GAAK,EAAG,CAE/B2wB,IADI9vB,EAAIyD,EAAMqsB,IACL,EACTgZ,GAAQ9oC,EAEZ,IAAI+oC,EAAgBtpC,EAASgE,MAC7B,GAA0B,GAAtBoF,EAAYzJ,OACZ,IAAS2lB,EAAI8D,EAAQ7iB,EAAW,EAAP8iC,EAAU/jB,EAAI5O,EAAO4O,GAAK8jB,EAAQ,CACvD,IAAIG,EAAK,EAAGC,EAAK,EACbjpC,EAAIyD,EAAMqsB,KAEd,IADA9vB,GAAK8vB,EACEA,EAAI9vB,EAAG8vB,IAAK9pB,GAAK,EAAG,CACnBuX,EAAMwrB,EAActlC,EAAMqsB,IAAIzX,OAC9BirB,EAAK96B,EAASxC,GAAIu9B,EAAK/6B,EAASxC,EAAI,GADxC,IAC4CkjC,EAAS1gC,EAASxC,EAAI,GAClEgjC,IAAO1F,EAAK/lB,EAAItX,EAAIs9B,EAAKhmB,EAAIxD,EAAIwD,EAAIpE,IAAM+vB,EAC3CD,IAAO3F,EAAK/lB,EAAIvX,EAAIu9B,EAAKhmB,EAAItD,EAAIsD,EAAInE,IAAM8vB,EAE/CN,EAAc7jB,GAAKikB,EACnBJ,EAAc7jB,EAAI,GAAKkkB,OAI3B,IADA,IAAI1gC,EAASM,EACsBsgC,GAA1BpkB,EAAI8D,EAAQ7iB,EAAW,EAAP8iC,EAAcA,GAAQ,GAAG/jB,EAAI5O,EAAO4O,GAAK8jB,EAAQ,CAClEG,EAAK,EAAGC,EAAK,EACbjpC,EAAIyD,EAAMqsB,KAEd,IADA9vB,GAAK8vB,EACEA,EAAI9vB,EAAG8vB,IAAK9pB,GAAK,EAAGmjC,GAAK,EAAG,CAC3B5rB,EAAMwrB,EAActlC,EAAMqsB,IAAIzX,OAC9BirB,EAAK96B,EAASxC,GAAKuC,EAAO4gC,GAAI5F,EAAK/6B,EAASxC,EAAI,GAAKuC,EAAO4gC,EAAI,GAAID,EAAS1gC,EAASxC,EAAI,GAC9FgjC,IAAO1F,EAAK/lB,EAAItX,EAAIs9B,EAAKhmB,EAAIxD,EAAIwD,EAAIpE,IAAM+vB,EAC3CD,IAAO3F,EAAK/lB,EAAIvX,EAAIu9B,EAAKhmB,EAAItD,EAAIsD,EAAInE,IAAM8vB,EAE/CN,EAAc7jB,GAAKikB,EACnBJ,EAAc7jB,EAAI,GAAKkkB,OA/C/B,CACQpgC,EAAYzJ,OAAS,IAAGoJ,EAAWK,GAKvC,IAJA,IAAI0U,EACA/a,GADA+a,EAAMjX,EAAK9C,KAAK6U,QACRc,GACR1W,EAAI8a,EAAInE,GACRnT,EAAIsX,EAAItX,EAAGD,EAAIuX,EAAIxD,EAAGA,EAAIwD,EAAIvX,EAAGiU,EAAIsD,EAAItD,EACpC,EAAInX,EAAOiiB,EAAI8D,EAAQ9D,EAAI5O,EAAO,GAAK,EAAG4O,GAAK8jB,EAAQ,CAC5D,IAAIvF,EAAK96B,EAAS,GAAI+6B,EAAK/6B,EAAS,EAAI,GACxCogC,EAAc7jB,GAAKue,EAAKr9B,EAAIs9B,EAAKv9B,EAAIxD,EACrComC,EAAc7jB,EAAI,GAAKue,EAAKvpB,EAAIwpB,EAAKtpB,EAAIxX,KA2CrD,YAAA2mC,OAAA,SAAQphC,GACc,MAAd/I,KAAKwE,OACLuE,EAAWvE,MAAQ,IAAIsE,MAAc9I,KAAKwE,MAAMrE,QAChD,EAAAyB,MAAMsI,UAAUlK,KAAKwE,MAAO,EAAGuE,EAAWvE,MAAO,EAAGxE,KAAKwE,MAAMrE,SAE/D4I,EAAWvE,MAAQ,KAEF,MAAjBxE,KAAKuJ,UACLR,EAAWQ,SAAW,EAAA3H,MAAMC,cAAc7B,KAAKuJ,SAASpJ,QACxD,EAAAyB,MAAMsI,UAAUlK,KAAKuJ,SAAU,EAAGR,EAAWQ,SAAU,EAAGvJ,KAAKuJ,SAASpJ,SAExE4I,EAAWQ,SAAW,KAE1BR,EAAW4b,oBAAsB3kB,KAAK2kB,oBACtC5b,EAAWY,iBAAmB3J,KAAK2J,kBA7FxB,EAAA8/B,OAAS,EA+F5B,EAhGA,CAA+CD,GAAzB,EAAA9/B,iBAAgB,EAZrB,GAAAlK,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,IACjB,SAAYquB,GACR,uBAAQ,iCAAa,mBAAM,+BAAY,mBAAM,qBAAO,2BADxD,CAAY,EAAAA,iBAAA,EAAAA,eAAc,KADT,GAAAruB,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,kBAGI,WAAaI,GAAb,MACI,YAAMA,IAAK,K,OAHf,EAAAgH,MAAQ,IAAI,EAAA+X,MAAM,EAAG,EAAG,EAAG,G,EAY/B,OAb2C,OAOvC,YAAA4d,KAAA,WACI,IAAIA,EAAO,IAAI7jB,EAAsB9Y,MAGrC,OAFAI,KAAKmqC,OAAO5N,GACZA,EAAK31B,MAAMW,aAAavH,KAAK4G,OACtB21B,GAEf,EAbA,CAA2C,EAAA7yB,kBAA9B,EAAAgP,sBAAqB,EADjB,GAAAlZ,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCDpB,SAAUA,IAAW,SAAAC,GACjB,kBAMI,WAAaI,GAAb,MACI,YAAMA,IAAK,K,OAHf,EAAAgH,MAAQ,IAAI,EAAA+X,MAAM,MAAQ,MAAQ,MAAQ,G,EAa9C,OAjBwC,OAUpC,YAAA4d,KAAA,WACI,IAAIA,EAAO,IAAIvjB,EAAmBpZ,MAIlC,OAHAI,KAAKmqC,OAAO5N,GACZA,EAAKpN,QAAUnvB,KAAKmvB,QACpBoN,EAAK31B,MAAMW,aAAavH,KAAK4G,OACtB21B,GAEf,EAjBA,CAAwC,EAAA7yB,kBAA3B,EAAAsP,mBAAkB,EADd,GAAAxZ,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCCpB,SAAUA,IAAW,SAAAC,GACjB,kBAaI,WAAaI,GAAb,MACI,YAAMA,IAAK,K,OATf,EAAAgH,MAAQ,IAAI,EAAA+X,MAAM,EAAG,EAAG,EAAG,GAM3B,EAAAyrB,UAAY,IAAI,EAAAzrB,MAAM,EAAG,EAAG,EAAG,G,EA8DnC,OAzEoC,OAiBhC,YAAA0rB,cAAA,WACI,OAAOrqC,KAAKsqC,YAIhB,YAAAtd,cAAA,SAAesd,GACXtqC,KAAKsqC,WAAaA,EACA,MAAdA,IACAtqC,KAAKwE,MAAQ8lC,EAAW9lC,MACxBxE,KAAKuJ,SAAW+gC,EAAW/gC,SAC3BvJ,KAAK2kB,oBAAsB2lB,EAAW3lB,oBACtC3kB,KAAKyuB,UAAY6b,EAAW7b,UAC5BzuB,KAAKquB,UAAYic,EAAWjc,UAC5BruB,KAAKuuB,WAAa+b,EAAW/b,WAC7BvuB,KAAK2kB,oBAAsB2lB,EAAW3lB,sBAI9C,YAAA4X,KAAA,WACI,GAAuB,MAAnBv8B,KAAKsqC,WAAoB,OAAOtqC,KAAKs8B,gBAEzC,IAAIC,EAAO,IAAI/jB,EAAexY,KAAKJ,MAsBnC,OArBA28B,EAAKnkB,OAASpY,KAAKoY,OACnBmkB,EAAKpkB,KAAOnY,KAAKmY,KACjBokB,EAAK31B,MAAMW,aAAavH,KAAK4G,OAE7B5G,KAAKmqC,OAAO5N,GACZA,EAAK9N,UAAY,IAAIC,aAAa1uB,KAAKyuB,UAAUtuB,QACjD,EAAAyB,MAAMsI,UAAUlK,KAAKyuB,UAAW,EAAG8N,EAAK9N,UAAW,EAAGzuB,KAAKyuB,UAAUtuB,QACrEo8B,EAAKpO,IAAM,IAAIrlB,MAAc9I,KAAKmuB,IAAIhuB,QACtC,EAAAyB,MAAMsI,UAAUlK,KAAKmuB,IAAK,EAAGoO,EAAKpO,IAAK,EAAGnuB,KAAKmuB,IAAIhuB,QACnDo8B,EAAKlO,UAAY,IAAIvlB,MAAc9I,KAAKquB,UAAUluB,QAClD,EAAAyB,MAAMsI,UAAUlK,KAAKquB,UAAW,EAAGkO,EAAKlO,UAAW,EAAGruB,KAAKquB,UAAUluB,QACrEo8B,EAAKhO,WAAavuB,KAAKuuB,WAGL,MAAdvuB,KAAKwuB,QACL+N,EAAK/N,MAAQ,IAAI1lB,MAAc9I,KAAKwuB,MAAMruB,QAC1C,EAAAyB,MAAMsI,UAAUlK,KAAKwuB,MAAO,EAAG+N,EAAK/N,MAAO,EAAGxuB,KAAKwuB,MAAMruB,SAE7Do8B,EAAKxR,MAAQ/qB,KAAK+qB,MAClBwR,EAAKvR,OAAShrB,KAAKgrB,OAEZuR,GAGX,YAAAD,cAAA,WACI,IAAIC,EAAO,IAAI/jB,EAAexY,KAAKJ,MAOnC,OANA28B,EAAKnkB,OAASpY,KAAKoY,OACnBmkB,EAAKpkB,KAAOnY,KAAKmY,KACjBokB,EAAK31B,MAAMW,aAAavH,KAAK4G,OAC7B21B,EAAK5yB,iBAAmB3J,KAAK2J,iBAC7B4yB,EAAKvP,cAAiC,MAAnBhtB,KAAKsqC,WAAqBtqC,KAAKsqC,WAAatqC,MAExDu8B,GAEf,EAzEA,CAAoC,EAAA7yB,kBAAvB,EAAA8O,eAAc,EADV,GAAAhZ,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACjB,kBAKI,WAAaI,GAAb,MACI,YAAMA,IAAK,K,OAJf,EAAA6kB,QAAS,EAAO,EAAAM,eAAgB,EAChC,EAAAne,MAAQ,IAAI,EAAA+X,MAAM,EAAG,EAAG,EAAG,G,EAgB/B,OAnBoC,OAShC,YAAA4d,KAAA,WACI,IAAIA,EAAO,IAAI3jB,EAAehZ,MAO9B,OANAI,KAAKmqC,OAAO5N,GACZA,EAAK7Z,QAAU,IAAI5Z,MAAc9I,KAAK0iB,QAAQviB,QAC9C,EAAAyB,MAAMsI,UAAUlK,KAAK0iB,QAAS,EAAG6Z,EAAK7Z,QAAS,EAAG1iB,KAAK0iB,QAAQviB,QAC/Do8B,EAAK9X,OAASA,OACd8X,EAAKxX,cAAgB/kB,KAAK+kB,cAC1BwX,EAAK31B,MAAMW,aAAavH,KAAK4G,OACtB21B,GAEf,EAnBA,CAAoC,EAAA7yB,kBAAvB,EAAAkP,eAAc,EADV,GAAApZ,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCDpB,SAAUA,IAAW,SAAAC,GACjB,kBAII,WAAaI,GAAb,MACI,YAAMA,IAAK,K,OAHf,EAAAgH,MAAQ,IAAI,EAAA+X,MAAM,IAAM,IAAM,EAAG,G,EA6BrC,OA/BqC,OAQjC,YAAA4rB,qBAAA,SAAqBhmC,EAAYwqB,GAC7B,IAAMzQ,EAAM/Z,EAAK6U,OAGjB,OAFA2V,EAAMxrB,EAAIvD,KAAKuD,EAAI+a,EAAItX,EAAIhH,KAAKwD,EAAI8a,EAAIxD,EAAIvW,EAAK4a,OACjD4P,EAAMvrB,EAAIxD,KAAKuD,EAAI+a,EAAIvX,EAAI/G,KAAKwD,EAAI8a,EAAItD,EAAIzW,EAAK6a,OAC1C2P,GAGX,YAAAyb,qBAAA,SAAqBjmC,GACjB,IAAM+Z,EAAM/Z,EAAK6U,OACbkD,EAAM,EAAA3Y,UAAUkX,OAAO7a,KAAK2E,UAAW4X,EAAM,EAAA5Y,UAAUoX,OAAO/a,KAAK2E,UACnEpB,EAAI+Y,EAAMgC,EAAItX,EAAIuV,EAAM+B,EAAIxD,EAC5BtX,EAAI8Y,EAAMgC,EAAIvX,EAAIwV,EAAM+B,EAAItD,EAChC,OAAO5U,KAAK4V,MAAMxY,EAAGD,GAAK,EAAAI,UAAUsY,QAGxC,YAAAsgB,KAAA,WACI,IAAIA,EAAO,IAAIzjB,EAAgBlZ,MAK/B,OAJA28B,EAAKh5B,EAAIvD,KAAKuD,EACdg5B,EAAK/4B,EAAIxD,KAAKwD,EACd+4B,EAAK53B,SAAW3E,KAAK2E,SACrB43B,EAAK31B,MAAMW,aAAavH,KAAK4G,OACtB21B,GAEf,EA/BA,CAAqC,EAAA7yB,kBAAxB,EAAAoP,gBAAe,EADX,GAAAtZ,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCCpB,SAAUA,IAAW,SAAAC,GACjB,kBAgEI,WAAYI,GAAZ,MACI,YAAMA,IAAK,K,OAnBf,EAAA2D,EAAI,EACJ,EAAAC,EAAI,EACJ,EAAAsC,OAAS,EACT,EAAAC,OAAS,EACT,EAAApB,SAAW,EACX,EAAAomB,MAAQ,EACR,EAAAC,OAAS,EACT,EAAApkB,MAAQ,IAAI,EAAA+X,MAAM,EAAG,EAAG,EAAG,GAM3B,EAAAiL,OAAS,EAAAhoB,MAAMC,cAAc,GAC7B,EAAAssB,IAAM,EAAAvsB,MAAMC,cAAc,GAE1B,EAAAuoC,UAAY,IAAI,EAAAzrB,MAAM,EAAG,EAAG,EAAG,G,EA2GnC,OAzKsC,OAoElC,YAAA8rB,aAAA,WACI,IAAIC,EAAe1qC,KAAK+qB,MAAQ/qB,KAAKoY,OAAOqpB,cAAgBzhC,KAAK8F,OAC7D6kC,EAAe3qC,KAAKgrB,OAAShrB,KAAKoY,OAAO0mB,eAAiB9+B,KAAK+F,OAC/D6kC,GAAU5qC,KAAK+qB,MAAQ,EAAI/qB,KAAK8F,OAAS9F,KAAKoY,OAAOgU,QAAUse,EAC/DG,GAAU7qC,KAAKgrB,OAAS,EAAIhrB,KAAK+F,OAAS/F,KAAKoY,OAAOiU,QAAUse,EAChEG,EAAUF,EAAS5qC,KAAKoY,OAAO2S,MAAQ2f,EACvCK,EAAUF,EAAS7qC,KAAKoY,OAAO4S,OAAS2f,EACxCK,EAAUhrC,KAAK2E,SAAWyB,KAAKuW,GAAK,IACpCL,EAAMlW,KAAKkW,IAAI0uB,GACfzuB,EAAMnW,KAAKmW,IAAIyuB,GACfC,EAAYL,EAAStuB,EAAMtc,KAAKuD,EAChC2nC,EAAYN,EAASruB,EACrB4uB,EAAYN,EAASvuB,EAAMtc,KAAKwD,EAChC4nC,EAAYP,EAAStuB,EACrB8uB,EAAaP,EAAUxuB,EAAMtc,KAAKuD,EAClC+nC,EAAaR,EAAUvuB,EACvBgvB,EAAaR,EAAUzuB,EAAMtc,KAAKwD,EAClCgoC,EAAaT,EAAUxuB,EACvBqN,EAAS5pB,KAAK4pB,OAClBA,EAAOtR,EAAiBmzB,KAAOR,EAAYG,EAC3CxhB,EAAOtR,EAAiBozB,KAAOP,EAAYD,EAC3CthB,EAAOtR,EAAiBqzB,KAAOV,EAAYO,EAC3C5hB,EAAOtR,EAAiBszB,KAAOL,EAAaL,EAC5CthB,EAAOtR,EAAiBuzB,KAAOR,EAAaG,EAC5C5hB,EAAOtR,EAAiBwzB,KAAOP,EAAaD,EAC5C1hB,EAAOtR,EAAiByzB,KAAOV,EAAaD,EAC5CxhB,EAAOtR,EAAiB0zB,KAAOb,EAAYG,GAG/C,YAAAW,UAAA,SAAU7zB,GACNpY,KAAKoY,OAASA,EACd,IAAI+V,EAAMnuB,KAAKmuB,IACX/V,EAAOnU,QACPkqB,EAAI,GAAK/V,EAAOyI,EAChBsN,EAAI,GAAK/V,EAAOge,GAChBjI,EAAI,GAAK/V,EAAOyI,EAChBsN,EAAI,GAAK/V,EAAOyY,EAChB1C,EAAI,GAAK/V,EAAO+d,GAChBhI,EAAI,GAAK/V,EAAOyY,EAChB1C,EAAI,GAAK/V,EAAO+d,GAChBhI,EAAI,GAAK/V,EAAOge,KAEhBjI,EAAI,GAAK/V,EAAOyI,EAChBsN,EAAI,GAAK/V,EAAOge,GAChBjI,EAAI,GAAK/V,EAAOyI,EAChBsN,EAAI,GAAK/V,EAAOyY,EAChB1C,EAAI,GAAK/V,EAAO+d,GAChBhI,EAAI,GAAK/V,EAAOyY,EAChB1C,EAAI,GAAK/V,EAAO+d,GAChBhI,EAAI,GAAK/V,EAAOge,KAIxB,YAAAhR,qBAAA,SAAqB7gB,EAAYolC,EAAkC/f,EAAgBggB,GAC/E,IAAI5T,EAAeh2B,KAAK4pB,OACpBtL,EAAM/Z,EAAK6U,OACX7V,EAAI+a,EAAIpE,GAAI1W,EAAI8a,EAAInE,GACpBnT,EAAIsX,EAAItX,EAAGD,EAAIuX,EAAIxD,EAAGA,EAAIwD,EAAIvX,EAAGiU,EAAIsD,EAAItD,EACzCoR,EAAU,EAAGC,EAAU,EAE3BD,EAAU4J,EAAa1d,EAAiBmzB,KACxCpf,EAAU2J,EAAa1d,EAAiBozB,KACxC/B,EAAc/f,GAAUwC,EAAUplB,EAAIqlB,EAAUtlB,EAAIxD,EACpDomC,EAAc/f,EAAS,GAAKwC,EAAUtR,EAAIuR,EAAUrR,EAAIxX,EACxDomB,GAAUggB,EAEVxd,EAAU4J,EAAa1d,EAAiBqzB,KACxCtf,EAAU2J,EAAa1d,EAAiBszB,KACxCjC,EAAc/f,GAAUwC,EAAUplB,EAAIqlB,EAAUtlB,EAAIxD,EACpDomC,EAAc/f,EAAS,GAAKwC,EAAUtR,EAAIuR,EAAUrR,EAAIxX,EACxDomB,GAAUggB,EAEVxd,EAAU4J,EAAa1d,EAAiBuzB,KACxCxf,EAAU2J,EAAa1d,EAAiBwzB,KACxCnC,EAAc/f,GAAUwC,EAAUplB,EAAIqlB,EAAUtlB,EAAIxD,EACpDomC,EAAc/f,EAAS,GAAKwC,EAAUtR,EAAIuR,EAAUrR,EAAIxX,EACxDomB,GAAUggB,EAEVxd,EAAU4J,EAAa1d,EAAiByzB,KACxC1f,EAAU2J,EAAa1d,EAAiB0zB,KACxCrC,EAAc/f,GAAUwC,EAAUplB,EAAIqlB,EAAUtlB,EAAIxD,EACpDomC,EAAc/f,EAAS,GAAKwC,EAAUtR,EAAIuR,EAAUrR,EAAIxX,GAG5D,YAAA+4B,KAAA,WACI,IAAIA,EAAO,IAAIjkB,EAAiBtY,KAAKJ,MAcrC,OAbA28B,EAAKnkB,OAASpY,KAAKoY,OACnBmkB,EAAK2P,eAAiBlsC,KAAKksC,eAC3B3P,EAAKpkB,KAAOnY,KAAKmY,KACjBokB,EAAKh5B,EAAIvD,KAAKuD,EACdg5B,EAAK/4B,EAAIxD,KAAKwD,EACd+4B,EAAKz2B,OAAS9F,KAAK8F,OACnBy2B,EAAKx2B,OAAS/F,KAAK+F,OACnBw2B,EAAK53B,SAAW3E,KAAK2E,SACrB43B,EAAKxR,MAAQ/qB,KAAK+qB,MAClBwR,EAAKvR,OAAShrB,KAAKgrB,OACnB,EAAAppB,MAAMsI,UAAUlK,KAAKmuB,IAAK,EAAGoO,EAAKpO,IAAK,EAAG,GAC1C,EAAAvsB,MAAMsI,UAAUlK,KAAK4pB,OAAQ,EAAG2S,EAAK3S,OAAQ,EAAG,GAChD2S,EAAK31B,MAAMW,aAAavH,KAAK4G,OACtB21B,GAtKJ,EAAAkP,IAAM,EACN,EAAAC,IAAM,EACN,EAAAC,IAAM,EACN,EAAAC,IAAM,EACN,EAAAC,IAAM,EACN,EAAAC,IAAM,EACN,EAAAC,IAAM,EACN,EAAAC,IAAM,EAEN,EAAAG,GAAK,EACL,EAAAC,GAAK,EACL,EAAAC,IAAM,EACN,EAAAC,IAAM,EACN,EAAAC,IAAM,EACN,EAAAC,IAAM,EACN,EAAAC,GAAK,EACL,EAAAC,GAAK,EAEL,EAAAC,GAAK,EACL,EAAAC,GAAK,EACL,EAAAC,IAAM,GACN,EAAAC,IAAM,GACN,EAAAC,IAAM,GACN,EAAAC,IAAM,GACN,EAAAC,GAAK,GACL,EAAAC,GAAK,GAEL,EAAAC,GAAK,GACL,EAAAC,GAAK,GACL,EAAAC,IAAM,GACN,EAAAC,IAAM,GACN,EAAAC,IAAM,GACN,EAAAC,IAAM,GACN,EAAAC,GAAK,GACL,EAAAC,GAAK,GAEL,EAAAC,GAAK,GACL,EAAAC,GAAK,GACL,EAAAC,IAAM,GACN,EAAAC,IAAM,GACN,EAAAC,IAAM,GACN,EAAAC,IAAM,GACN,EAAAC,GAAK,GACL,EAAAC,GAAK,GA6HhB,EAzKA,CAAsC,EAAA1E,YAAzB,EAAAlxB,iBAAgB,EADZ,GAAA9Y,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCDpB,SAAUA,IAAW,SAAAC,GACpB,iBAIC,WAAa2uC,EAAiBC,GAH9B,KAAAD,QAAU,EACV,KAAAC,QAAU,EAGTpuC,KAAKmuC,QAAUA,EACfnuC,KAAKouC,QAAUA,EAajB,OAVC,YAAAC,MAAA,SAAM7tC,KAGN,YAAA65B,UAAA,SAAU1sB,EAAmB2gC,EAAahmC,EAAcC,GACvDoF,EAASpK,GAAK,EAAAI,UAAUijC,kBAAkB5mC,KAAKmuC,QAASnuC,KAAKouC,SAC7DzgC,EAASnK,GAAK,EAAAG,UAAUijC,kBAAkB5mC,KAAKmuC,QAASnuC,KAAKouC,UAG9D,YAAAz+B,IAAA,aAED,EAnBA,GAAa,EAAA4+B,aAAY,EADL,GAAA/uC,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KCApB,SAAUA,IAAW,SAAAC,GACpB,iBASC,WAAagvC,GAPb,KAAAC,QAAU,EACV,KAAAC,QAAU,EACV,KAAAF,OAAS,EACT,KAAAG,MAAQ,EACA,KAAAxvB,OAAS,EACT,KAAAC,OAAS,EAGhBpf,KAAKwuC,OAASA,EAwBhB,OArBC,YAAAH,MAAA,SAAM7tC,GACLR,KAAKmf,OAAS3e,EAAS+C,EAAIvD,KAAKyuC,QAChCzuC,KAAKof,OAAS5e,EAASgD,EAAIxD,KAAK0uC,SAGjC,YAAArU,UAAA,SAAU1sB,EAAmB2gC,EAAahmC,EAAcC,GACvD,IAAIqmC,EAAW5uC,KAAK2uC,MAAQ,EAAAhrC,UAAUsjC,iBAClC1jC,EAAIoK,EAASpK,EAAIvD,KAAKmf,OACtB3b,EAAImK,EAASnK,EAAIxD,KAAKof,OACtByvB,EAAOzoC,KAAKsW,KAAKnZ,EAAIA,EAAIC,EAAIA,GACjC,GAAIqrC,EAAO7uC,KAAKwuC,OAAQ,CACvB,IAAIM,EAAQC,EAAYC,cAAczuC,MAAM,EAAGquC,GAAW5uC,KAAKwuC,OAASK,GAAQ7uC,KAAKwuC,QACjFlyB,EAAMlW,KAAKkW,IAAIwyB,GACfvyB,EAAMnW,KAAKmW,IAAIuyB,GACnBnhC,EAASpK,EAAI+Y,EAAM/Y,EAAIgZ,EAAM/Y,EAAIxD,KAAKmf,OACtCxR,EAASnK,EAAI+Y,EAAMhZ,EAAI+Y,EAAM9Y,EAAIxD,KAAKof,SAIxC,YAAAzP,IAAA,aA/BO,EAAAq/B,cAAgB,IAAI,EAAA1H,OAAO,GAiCnC,EAlCA,GAAa,EAAAyH,YAAW,EADJ,GAAAvvC,OAAA,EAAAA,KAAI,KAAzB,CAAUD,MAAU,KC1BpB,WAEqC,IAASiwB,EADrCppB,KAAK4hC,SACN5hC,KAAK4hC,OAAS5hC,KAAK4hC,QAAmBxY,EAInC,IAAId,aAAa,GAHT,SAASnrB,GACZ,OAAOisB,EAAM,GAAKjsB,EAAGisB,EAAM,MAJ3C,GCDA,SAAUjwB,GAEN,EAAAC,KAAKkb,KAAKC,OAAQ,EAElB,IAAIs0B,EAAU,CAAC,EAAG,EAAG,GAOrB,yE,OACI,EAAA72B,OAA8B,KAC9B,EAAArP,WAA+B,K,EACnC,OAHiC,OAGjC,EAHA,CAAiCsQ,KAAK61B,QAAzB,EAAAC,YAAW,EAKxB,IAAMC,EAAK/1B,KAAKg2B,iBAAiBC,UACjC,IAAKF,EAAGG,WAAY,CAChB,IAAI,EAAM,GACVH,EAAGG,WAAa,WACZ,IAAMC,EAAIxvC,KAAKyvC,aACf,EAAI/kC,KAAK,GACT1K,KAAKyvC,aAAe,EACpBzvC,KAAK6U,QACL7U,KAAKyvC,aAAeD,GAI5B,kBAII,WAAYnR,EAAuB90B,EAAyB4kB,EAAoByV,EAAuB8L,GAAvG,MACI,YAAMrR,EAAS90B,EAAU4kB,EAAKyV,EAAS8L,IAAS,K,OAJpD,EAAAt3B,OAA8B,KAC9B,EAAArP,WAA+B,K,EAKnC,OAP+B,OAO/B,EAPA,CAA+BsQ,KAAKs2B,YAAvB,EAAAC,UAAS,EAuBtB,kBAeI,WAAYC,GAAZ,MACI,cAAO,KAEP,IAAKA,EACD,MAAM,IAAI9vC,MAAM,oCAGpB,GAA2B,kBAAf8vC,EACR,MAAM,IAAI9vC,MAAM,uGAQpB,EAAK8vC,UAAYA,EAOjB,EAAKrvC,SAAW,IAAI,EAAAhB,KAAK0qB,SAAS2lB,GAClC,EAAKrvC,SAAS8Z,uBAOd,EAAKw1B,UAAY,IAAI,EAAAtwC,KAAKsY,mBAAmB+3B,GAO7C,EAAKE,MAAQ,IAAI,EAAAvwC,KAAK6R,eAAe,EAAKy+B,WAO1C,EAAKE,eAAiB,GAEtB,EAAKC,mBAAqB,GAE1B,IAAK,IAAI/vC,EAAI,EAAGa,EAAI,EAAKP,SAAS8G,MAAMnH,OAAQD,EAAIa,EAAGb,IAAK,CACxD,IAAImH,EAAO,EAAK7G,SAAS8G,MAAMpH,GAC3B6I,EAAkB1B,EAAK6B,gBACvBgnC,EAAgB,EAAKC,eAKzB,GAJA,EAAKH,eAAetlC,KAAKwlC,GACzB,EAAKE,SAASF,GACd,EAAKD,mBAAmBvlC,KAAK,MAEzB3B,aAAsB,EAAAvJ,KAAK8Y,iBAAkB,CAC7C,IAAI+3B,EAActnC,EAAWqP,OAAmCxY,KAC5D0wC,EAAS,EAAKC,aAAalpC,EAAM0B,EAAYsnC,GACjDhpC,EAAKmpC,cAAgBF,EACrBjpC,EAAKopC,kBAAoBJ,EACzBH,EAAcE,SAASE,QAEtB,GAAIvnC,aAAsB,EAAAvJ,KAAKgZ,eAAgB,CAChD,IAAIwR,EAAO,EAAK0mB,WAAWrpC,EAAM0B,GACjC1B,EAAKspC,YAAc3mB,EACnB3iB,EAAKupC,gBAAkB7nC,EAAWnJ,KAClCswC,EAAcE,SAASpmB,OAEtB,MAAIjhB,aAAsB,EAAAvJ,KAAKwZ,oBAMhC,SALA,EAAK63B,eAAexpC,EAAM0B,GAC1BmnC,EAAcE,SAAS/oC,EAAKypC,mBAC5BZ,EAAcE,SAAS/oC,EAAK0pC,kB,OAcpC,EAAKC,QAAU,IAAItiB,aAAa,CAAC,EAAG,EAAG,IAEvC,EAAKuiB,YAAa,EAClB,EAAKC,SAAU,E,EA+mBvB,OAxtB2B,OAuHvB,sBAAI,yBAAU,C,IAAd,WACI,OAAOlxC,KAAKmxC,a,IAGhB,SAAe3jC,GACPA,IAAUxN,KAAKmxC,cACfnxC,KAAKmxC,YAAc3jC,EACnBxN,KAAKoxC,gBAAkB5jC,EAAQ6jC,EAAM/B,UAAUgC,oBAAsBj4B,KAAKk4B,UAAUjC,UAAU8B,kB,gCAYtG,sBAAI,sBAAO,C,IAAX,WACI,OAAOpxC,KAAKwxC,U,IAGhB,SAAYhkC,GACJA,IAAUxN,KAAKwxC,WACfxxC,KAAKwxC,SAAWhkC,EACZA,IACAxN,KAAKS,SAAW,K,gCAY5B,sBAAI,mBAAI,C,IAAR,WACI,OAAO4Y,KAAKo4B,MAAMC,QAAQ1xC,KAAKgxC,U,IAGnC,SAASxjC,GACLxN,KAAKgxC,QAAU33B,KAAKo4B,MAAME,QAAQnkC,EAAOxN,KAAKgxC,U,gCAQlD,sBAAI,yBAAU,C,IAAd,WAKI,OAJ4C,qBAAzBhxC,KAAK4xC,gBACpB5xC,KAAK4xC,gBAAiBP,EAAMQ,mBAGhBrnC,OAAOC,W,gCAQ3B,YAAArM,OAAA,SAAO0zC,GAEH,IAAIC,EAAa/xC,KAAK+xC,WAOtB,GANID,EAAKC,IAAYD,EAAKC,GAE1B/xC,KAAK+vC,MAAM3xC,OAAO0zC,GAClB9xC,KAAK+vC,MAAMxvC,MAAMP,KAAKQ,UAGlBR,KAAKQ,SAAT,CAGAR,KAAKQ,SAAS8Z,uBAEd,IAAIhT,EAAQtH,KAAKQ,SAAS8G,MAGtB0qC,EAAahyC,KAAa4G,MAC1B0B,EAA2B,KAAMC,EAA0B,KAE3DypC,GACA1pC,EAAQ0pC,EAAU1pC,MAClBC,EAAOypC,EAAUzpC,MAEjBD,EAAQtI,KAAKgxC,QAKjB,IAFA,IAES9wC,EAAI,EAAGa,EAAIuG,EAAMnH,OAAQD,EAAIa,EAAGb,IAAK,CAC1C,IACI6I,GADA1B,EAAOC,EAAMpH,IACKgJ,gBAClBgnC,EAAgBlwC,KAAKgwC,eAAe9vC,GAExC,GAAK6I,EAAL,CAKA,IAAIkpC,EAAmB,KAEnBC,EAAYnpC,EAAmBnC,MACnC,GAAImC,aAAsB,EAAAvJ,KAAK8Y,iBAAkB,CAC7C,IAAIF,EAAUrP,EAAqCqP,OACnD,GAAIA,EAAQ,CACJ/Q,EAAKspC,cACLtpC,EAAKspC,YAAYO,SAAU,EAC3B7pC,EAAKspC,YAAc,KACnBtpC,EAAKupC,qBAAkB54B,GAE3B,IAAIm6B,EAAK/5B,EACT,GAAK/Q,EAAKopC,mBAAqBppC,EAAKopC,oBAAsB0B,EAAGvyC,KAkBlDyH,EAAKopC,oBAAsB0B,EAAGvyC,MAASyH,EAAK+qC,YACnDpyC,KAAKqyC,gBAAgBtpC,EAAY1B,EAAKmpC,cAAep4B,OAnBU,CAC/D,IAAIi4B,EAAa8B,EAAGvyC,KAKpB,GAJIyH,EAAKmpC,gBACLnpC,EAAKmpC,cAAcU,SAAU,GAEjC7pC,EAAKirC,QAAUjrC,EAAKirC,SAAW,QACEt6B,IAA7B3Q,EAAKirC,QAAQjC,GACbhpC,EAAKirC,QAAQjC,GAAYa,SAAU,MAElC,CACD,IAAIZ,EAAStwC,KAAKuwC,aAAalpC,EAAM0B,EAAYsnC,GACjDH,EAAcE,SAASE,GAE3BjpC,EAAKmpC,cAAgBnpC,EAAKirC,QAAQjC,GAClChpC,EAAKopC,kBAAoBJ,IAS7BhW,EAAY6V,EAAc7V,WACpBkY,cAAclrC,EAAK9C,KAAK6U,QAE9B/R,EAAKmpC,cAAc5pC,MAEnBqrC,EAAc5qC,EAAKmpC,cAAc5pC,OAEjCqoC,EAAQ,GAAK3mC,EAAM,GAAKjB,EAAKT,MAAMtB,EAAI4sC,EAAS5sC,EAChD2pC,EAAQ,GAAK3mC,EAAM,GAAKjB,EAAKT,MAAME,EAAIorC,EAASprC,EAChDmoC,EAAQ,GAAK3mC,EAAM,GAAKjB,EAAKT,MAAMG,EAAImrC,EAASnrC,EAChDM,EAAKmpC,cAAcgC,KAAOn5B,KAAKo4B,MAAMC,QAAQzC,IAEjD5nC,EAAKmpC,cAAczkB,UAAY1kB,EAAK0kB,eAEnC,GAAIhjB,aAAsB,EAAAvJ,KAAKgZ,eAAgB,CAQ5C,IAAM6hB,EAPV,GAAIhzB,EAAKmpC,cAELnpC,EAAKmpC,cAAcU,SAAU,EAC7B7pC,EAAKmpC,cAAgB,KACrBnpC,EAAKopC,uBAAoBz4B,GAGnBqiB,EAAY,IAAIhhB,KAAKo5B,WACRC,WAAa,EAC/BrY,EAAkBsY,SAAYzC,EAAc7V,UAAkBsY,SAC/DzC,EAAc7V,UAAYA,EAE9B,IAAKhzB,EAAKupC,iBAAmBvpC,EAAKupC,kBAAoB7nC,EAAWnJ,KAAM,CACnE,IAAIgzC,EAAW7pC,EAAWnJ,KAO1B,GANIyH,EAAKspC,cACLtpC,EAAKspC,YAAYO,SAAU,GAG/B7pC,EAAKwrC,OAASxrC,EAAKwrC,QAAU,QAEC76B,IAA1B3Q,EAAKwrC,OAAOD,GACZvrC,EAAKwrC,OAAOD,GAAU1B,SAAU,MAE/B,CACD,IAAIlnB,EAAOhqB,KAAK0wC,WAAWrpC,EAAM0B,GACjCmnC,EAAcE,SAASpmB,GAG3B3iB,EAAKspC,YAActpC,EAAKwrC,OAAOD,GAC/BvrC,EAAKupC,gBAAkBgC,EAE1B7pC,EAAqC2gC,wBAAwBriC,EAAMA,EAAKspC,YAAYpnC,UACjFlC,EAAKspC,YAAY/pC,MAEjBqrC,EAAc5qC,EAAKspC,YAAY/pC,OAE/BqoC,EAAQ,GAAK3mC,EAAM,GAAKjB,EAAKT,MAAMtB,EAAI4sC,EAAS5sC,EAChD2pC,EAAQ,GAAK3mC,EAAM,GAAKjB,EAAKT,MAAME,EAAIorC,EAASprC,EAChDmoC,EAAQ,GAAK3mC,EAAM,GAAKjB,EAAKT,MAAMG,EAAImrC,EAASnrC,EAChDM,EAAKspC,YAAY6B,KAAOn5B,KAAKo4B,MAAMC,QAAQzC,IAE/C5nC,EAAKspC,YAAY5kB,UAAY1kB,EAAK0kB,cAEjC,MAAIhjB,aAAsB,EAAAvJ,KAAKwZ,oBAQ/B,CACDk3B,EAAcgB,SAAU,EACxB,SATK7pC,EAAK0pC,kBACN/wC,KAAK6wC,eAAexpC,EAAM0B,GAC1BmnC,EAAcE,SAAS/oC,EAAKypC,mBAC5BZ,EAAcE,SAAS/oC,EAAK0pC,kBAEhC/wC,KAAK8yC,eAAezrC,EAAM0B,GAS9B,GAHAmnC,EAAcgB,SAAU,EAGpBe,EAAa,CACb,IAAIrwB,EAAKva,EAAKT,MAAMtB,EAAI4sC,EAAS5sC,EAC7BytC,EAAK1rC,EAAKT,MAAME,EAAIorC,EAASprC,EAC7BksC,EAAK3rC,EAAKT,MAAMG,EAAImrC,EAASnrC,EAGjCkrC,EAAYgB,SACR3qC,EAAM,GAAKsZ,EAAKrZ,EAAK,IAAM,EAAMqZ,GACjCtZ,EAAM,GAAKyqC,EAAKxqC,EAAK,IAAM,EAAMwqC,GACjCzqC,EAAM,GAAK0qC,EAAKzqC,EAAK,IAAM,EAAMyqC,IAEjC3rC,EAAKgB,WACLuZ,EAAKva,EAAKgB,UAAU/C,EACpBytC,EAAK1rC,EAAKgB,UAAUvB,EACpBksC,EAAK3rC,EAAKgB,UAAUtB,IAEpB6a,EAAK,EACLmxB,EAAK,EACLC,EAAK,GAETf,EAAYiB,QACR5qC,EAAM,GAAKsZ,EAAKrZ,EAAK,IAAM,EAAIqZ,GAC/BtZ,EAAM,GAAKyqC,EAAKxqC,EAAK,IAAM,EAAIwqC,GAC/BzqC,EAAM,GAAK0qC,EAAKzqC,EAAK,IAAM,EAAIyqC,IAIvC9C,EAActvC,MAAQyG,EAAKT,MAAMI,OA3I7BkpC,EAAcgB,SAAU,EAgJhC,IAAIrmC,EAAY7K,KAAKQ,SAASqK,UAC1BsoC,EAA8C,KAC9CrC,EAAoC,KAExC,IAAS5wC,EAAI,EAAGa,EAAI8J,EAAU1K,OAAQD,EAAIa,EAAGb,IAAK,CAC9C,IAAImH,EAAOC,EAAMuD,EAAU3K,GAAG0E,KAAKrC,OAC/B2tC,EAAgBlwC,KAAKgwC,eAAenlC,EAAU3K,GAAG0E,KAAKrC,OAU1D,GARKuuC,GAE4B,OAAzBZ,EAAc/2B,QAAmB+2B,EAAc/2B,SAAWnZ,OAC1DkwC,EAAc/2B,OAAOi6B,YAAYlD,GAEhCA,EAAsB/2B,OAASnZ,MAGpCqH,EAAK0pC,iBAAmB1pC,EAAK6B,gBAC7B4nC,EAAoBzpC,EAAKypC,kBACzBqC,EAAqB9rC,EAAK6B,gBAC1B4nC,EAAkBv3B,SAASpZ,OAAS,EACpCH,KAAKuZ,SAASrZ,GAAKgwC,EAEfiD,EAAmBhkB,SAAW9nB,EAAKzC,OACnCuuC,EAAmBhkB,QAAU,WAIjC,GAAI2hB,EAAmB,CACnB,IAAIh2B,EAAI9a,KAAKiwC,mBAAmB/vC,GAC3B4a,KACDA,EAAI9a,KAAKiwC,mBAAmB/vC,GAAKF,KAAKmwC,gBACpCe,SAAU,GAEhBlxC,KAAKuZ,SAASrZ,GAAK4a,EAGlBo1B,EAAsB/2B,OAAS,KAChC23B,EAAkBV,SAASF,GACvBiD,EAAmBhkB,SAAW9nB,EAAKzC,OACnCksC,EAAkBuC,YAAa,EAC/BvC,EAAoB,KACpBqC,EAAqB,WAGzBnzC,KAAKuZ,SAASrZ,GAAKgwC,KAM3B,YAAAmC,gBAAR,SAAwBtpC,EAAmCunC,EAAqBl4B,GAEzEk4B,EAAOvnC,aAAeA,GAAcunC,EAAOl4B,SAAWA,IAIzDk4B,EAAOl4B,OAASA,EAChBk4B,EAAOvnC,WAAaA,EAEpBunC,EAAOjS,QAAUjmB,EAAOimB,QACxBiS,EAAO3rC,SAAWoE,EAAWpE,SAAW,EAAAnF,KAAKmE,UAAUygB,OACvDksB,EAAO3iC,SAASpK,EAAIwF,EAAWxF,EAC/B+sC,EAAO3iC,SAASnK,EAAIuF,EAAWvF,EAC/B8sC,EAAO1vC,MAAQmI,EAAWnC,MAAMI,EAE3BoR,EAAOyR,MAKRymB,EAAOzqC,MAAMtC,EAAI6U,EAAOyR,KAAKkB,MAAQ3S,EAAOqpB,cAC5C6O,EAAOzqC,MAAMrC,GAAK4U,EAAOyR,KAAKmB,OAAS5S,EAAO0mB,iBAL9CwR,EAAOzqC,MAAMtC,EAAIwF,EAAWjD,OAASiD,EAAWgiB,MAAQ3S,EAAOqpB,cAC/D6O,EAAOzqC,MAAMrC,GAAKuF,EAAWhD,OAASgD,EAAWiiB,OAAS5S,EAAO0mB,kBAQjE,YAAAwU,cAAR,SAAsBvqC,EAAiCihB,EAAiB5R,GAEjE4R,EAAKjhB,aAAeA,GAAcihB,EAAK5R,SAAWA,IAIrD4R,EAAK5R,OAASA,EACd4R,EAAKjhB,WAAaA,EAClBihB,EAAKqU,QAAUjmB,EAAOimB,QACtBjmB,EAAOimB,QAAQuD,YACf5X,EAAKupB,SAASn1C,OAAO2K,EAAW0lB,aAUpC,YAAA6iB,oBAAA,WACI,GAAID,EAAMmC,iBAAkB,CACxBxzC,KAAKS,SAAWT,KAAKS,UAAYmoC,KAAKC,MACtC,IAAI4K,EAA2C,MAA9B7K,KAAKC,MAAQ7oC,KAAKS,UACnCT,KAAKS,SAAWmoC,KAAKC,MACrB7oC,KAAK5B,OAAOq1C,QAEZzzC,KAAKS,SAAW,EAGpB4Y,KAAKk4B,UAAUjC,UAAU8B,gBAAgBsC,KAAK1zC,OAUlD,YAAAuwC,aAAA,SAAalpC,EAAiB0B,EAAmC4qC,GAC7D,IAAIv7B,EAASrP,EAAWqP,OACpB/Q,EAAKusC,iBAAmB7qC,IACxBqP,EAAS/Q,EAAK+qC,YAElB,IAAI/T,EAAUjmB,EAAOimB,QACjBiS,EAAStwC,KAAK6zC,UAAUxV,GAO5B,OALAiS,EAAOwD,OAAOlsC,IAAI,IAClB5H,KAAKqyC,gBAAgBtpC,EAAYunC,EAAQvnC,EAAWqP,QAEpD/Q,EAAKirC,QAAUjrC,EAAKirC,SAAW,GAC/BjrC,EAAKirC,QAAQqB,GAAWrD,EACjBA,GASX,YAAAI,WAAA,SAAWrpC,EAAiB0B,GACxB,IAAIqP,EAASrP,EAAWqP,OACpB/Q,EAAKusC,iBAAmB7qC,IACxBqP,EAAS/Q,EAAK+qC,WACd/qC,EAAKusC,eAAiB,KACtBvsC,EAAK+qC,WAAa,MAEtB,IAAI2B,EAAQ/zC,KAAKg0C,QACb57B,EAAOimB,QACP,IAAI3P,aAAa3lB,EAAW0lB,UAAUtuB,QACtC4I,EAAW0lB,UACX,IAAIwlB,YAAYlrC,EAAWslB,WAC3BhV,KAAK66B,WAAWC,WAapB,MAX6C,qBAAjCJ,EAAcK,iBACrBL,EAAcK,eAAiB,KAGpCL,EAAMnzC,MAAQmI,EAAWnC,MAAMI,EAE/B+sC,EAAM37B,OAASrP,EAAWqP,OAC1BpY,KAAKszC,cAAcvqC,EAAYgrC,EAAO37B,GAEtC/Q,EAAKwrC,OAASxrC,EAAKwrC,QAAU,GAC7BxrC,EAAKwrC,OAAO9pC,EAAWnJ,MAAQm0C,EACxBA,GAKX,YAAAlD,eAAA,SAAexpC,EAAiB6nB,GAC5B,IAAImlB,EAAWr0C,KAAKs0C,cAChBC,EAAO,IAAIl7B,KAAKm7B,QAAQ,IAS5B,OARAH,EAASx/B,QACTw/B,EAASI,UAAU,SAAU,GAC7BJ,EAASK,YAAYH,GACrBF,EAAShB,YAAa,EACtBhsC,EAAK0pC,gBAAkBsD,EACvBhtC,EAAKypC,kBAAoB9wC,KAAKmwC,eAC9B9oC,EAAKypC,kBAAkB6D,KAAOttC,EAAK0pC,gBAE5BsD,GAGX,YAAAvB,eAAA,SAAezrC,EAAiB6nB,GAC5B,IAAI0lB,EAAOvtC,EAAK0pC,gBAAgB8D,SAC5BtrC,EAAYqrC,EAAKnF,aAAa,GAAGqF,MAAuBC,OACxDh0C,EAAImuB,EAAKvK,oBACbpb,EAASpJ,OAASY,EAClBmuB,EAAK9J,qBAAqB/d,EAAM,EAAGtG,EAAGwI,EAAU,EAAG,GACnDqrC,EAAKrF,cAaT,YAAAyF,uBAAA,SAAuBnuC,EAAmBw3B,EAA8BxU,QAA9B,IAAAwU,MAAA,WAA8B,IAAAxU,MAAA,MACpE,IAAIxiB,EAAOrH,KAAKQ,SAAS8G,MAAMT,GAC/B,IAAKQ,EACD,OAAO,EAEX,IAAI0B,EAAkB1B,EAAK6B,gBACvBkP,EAA6BrP,EAAWqP,OAiB5C,OAhBIimB,IACAjmB,EAAS,IAAI,EAAA5Y,KAAKu/B,eACXV,QAAUA,EACjBjmB,EAAOyR,KAAOA,EACdxiB,EAAK+qC,WAAah6B,EAClB/Q,EAAKusC,eAAiB7qC,IAEtB1B,EAAK+qC,WAAa,KAClB/qC,EAAKusC,eAAiB,MAEtBvsC,EAAKmpC,eAAiBnpC,EAAKmpC,cAAcp4B,QAAUA,GACnDpY,KAAKqyC,gBAAgBtpC,EAAY1B,EAAKmpC,cAAep4B,GACrD/Q,EAAKmpC,cAAcp4B,OAASA,GACrB/Q,EAAKspC,aAAetpC,EAAKspC,YAAYv4B,QAAUA,GACtDpY,KAAKszC,cAAcvqC,EAAY1B,EAAKspC,YAAav4B,IAE9C,GAaX,YAAA68B,sBAAA,SAAsBnsB,EAAkBuV,EAA8BxU,QAA9B,IAAAwU,MAAA,WAA8B,IAAAxU,MAAA,MAClE,IAAItnB,EAAQvC,KAAKQ,SAASuoB,cAAcD,GACxC,OAAc,GAAVvmB,GAGGvC,KAAKg1C,uBAAuBzyC,EAAO87B,EAASxU,IAcvD,YAAAqrB,sBAAA,SAAsBpsB,EAAkB9f,EAAwBq1B,EAASxU,QAAA,IAAAA,MAAA,MAErE,IAAMhjB,EAAY7G,KAAKQ,SAASuoB,cAAcD,GACxC/f,EAAkB/I,KAAKQ,SAAS8oB,oBAAoBR,EAAU9f,GACpED,EAAWqP,OAAOimB,QAAUA,EAE5B,IAAMh3B,EAAOrH,KAAKQ,SAAS8G,MAAMT,GACjC,IAAKQ,EACD,OAAO,EAIX,IAAM8tC,EAAyB9tC,EAAK6B,gBACpC,GAAIF,IAAmBmsC,EAAkBv1C,KAAM,CAE3C,IAAIwY,EAA6BrP,EAAWqP,OAiB5C,OAhBIimB,IACAjmB,EAAS,IAAI,EAAA5Y,KAAKu/B,eACXV,QAAUA,EACjBjmB,EAAOyR,KAAOA,EACdxiB,EAAK+qC,WAAah6B,EAClB/Q,EAAKusC,eAAiBuB,IAEtB9tC,EAAK+qC,WAAa,KAClB/qC,EAAKusC,eAAiB,MAEtBvsC,EAAKmpC,eAAiBnpC,EAAKmpC,cAAcp4B,QAAUA,GACnDpY,KAAKqyC,gBAAgB8C,EAAmB9tC,EAAKmpC,cAAep4B,GAC5D/Q,EAAKmpC,cAAcp4B,OAASA,GACrB/Q,EAAKspC,aAAetpC,EAAKspC,YAAYv4B,QAAUA,GACtDpY,KAAKszC,cAAc6B,EAAmB9tC,EAAKspC,YAAav4B,IAErD,EAEX,OAAO,GAIX,YAAA+3B,aAAA,WACI,OAAO,IAAI92B,KAAKk4B,WAGpB,YAAAsC,UAAA,SAAUzV,GACN,OAAO,IAAI+Q,EAAY/Q,IAG3B,YAAAkW,YAAA,WACI,OAAO,IAAIj7B,KAAK+7B,UAGpB,YAAApB,QAAA,SAAQ3V,EAAuB90B,EAAyB4kB,EAAoByV,EAAuB8L,GAC/F,OAAO,IAAIE,EAAUvR,EAAS90B,EAAU4kB,EAAKyV,EAAS8L,IAG1D,YAAA2F,cAAA,WACI,OAAO,GASX,YAAAC,qBAAA,SAAqBC,EAAoBC,EAAYC,GACjD,GAAKF,EAAL,CAIA,IADA,IAAMG,EAAS,GAAIC,EAAS,GACnBz1C,EAAI,EAAGsoC,EAAMxoC,KAAKQ,SAAS8G,MAAMnH,OAAQD,EAAIsoC,EAAKtoC,IAAK,CAC5D,IAAMmH,EAAOrH,KAAKQ,SAAS8G,MAAMpH,GAC3B,EAAOmH,EAAKopC,mBAAqBppC,EAAKupC,iBAAmB,GACzD1vC,EAASmG,EAAKmpC,eAAiBnpC,EAAKspC,YACvC,EAAKiF,SAASL,IACbr0C,EAAO20C,YAAcL,EACrBG,EAAOjrC,KAAKxJ,IACPu0C,GAAYv0C,IACjBA,EAAO20C,YAAcJ,EACrBC,EAAOhrC,KAAKxJ,IAGpB,MAAO,CAACw0C,EAAOC,KAGnB,YAAAG,QAAA,SAAQC,GACJ,IAAK,IAAI71C,EAAI,EAAGa,EAAIf,KAAKQ,SAAS8G,MAAMnH,OAAQD,EAAIa,EAAGb,IAAK,CACxD,IAAImH,EAAOrH,KAAKQ,SAAS8G,MAAMpH,GAC/B,IAAK,IAAI,KAAQmH,EAAKwrC,OAClBxrC,EAAKwrC,OAAO,GAAMiD,QAAQC,GAI9B,IAAK,IAAI,KAFT1uC,EAAKwrC,OAAS,KAEGxrC,EAAKirC,QAClBjrC,EAAKirC,QAAQ,GAAMwD,QAAQC,GAE/B1uC,EAAKirC,QAAU,KAGnB,IAASpyC,EAAI,EAAGa,EAAIf,KAAKgwC,eAAe7vC,OAAQD,EAAIa,EAAGb,IACnDF,KAAKgwC,eAAe9vC,GAAG41C,QAAQC,GAEnC/1C,KAAK6vC,UAAY,KACjB7vC,KAAKQ,SAAW,KAChBR,KAAKgwC,eAAiB,KACtBhwC,KAAK8vC,UAAY,KACjB9vC,KAAK+vC,MAAQ,KACb/vC,KAAKiwC,mBAAqB,KAE1B,YAAM6F,QAAO,UAACC,IArtBX,EAAAvC,kBAA4B,EAC5B,EAAA3B,iBAA4B,EA8gB5B,EAAAhd,gBAAiC,GAwM5C,EAxtBA,CAA2Bxb,KAAKk4B,WAAnB,EAAAF,MAAK,EAnDtB,CAAU9xC,MAAU,KCHpB,SAAUA,GACL8Z,KAAa3a,MAAQa,EAItB,IAAMy2C,EAAe38B,KAAK8kB,QAAQmR,UAE7B0G,EAAaC,aACdD,EAAaC,WAAaD,EAAapU,WAR/C,CAAUriC,MAAU,K1CgBpB,SAAUA,GAUN8Z,KAAK68B,eAAeC,oBAAoB,OAAQ98B,KAAK68B,eAAeE,kBAAkBC,QAEtF,+BAiHA,OAhHW,EAAAC,IAAP,SAA8B13C,EAA+BwQ,GAEzD,IAAKxQ,EAASgG,KACV,OAAOwK,IAGX,IAAMmnC,EAjBd,SAAgB33C,GACZ,OAAOA,EAAS4D,OAAS6W,KAAK68B,eAAeM,KAAKpd,KAgBrBqd,CAAO73C,IAAaA,EAASgG,KAAKJ,MACrDkyC,EAdd,SAAkB93C,GACd,OAAOA,EAAS+3C,UAAYt9B,KAAK68B,eAAeE,kBAAkBC,OAanCO,CAASh4C,KAAqC,SAAvBA,EAASi4C,WAAwBj4C,EAASk4C,SAASC,eAErG,IAAKR,IAAqBG,EACtB,OAAOtnC,IAGX,IAAI4nC,EAAkD,KAClDC,EAAcr4C,EAASgG,KAEvB2xC,EACAS,EAAS,IAAI,EAAAx3C,KAAKo6B,aAAa,OAE/Bod,EAAS,IAAI,EAAAx3C,KAAKgsB,eAAe,MAC7B5sB,EAASgG,gBAAgBsyC,cACzBD,EAAc,IAAIE,WAAWv4C,EAASgG,QAI9C,IAAMkyC,EAAWl4C,EAASk4C,UAAY,GAChCM,EAAwBN,EAAWl4C,EAASk4C,SAASO,mBAAqB,KAE5ED,IACAJ,EAAOnxC,MAAQuxC,GAGnB,IAAME,EAAgBR,EAAWl4C,EAASk4C,SAASS,WAAa,KAChE,IAAsB,IAAlBD,EACA,OAAOloC,IAEX,GAAIkoC,GAAiBA,EAAcnY,MAM/B,OAJA6X,EAAO7sB,iBAAmB,IAAI,EAAA3qB,KAAKyZ,sBAAsBq+B,GACzD14C,EAASixC,UAAYmH,EAAO3sB,iBAAiB4sB,GAC7Cr4C,EAAS24C,WAAaD,EAEfloC,IAGX,IAAMooC,EAAsBV,EAASW,kBAAoB,SAOrDC,EAAY94C,EAAS+4C,IACrBC,EAAiBF,EAAUniC,QAAQ,KACnCqiC,EAAiB,IAEjBF,EAAYA,EAAUne,OAAO,EAAGqe,IAEpCF,EAAYA,EAAUne,OAAO,EAAGme,EAAUtX,YAAY,MAAQoX,EAE1D54C,EAASk4C,UAAYl4C,EAASk4C,SAASe,iBACvCH,EAAY94C,EAASk4C,SAASe,gBAIlCH,EAAYA,EAAU1yC,QAAQhF,KAAK83C,QAAS,IAE5C,IAAMC,EAAe,CACjBC,YAAap5C,EAASo5C,YACtBrB,QAASt9B,KAAK68B,eAAeE,kBAAkB6B,KAC/CnB,SAAUA,EAASC,eAAiB,KACpCmB,eAAgBt5C,GAEdu5C,EAAe,CACjBH,YAAap5C,EAASo5C,YACtBlB,SAAUA,EAASsB,eAAiB,KACpCF,eAAgBt5C,GAEhBk5C,EAAUl5C,EAAS+4C,IAAIpe,OAAO,EAAG36B,EAAS+4C,IAAIvX,YAAY,KAAO,GAErE0X,EAAUA,EAAQ9yC,QAAQhF,KAAK83C,QAAS,IAExC,IAAMO,EAAavB,EAASwB,iBAAoB15C,EAASgB,KAAO,eAE1D24C,EAAUzB,EAAStd,OAASgf,EAAkB1B,EAAStd,QACvDsd,EAAS3Z,MAAQqb,EAAkB,CAAE,QAAW1B,EAAS3Z,QACrD2Z,EAAS2B,YAAc3B,EAAS2B,YAAYz4C,KAAMq4C,EAAYP,EAASK,GACnEO,EAAmB14C,KAAMq4C,EAAYP,EAASK,GAEtDQ,EAA6B,SAAUC,GACzC,IAAI,EAAAp5C,KAAKqiC,aAAa+W,EAASL,GAAS,SAAUhB,GAC1CA,IACAP,EAAO7sB,iBAAmB,IAAI,EAAA3qB,KAAKyZ,sBAAsBs+B,GACzD34C,EAASixC,UAAYmH,EAAO3sB,iBAAiB4sB,GAC7Cr4C,EAAS24C,WAAaA,GAE1BnoC,QAIJxQ,EAASk4C,UAAYl4C,EAASk4C,SAAS+B,aACvCF,EAA2B/5C,EAASk4C,SAAS+B,cAE7C74C,KAAKiF,IAAIrG,EAASgB,KAAO,SAAU83C,EAAWK,GAAc,SAAUe,GAC7DA,EAAcjuB,MAGfzb,IAFAupC,EAA2BG,EAAcl0C,UAO7D,EAjHA,GAmHA,SAAgB8zC,EAAmBK,EAAaV,EAAiBP,EAAcK,GAI3E,OAHIL,GAAWA,EAAQ1X,YAAY,OAAU0X,EAAQ33C,OAAS,IAC1D23C,GAAW,KAER,SAAUpX,EAAcxB,GAC3B,IAAMt/B,EAAOy4C,EAAa3X,EACpBiX,EAAMG,EAAUpX,EAEhBsY,EAAiBD,EAAO/6C,UAAU4B,GACxC,GAAIo5C,EAAgB,CAChB,IAAMC,EAAO,WACT/Z,EAAS8Z,EAAe3a,QAAQmB,cAEhCwZ,EAAe3a,QACf4a,IAGAD,EAAeE,kBAAkBj0C,IAAIg0C,QAGzCF,EAAO9zC,IAAIrF,EAAM+3C,EAAKQ,GAAc,SAACv5C,GAC9BA,EAASisB,MAGZqU,EAAS,MAFTA,EAAStgC,EAASy/B,QAAQmB,iBAkB1C,SAAgBgZ,EAAkBrZ,GAC9B,OAAO,SAAUuB,EAAWxB,GACxB,IAAIK,EAAOJ,EAAMuB,IAASvB,EAAK,QAC3BI,GAAQA,EAAKC,YACbN,EAASK,EAAKC,aAEdN,EAASK,IAjKR,EAAA4Z,YAAW,EAmHR,EAAAT,mBAAkB,EA+BlB,EAAAU,uBAAhB,SAAuCtB,EAAcE,GAIjD,OAHIF,GAAWA,EAAQ1X,YAAY,OAAU0X,EAAQ33C,OAAS,IAC1D23C,GAAW,KAER,SAAUpX,EAAWxB,GACxBA,EAAS7lB,KAAKggC,YAAYvpC,KAAK4wB,EAAMsX,MAI7B,EAAAQ,kBAAiB,EAU7Bn/B,KAAKigC,QACLjgC,KAAKigC,OAAOC,eAAeJ,GAlLnC,CAAU55C,MAAU","file":"static/js/96.0ffbcccc.chunk.js","sourcesContent":["import React, { Reducer, useContext, useEffect, useReducer, useState } from 'react';\nimport * as PIXI from 'pixi.js';\nimport { AnimationContext, PixiDisplayObject, RenderingContext, TextureContext, useElement } from 'pixi-reactive';\nimport { PixiSpineProps } from '../props';\nimport 'pixi-spine';\n\nconst PixiSpine: React.FC<PixiSpineProps> = (props) => {\n  const element = useElement(new PIXI.Container());\n  const { resources } = useContext(TextureContext);\n  const { frameId, elapsed } = useContext(AnimationContext);\n  const { update } = useContext(RenderingContext);\n  const [playing, setPlaying] = useState(false);\n  const [spine, setSpineElement] = useReducer<Reducer<PIXI.spine.Spine | undefined, PIXI.spine.Spine>>(\n    (previousElement: PIXI.spine.Spine | undefined, newElement: PIXI.spine.Spine) => {\n      if (previousElement) {\n        previousElement.destroy();\n      }\n      return newElement;\n    },\n    undefined\n  );\n  const { resource, loop = false, animation, trackIndex = 0, skin, speed = 1 } = props;\n\n  useEffect(() => {\n    if (spine) {\n      spine.skeleton.setSkin((null as unknown) as PIXI.spine.core.Skin);\n      if (skin) {\n        spine.skeleton.setSkinByName(skin);\n      }\n    }\n  }, [skin, spine]);\n\n  useEffect(() => {\n    if (spine) {\n      spine.setParent(element);\n    }\n  }, [element, spine]);\n\n  useEffect(() => {\n    if (resource && resources[resource] && resources[resource].spineData) {\n      const component = new window.PIXI.spine.Spine(resources[resource].spineData);\n      component.autoUpdate = false;\n\n      setSpineElement(component);\n    }\n  }, [resource, resources]);\n\n  useEffect(() => {\n    if (spine) {\n      if (animation && spine.state.hasAnimation(animation)) {\n        spine.state.setAnimation(trackIndex, animation, loop);\n        setPlaying(true);\n      } else {\n        spine.state.clearTrack(trackIndex);\n        spine.skeleton.setToSetupPose();\n        setPlaying(false);\n      }\n      update();\n    }\n  }, [spine, trackIndex, animation, loop, update]);\n\n  useEffect(() => {\n    if (spine) {\n      spine.state.timeScale = speed;\n    }\n  }, [spine, speed]);\n\n  useEffect(() => {\n    if (playing && spine) {\n      spine.update(elapsed);\n    }\n  }, [playing, frameId, elapsed, spine, update]);\n\n  return <PixiDisplayObject item={element} {...props} />;\n};\n\nexport default PixiSpine;\n","declare namespace PIXI.loaders {\r\n    export interface IMetadata {\r\n        spineSkeletonScale?: number;\r\n        spineAtlas?: any;\r\n        spineAtlasSuffix?: string;\r\n        spineAtlasFile?: string;\r\n        spineMetadata?: any;\r\n        imageNamePrefix?: string;\r\n        atlasRawData?: string;\r\n        imageLoader?: any;\r\n        images?: any;\r\n        imageMetadata?: any;\r\n        image?: any;\r\n    }\r\n}\r\n\r\nnamespace pixi_spine {\r\n\r\n    function isJson(resource: PIXI.LoaderResource) {\r\n        return resource.type === PIXI.LoaderResource.TYPE.JSON;\r\n    }\r\n\r\n    function isBuffer(resource: PIXI.LoaderResource) {\r\n        return resource.xhrType === PIXI.LoaderResource.XHR_RESPONSE_TYPE.BUFFER;\r\n    }\r\n\r\n    PIXI.LoaderResource.setExtensionXhrType('skel', PIXI.LoaderResource.XHR_RESPONSE_TYPE.BUFFER);\r\n\r\n    export class AtlasParser {\r\n        static use(this: PIXI.Loader, resource: PIXI.LoaderResource, next: () => any) {\r\n            // skip if no data, its not json, or it isn't atlas data\r\n            if (!resource.data) {\r\n                return next();\r\n            }\r\n\r\n            const isJsonSpineModel = isJson(resource) && resource.data.bones;\r\n            const isBinarySpineModel = isBuffer(resource) && (resource.extension === 'skel' || resource.metadata.spineMetadata);\r\n\r\n            if (!isJsonSpineModel && !isBinarySpineModel) {\r\n                return next();\r\n            }\r\n\r\n            let parser: core.SkeletonJson | core.SkeletonBinary = null;\r\n            let dataToParse = resource.data;\r\n\r\n            if (isJsonSpineModel) {\r\n                parser = new core.SkeletonJson(null);\r\n            } else {\r\n                parser = new core.SkeletonBinary(null);\r\n                if (resource.data instanceof ArrayBuffer) {\r\n                    dataToParse = new Uint8Array(resource.data);\r\n                }\r\n            }\r\n\r\n            const metadata = resource.metadata || {};\r\n            const metadataSkeletonScale = metadata ? resource.metadata.spineSkeletonScale : null;\r\n\r\n            if (metadataSkeletonScale) {\r\n                parser.scale = metadataSkeletonScale;\r\n            }\r\n\r\n            const metadataAtlas = metadata ? resource.metadata.spineAtlas : null;\r\n            if (metadataAtlas === false) {\r\n                return next();\r\n            }\r\n            if (metadataAtlas && metadataAtlas.pages) {\r\n                //its an atlas!\r\n                parser.attachmentLoader = new core.AtlasAttachmentLoader(metadataAtlas);\r\n                resource.spineData = parser.readSkeletonData(dataToParse);\r\n                resource.spineAtlas = metadataAtlas;\r\n\r\n                return next();\r\n            }\r\n\r\n            const metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';\r\n\r\n            /**\r\n             * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n             * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n             * have the same name\r\n             */\r\n            let atlasPath = resource.url;\r\n            let queryStringPos = atlasPath.indexOf('?');\r\n            if (queryStringPos > 0) {\r\n                //remove querystring\r\n                atlasPath = atlasPath.substr(0, queryStringPos)\r\n            }\r\n            atlasPath = atlasPath.substr(0, atlasPath.lastIndexOf('.')) + metadataAtlasSuffix;\r\n            // use atlas path as a params. (no need to use same atlas file name with json file name)\r\n            if (resource.metadata && resource.metadata.spineAtlasFile) {\r\n                atlasPath = resource.metadata.spineAtlasFile;\r\n            }\r\n\r\n            //remove the baseUrl\r\n            atlasPath = atlasPath.replace(this.baseUrl, '');\r\n\r\n            const atlasOptions = {\r\n                crossOrigin: resource.crossOrigin,\r\n                xhrType: PIXI.LoaderResource.XHR_RESPONSE_TYPE.TEXT,\r\n                metadata: metadata.spineMetadata || null,\r\n                parentResource: resource\r\n            };\r\n            const imageOptions = {\r\n                crossOrigin: resource.crossOrigin,\r\n                metadata: metadata.imageMetadata || null,\r\n                parentResource: resource\r\n            };\r\n            let baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n            //remove the baseUrl\r\n            baseUrl = baseUrl.replace(this.baseUrl, '');\r\n\r\n            const namePrefix = metadata.imageNamePrefix || (resource.name + '_atlas_page_');\r\n\r\n            const adapter = metadata.images ? staticImageLoader(metadata.images)\r\n                : metadata.image ? staticImageLoader({ 'default': metadata.image })\r\n                    : metadata.imageLoader ? metadata.imageLoader(this, namePrefix, baseUrl, imageOptions)\r\n                        : imageLoaderAdapter(this, namePrefix, baseUrl, imageOptions);\r\n\r\n            const createSkeletonWithRawAtlas = function (rawData: string) {\r\n                new core.TextureAtlas(rawData, adapter, function (spineAtlas) {\r\n                    if (spineAtlas) {\r\n                        parser.attachmentLoader = new core.AtlasAttachmentLoader(spineAtlas);\r\n                        resource.spineData = parser.readSkeletonData(dataToParse);\r\n                        resource.spineAtlas = spineAtlas;\r\n                    }\r\n                    next();\r\n                });\r\n            };\r\n\r\n            if (resource.metadata && resource.metadata.atlasRawData) {\r\n                createSkeletonWithRawAtlas(resource.metadata.atlasRawData)\r\n            } else {\r\n                this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource: any) {\r\n                    if (!atlasResource.error) {\r\n                        createSkeletonWithRawAtlas(atlasResource.data);\r\n                    } else {\r\n                        next();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    export function imageLoaderAdapter(loader: any, namePrefix: any, baseUrl: any, imageOptions: any) {\r\n        if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\r\n            baseUrl += '/';\r\n        }\r\n        return function (line: string, callback: (baseTexture: PIXI.BaseTexture) => any) {\r\n            const name = namePrefix + line;\r\n            const url = baseUrl + line;\r\n\r\n            const cachedResource = loader.resources[name];\r\n            if (cachedResource) {\r\n                const done = () => {\r\n                    callback(cachedResource.texture.baseTexture)\r\n                }\r\n                if (cachedResource.texture) {\r\n                    done();\r\n                }\r\n                else {\r\n                    cachedResource.onAfterMiddleware.add(done);\r\n                }\r\n            } else {\r\n                loader.add(name, url, imageOptions, (resource: PIXI.LoaderResource) => {\r\n                  if (!resource.error) {\r\n                    callback(resource.texture.baseTexture);\r\n                  } else {\r\n                    callback(null);\r\n                  }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    export function syncImageLoaderAdapter(baseUrl: any, crossOrigin: any) {\r\n        if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\r\n            baseUrl += '/';\r\n        }\r\n        return function (line: any, callback: any) {\r\n            callback(PIXI.BaseTexture.from(line, crossOrigin));\r\n        }\r\n    }\r\n\r\n    export function staticImageLoader(pages: { [key: string]: (PIXI.BaseTexture | PIXI.Texture) }) {\r\n        return function (line: any, callback: any) {\r\n            let page = pages[line] || pages['default'] as any;\r\n            if (page && page.baseTexture)\r\n                callback(page.baseTexture);\r\n            else\r\n                callback(page);\r\n        }\r\n    }\r\n\r\n    if (PIXI.Loader) {\r\n        PIXI.Loader.registerPlugin(AtlasParser);\r\n    }\r\n}\r\n","/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated May 1, 2019. Replaces all prior versions.\n *\n * Copyright (c) 2013-2019, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software\n * or otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY EXPRESS\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN\n * NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS\n * INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n\n    /** A simple container for a list of timelines and a name. */\n    export class Animation {\n        /** The animation's name, which is unique across all animations in the skeleton. */\n        name: string;\n        timelines: Array<Timeline>;\n        timelineIds: Array<boolean>;\n\n        /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\n        duration: number;\n\n        constructor (name: string, timelines: Array<Timeline>, duration: number) {\n            if (name == null) throw new Error(\"name cannot be null.\");\n            if (timelines == null) throw new Error(\"timelines cannot be null.\");\n            this.name = name;\n            this.timelines = timelines;\n            this.timelineIds = [];\n            for (var i = 0; i < timelines.length; i++)\n                this.timelineIds[timelines[i].getPropertyId()] = true;\n            this.duration = duration;\n        }\n\n        hasTimeline (id: number) {\n            return this.timelineIds[id] == true;\n        }\n\n        /** Applies all the animation's timelines to the specified skeleton.\n         *\n         * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n         * @param loop If true, the animation repeats after {@link #getDuration()}.\n         * @param events May be null to ignore fired events. */\n        apply (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n\n            if (loop && this.duration != 0) {\n                time %= this.duration;\n                if (lastTime > 0) lastTime %= this.duration;\n            }\n\n            let timelines = this.timelines;\n            for (let i = 0, n = timelines.length; i < n; i++)\n                timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n        }\n\n        /** @param target After the first and before the last value.\n         * @returns index of first value greater than the target. */\n        static binarySearch (values: ArrayLike<number>, target: number, step: number = 1) {\n            let low = 0;\n            let high = values.length / step - 2;\n            if (high == 0) return step;\n            let current = high >>> 1;\n            while (true) {\n                if (values[(current + 1) * step] <= target)\n                    low = current + 1;\n                else\n                    high = current;\n                if (low == high) return (low + 1) * step;\n                current = (low + high) >>> 1;\n            }\n        }\n\n        static linearSearch (values: ArrayLike<number>, target: number, step: number) {\n            for (let i = 0, last = values.length - step; i <= last; i += step)\n                if (values[i] > target) return i;\n            return -1;\n        }\n    }\n\n    /** The interface for all timelines. */\n    export interface Timeline {\n        /** Applies this timeline to the skeleton.\n         * @param skeleton The skeleton the timeline is being applied to. This provides access to the bones, slots, and other\n         *           skeleton components the timeline may change.\n         * @param lastTime The time this timeline was last applied. Timelines such as {@link EventTimeline}} trigger only at specific\n         *           times rather than every frame. In that case, the timeline triggers everything between `lastTime`\n         *           (exclusive) and `time` (inclusive).\n         * @param time The time within the animation. Most timelines find the key before and the key after this time so they can\n         *           interpolate between the keys.\n         * @param events If any events are fired, they are added to this list. Can be null to ignore fired events or if the timeline\n         *           does not fire events.\n         * @param alpha 0 applies the current or setup value (depending on `blend`). 1 applies the timeline value.\n         *           Between 0 and 1 applies a value between the current or setup value and the timeline value. By adjusting\n         *           `alpha` over time, an animation can be mixed in or out. `alpha` can also be useful to\n         *           apply animations on top of each other (layering).\n         * @param blend Controls how mixing is applied when `alpha` < 1.\n         * @param direction Indicates whether the timeline is mixing in or out. Used by timelines which perform instant transitions,\n         *           such as {@link DrawOrderTimeline} or {@link AttachmentTimeline}. */\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\n\n        /** Uniquely encodes both the type of this timeline and the skeleton property that it affects. */\n        getPropertyId (): number;\n    }\n\n    /** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\n     * < 1.\n     *\n     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}. */\n    export enum MixBlend {\n        /** Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup\n         * value is set. */\n        setup,\n        /** Transitions from the current value to the timeline value. Before the first key, transitions from the current value to\n         * the setup value. Timelines which perform instant transitions, such as {@link DrawOrderTimeline} or\n         * {@link AttachmentTimeline}, use the setup value before the first key.\n         *\n         * `first` is intended for the first animations applied, not for animations layered on top of those. */\n        first,\n        /** Transitions from the current value to the timeline value. No change is made before the first key (the current value is\n         * kept until the first key).\n         *\n         * `replace` is intended for animations layered on top of others, not for the first animations applied. */\n        replace,\n        /** Transitions from the current value to the current value plus the timeline value. No change is made before the first key\n         * (the current value is kept until the first key).\n         *\n         * `add` is intended for animations layered on top of others, not for the first animations applied. Properties\n         * keyed by additive animations must be set manually or by another animation before applying the additive animations, else\n         * the property values will increase continually. */\n        add\n    }\n\n    /** Indicates whether a timeline's `alpha` is mixing out over time toward 0 (the setup or current pose value) or\n     * mixing in toward 1 (the timeline's value).\n     *\n     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}. */\n    export enum MixDirection {\n        mixIn, mixOut\n    }\n\n    export enum TimelineType {\n        rotate, translate, scale, shear,\n        attachment, color, deform,\n        event, drawOrder,\n        ikConstraint, transformConstraint,\n        pathConstraintPosition, pathConstraintSpacing, pathConstraintMix,\n        twoColor\n    }\n\n    /** The base class for timelines that use interpolation between key frame values. */\n    export abstract class CurveTimeline implements Timeline {\n        static LINEAR = 0; static STEPPED = 1; static BEZIER = 2;\n        static BEZIER_SIZE = 10 * 2 - 1;\n\n        private curves: ArrayLike<number>; // type, x, y, ...\n\n        abstract getPropertyId(): number;\n\n        constructor (frameCount: number) {\n            if (frameCount <= 0) throw new Error(\"frameCount must be > 0: \" + frameCount);\n            this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n        }\n\n        /** The number of key frames for this timeline. */\n        getFrameCount () {\n            return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n        }\n\n        /** Sets the specified key frame to linear interpolation. */\n        setLinear (frameIndex: number) {\n            this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n        }\n\n        /** Sets the specified key frame to stepped interpolation. */\n        setStepped (frameIndex: number) {\n            this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n        }\n\n        /** Returns the interpolation type for the specified key frame.\n         * @returns Linear is 0, stepped is 1, Bezier is 2. */\n        getCurveType (frameIndex: number): number {\n            let index = frameIndex * CurveTimeline.BEZIER_SIZE;\n            if (index == this.curves.length) return CurveTimeline.LINEAR;\n            let type = this.curves[index];\n            if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\n            if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\n            return CurveTimeline.BEZIER;\n        }\n\n        /** Sets the specified key frame to Bezier interpolation. `cx1` and `cx2` are from 0 to 1,\n         * representing the percent of time between the two key frames. `cy1` and `cy2` are the percent of the\n         * difference between the key frame's values. */\n        setCurve (frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\n            let tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\n            let dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n            let ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\n            let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n\n            let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n            let curves = this.curves;\n            curves[i++] = CurveTimeline.BEZIER;\n\n            let x = dfx, y = dfy;\n            for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n                curves[i] = x;\n                curves[i + 1] = y;\n                dfx += ddfx;\n                dfy += ddfy;\n                ddfx += dddfx;\n                ddfy += dddfy;\n                x += dfx;\n                y += dfy;\n            }\n        }\n\n        /** Returns the interpolated percentage for the specified key frame and linear percentage. */\n        getCurvePercent (frameIndex: number, percent: number) {\n            percent = MathUtils.clamp(percent, 0, 1);\n            let curves = this.curves;\n            let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n            let type = curves[i];\n            if (type == CurveTimeline.LINEAR) return percent;\n            if (type == CurveTimeline.STEPPED) return 0;\n            i++;\n            let x = 0;\n            for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n                x = curves[i];\n                if (x >= percent) {\n                    let prevX: number, prevY: number;\n                    if (i == start) {\n                        prevX = 0;\n                        prevY = 0;\n                    } else {\n                        prevX = curves[i - 2];\n                        prevY = curves[i - 1];\n                    }\n                    return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n                }\n            }\n            let y = curves[i - 1];\n            return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\n        }\n\n        abstract apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection): void;\n    }\n\n    /** Changes a bone's local {@link Bone#rotation}. */\n    export class RotateTimeline extends CurveTimeline {\n        static ENTRIES = 2;\n        static PREV_TIME = -2; static PREV_ROTATION = -1;\n        static ROTATION = 1;\n\n        /** The index of the bone in {@link Skeleton#bones} that will be changed. */\n        boneIndex: number;\n\n        /** The time in seconds and rotation in degrees for each key frame. */\n        frames: ArrayLike<number>; // time, degrees, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount << 1);\n        }\n\n        getPropertyId () {\n            return (TimelineType.rotate << 24) + this.boneIndex;\n        }\n\n        /** Sets the time and angle of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, degrees: number) {\n            frameIndex <<= 1;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let frames = this.frames;\n\n            let bone = skeleton.bones[this.boneIndex];\n            if (!bone.active) return;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bone.rotation = bone.data.rotation;\n                        return;\n                    case MixBlend.first:\n                        let r = bone.data.rotation - bone.rotation;\n                        bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n                }\n                return;\n            }\n\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES]) { // Time is after last frame.\n                let r = frames[frames.length + RotateTimeline.PREV_ROTATION];\n                switch (blend) {\n                    case MixBlend.setup:\n                        bone.rotation = bone.data.rotation + r * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        r += bone.data.rotation - bone.rotation;\n                        r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360; // Wrap within -180 and 180.\n                    case MixBlend.add:\n                        bone.rotation += r * alpha;\n                }\n                return;\n            }\n\n            // Interpolate between the previous frame and the current frame.\n            let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n            let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n            let frameTime = frames[frame];\n            let percent = this.getCurvePercent((frame >> 1) - 1,\n                1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n            let r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n            r = prevRotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * percent;\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation + (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n                    break;\n                case MixBlend.first:\n                case MixBlend.replace:\n                    r += bone.data.rotation - bone.rotation;\n                case MixBlend.add:\n                    bone.rotation += (r - (16384 - ((16384.499999999996 - r / 360) | 0)) * 360) * alpha;\n            }\n        }\n    }\n\n    /** Changes a bone's local {@link Bone#x} and {@link Bone#y}. */\n    export class TranslateTimeline extends CurveTimeline {\n        static ENTRIES = 3;\n        static PREV_TIME = -3; static PREV_X = -2; static PREV_Y = -1;\n        static X = 1; static Y = 2;\n\n        /** The index of the bone in {@link Skeleton#bones} that will be changed. */\n        boneIndex: number;\n\n        /** The time in seconds, x, and y values for each key frame. */\n        frames: ArrayLike<number>; // time, x, y, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.translate << 24) + this.boneIndex;\n        }\n\n        /** Sets the time in seconds, x, and y values for the specified key frame. */\n        setFrame (frameIndex: number, time: number, x: number, y: number) {\n            frameIndex *= TranslateTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + TranslateTimeline.X] = x;\n            this.frames[frameIndex + TranslateTimeline.Y] = y;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let frames = this.frames;\n\n            let bone = skeleton.bones[this.boneIndex];\n            if (!bone.active) return;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bone.x = bone.data.x;\n                        bone.y = bone.data.y;\n                        return;\n                    case MixBlend.first:\n                        bone.x += (bone.data.x - bone.x) * alpha;\n                        bone.y += (bone.data.y - bone.y) * alpha;\n                }\n                return;\n            }\n\n            let x = 0, y = 0;\n            if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) { // Time is after last frame.\n                x = frames[frames.length + TranslateTimeline.PREV_X];\n                y = frames[frames.length + TranslateTimeline.PREV_Y];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n                x = frames[frame + TranslateTimeline.PREV_X];\n                y = frames[frame + TranslateTimeline.PREV_Y];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n\n                x += (frames[frame + TranslateTimeline.X] - x) * percent;\n                y += (frames[frame + TranslateTimeline.Y] - y) * percent;\n            }\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.x = bone.data.x + x * alpha;\n                    bone.y = bone.data.y + y * alpha;\n                    break;\n                case MixBlend.first:\n                case MixBlend.replace:\n                    bone.x += (bone.data.x + x - bone.x) * alpha;\n                    bone.y += (bone.data.y + y - bone.y) * alpha;\n                    break;\n                case MixBlend.add:\n                    bone.x += x * alpha;\n                    bone.y += y * alpha;\n            }\n        }\n    }\n\n    /** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}. */\n    export class ScaleTimeline extends TranslateTimeline {\n        constructor (frameCount: number) {\n            super(frameCount);\n        }\n\n        getPropertyId () {\n            return (TimelineType.scale << 24) + this.boneIndex;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let frames = this.frames;\n\n            let bone = skeleton.bones[this.boneIndex];\n            if (!bone.active) return;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bone.scaleX = bone.data.scaleX;\n                        bone.scaleY = bone.data.scaleY;\n                        return;\n                    case MixBlend.first:\n                        bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n                        bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n                }\n                return;\n            }\n\n            let x = 0, y = 0;\n            if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) { // Time is after last frame.\n                x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n                y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n                x = frames[frame + ScaleTimeline.PREV_X];\n                y = frames[frame + ScaleTimeline.PREV_Y];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n\n                x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n                y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n            }\n            if (alpha == 1) {\n                if (blend == MixBlend.add) {\n                    bone.scaleX += x - bone.data.scaleX;\n                    bone.scaleY += y - bone.data.scaleY;\n                } else {\n                    bone.scaleX = x;\n                    bone.scaleY = y;\n                }\n            } else {\n                let bx = 0, by = 0;\n                if (direction == MixDirection.mixOut) {\n                    switch (blend) {\n                        case MixBlend.setup:\n                            bx = bone.data.scaleX;\n                            by = bone.data.scaleY;\n                            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                            break;\n                        case MixBlend.first:\n                        case MixBlend.replace:\n                            bx = bone.scaleX;\n                            by = bone.scaleY;\n                            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                            break;\n                        case MixBlend.add:\n                            bx = bone.scaleX;\n                            by = bone.scaleY;\n                            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bone.data.scaleX) * alpha;\n                            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - bone.data.scaleY) * alpha;\n                    }\n                } else {\n                    switch (blend) {\n                        case MixBlend.setup:\n                            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n                            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n                            bone.scaleX = bx + (x - bx) * alpha;\n                            bone.scaleY = by + (y - by) * alpha;\n                            break;\n                        case MixBlend.first:\n                        case MixBlend.replace:\n                            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n                            by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n                            bone.scaleX = bx + (x - bx) * alpha;\n                            bone.scaleY = by + (y - by) * alpha;\n                            break;\n                        case MixBlend.add:\n                            bx = MathUtils.signum(x);\n                            by = MathUtils.signum(y);\n                            bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\n                            bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\n                    }\n                }\n            }\n        }\n    }\n\n    /** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}. */\n    export class ShearTimeline extends TranslateTimeline {\n        constructor (frameCount: number) {\n            super(frameCount);\n        }\n\n        getPropertyId () {\n            return (TimelineType.shear << 24) + this.boneIndex;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let frames = this.frames;\n\n            let bone = skeleton.bones[this.boneIndex];\n            if (!bone.active) return;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bone.shearX = bone.data.shearX;\n                        bone.shearY = bone.data.shearY;\n                        return;\n                    case MixBlend.first:\n                        bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n                        bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n                }\n                return;\n            }\n\n            let x = 0, y = 0;\n            if (time >= frames[frames.length - ShearTimeline.ENTRIES]) { // Time is after last frame.\n                x = frames[frames.length + ShearTimeline.PREV_X];\n                y = frames[frames.length + ShearTimeline.PREV_Y];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n                x = frames[frame + ShearTimeline.PREV_X];\n                y = frames[frame + ShearTimeline.PREV_Y];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n\n                x = x + (frames[frame + ShearTimeline.X] - x) * percent;\n                y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n            }\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearX = bone.data.shearX + x * alpha;\n                    bone.shearY = bone.data.shearY + y * alpha;\n                    break;\n                case MixBlend.first:\n                case MixBlend.replace:\n                    bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                    bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n                    break;\n                case MixBlend.add:\n                    bone.shearX += x * alpha;\n                    bone.shearY += y * alpha;\n            }\n        }\n    }\n\n    /** Changes a slot's {@link Slot#color}. */\n    export class ColorTimeline extends CurveTimeline {\n        static ENTRIES = 5;\n        static PREV_TIME = -5; static PREV_R = -4; static PREV_G = -3; static PREV_B = -2; static PREV_A = -1;\n        static R = 1; static G = 2; static B = 3; static A = 4;\n\n        /** The index of the slot in {@link Skeleton#slots} that will be changed. */\n        slotIndex: number;\n\n        /** The time in seconds, red, green, blue, and alpha values for each key frame. */\n        frames: ArrayLike<number>; // time, r, g, b, a, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.color << 24) + this.slotIndex;\n        }\n\n        /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n        setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\n            frameIndex *= ColorTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + ColorTimeline.R] = r;\n            this.frames[frameIndex + ColorTimeline.G] = g;\n            this.frames[frameIndex + ColorTimeline.B] = b;\n            this.frames[frameIndex + ColorTimeline.A] = a;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let slot = skeleton.slots[this.slotIndex];\n            if (!slot.bone.active) return;\n            let frames = this.frames;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        slot.color.setFromColor(slot.data.color);\n                        return;\n                    case MixBlend.first:\n                        let color = slot.color, setup = slot.data.color;\n                        color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha,\n                            (setup.a - color.a) * alpha);\n                }\n                return;\n            }\n\n            let r = 0, g = 0, b = 0, a = 0;\n            if (time >= frames[frames.length - ColorTimeline.ENTRIES]) { // Time is after last frame.\n                let i = frames.length;\n                r = frames[i + ColorTimeline.PREV_R];\n                g = frames[i + ColorTimeline.PREV_G];\n                b = frames[i + ColorTimeline.PREV_B];\n                a = frames[i + ColorTimeline.PREV_A];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n                r = frames[frame + ColorTimeline.PREV_R];\n                g = frames[frame + ColorTimeline.PREV_G];\n                b = frames[frame + ColorTimeline.PREV_B];\n                a = frames[frame + ColorTimeline.PREV_A];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n\n                r += (frames[frame + ColorTimeline.R] - r) * percent;\n                g += (frames[frame + ColorTimeline.G] - g) * percent;\n                b += (frames[frame + ColorTimeline.B] - b) * percent;\n                a += (frames[frame + ColorTimeline.A] - a) * percent;\n            }\n            if (alpha == 1)\n                slot.color.set(r, g, b, a);\n            else {\n                let color = slot.color;\n                if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\n                color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n            }\n        }\n    }\n\n    /** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting. */\n    export class TwoColorTimeline extends CurveTimeline {\n        static ENTRIES = 8;\n        static PREV_TIME = -8; static PREV_R = -7; static PREV_G = -6; static PREV_B = -5; static PREV_A = -4;\n        static PREV_R2 = -3; static PREV_G2 = -2; static PREV_B2 = -1;\n        static R = 1; static G = 2; static B = 3; static A = 4; static R2 = 5; static G2 = 6; static B2 = 7;\n\n        /** The index of the slot in {@link Skeleton#slots()} that will be changed. The {@link Slot#darkColor()} must not be\n         * null. */\n        slotIndex: number;\n\n        /** The time in seconds, red, green, blue, and alpha values of the color, red, green, blue of the dark color, for each key frame. */\n        frames: ArrayLike<number>; // time, r, g, b, a, r2, g2, b2, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.twoColor << 24) + this.slotIndex;\n        }\n\n        /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n        setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\n            frameIndex *= TwoColorTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + TwoColorTimeline.R] = r;\n            this.frames[frameIndex + TwoColorTimeline.G] = g;\n            this.frames[frameIndex + TwoColorTimeline.B] = b;\n            this.frames[frameIndex + TwoColorTimeline.A] = a;\n            this.frames[frameIndex + TwoColorTimeline.R2] = r2;\n            this.frames[frameIndex + TwoColorTimeline.G2] = g2;\n            this.frames[frameIndex + TwoColorTimeline.B2] = b2;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let slot = skeleton.slots[this.slotIndex];\n            if (!slot.bone.active) return;\n            let frames = this.frames;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        slot.color.setFromColor(slot.data.color);\n                        slot.darkColor.setFromColor(slot.data.darkColor);\n                        return;\n                    case MixBlend.first:\n                        let light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\n                        light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha,\n                            (setupLight.a - light.a) * alpha);\n                        dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n                }\n                return;\n            }\n\n            let r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\n            if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) { // Time is after last frame.\n                let i = frames.length;\n                r = frames[i + TwoColorTimeline.PREV_R];\n                g = frames[i + TwoColorTimeline.PREV_G];\n                b = frames[i + TwoColorTimeline.PREV_B];\n                a = frames[i + TwoColorTimeline.PREV_A];\n                r2 = frames[i + TwoColorTimeline.PREV_R2];\n                g2 = frames[i + TwoColorTimeline.PREV_G2];\n                b2 = frames[i + TwoColorTimeline.PREV_B2];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\n                r = frames[frame + TwoColorTimeline.PREV_R];\n                g = frames[frame + TwoColorTimeline.PREV_G];\n                b = frames[frame + TwoColorTimeline.PREV_B];\n                a = frames[frame + TwoColorTimeline.PREV_A];\n                r2 = frames[frame + TwoColorTimeline.PREV_R2];\n                g2 = frames[frame + TwoColorTimeline.PREV_G2];\n                b2 = frames[frame + TwoColorTimeline.PREV_B2];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\n\n                r += (frames[frame + TwoColorTimeline.R] - r) * percent;\n                g += (frames[frame + TwoColorTimeline.G] - g) * percent;\n                b += (frames[frame + TwoColorTimeline.B] - b) * percent;\n                a += (frames[frame + TwoColorTimeline.A] - a) * percent;\n                r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\n                g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\n                b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\n            }\n            if (alpha == 1) {\n                slot.color.set(r, g, b, a);\n                slot.darkColor.set(r2, g2, b2, 1);\n            } else {\n                let light = slot.color, dark = slot.darkColor;\n                if (blend == MixBlend.setup) {\n                    light.setFromColor(slot.data.color);\n                    dark.setFromColor(slot.data.darkColor);\n                }\n                light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n                dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n            }\n        }\n    }\n\n    /** Changes a slot's {@link Slot#attachment}. */\n    export class AttachmentTimeline implements Timeline {\n        /** The index of the slot in {@link Skeleton#slots} that will be changed. */\n        slotIndex: number;\n\n        /** The time in seconds for each key frame. */\n        frames: ArrayLike<number> // time, ...\n\n        /** The attachment name for each key frame. May contain null values to clear the attachment. */\n        attachmentNames: Array<string>;\n\n        constructor (frameCount: number) {\n            this.frames = Utils.newFloatArray(frameCount);\n            this.attachmentNames = new Array<string>(frameCount);\n        }\n\n        getPropertyId () {\n            return (TimelineType.attachment << 24) + this.slotIndex;\n        }\n\n        /** The number of key frames for this timeline. */\n        getFrameCount () {\n            return this.frames.length;\n        }\n\n        /** Sets the time in seconds and the attachment name for the specified key frame. */\n        setFrame (frameIndex: number, time: number, attachmentName: string) {\n            this.frames[frameIndex] = time;\n            this.attachmentNames[frameIndex] = attachmentName;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let slot = skeleton.slots[this.slotIndex];\n            if (!slot.bone.active) return;\n            if (direction == MixDirection.mixOut) {\n                if (blend == MixBlend.setup)\n                    this.setAttachment(skeleton, slot, slot.data.attachmentName);\n                return;\n            }\n\n            let frames = this.frames;\n            if (time < frames[0]) {\n                if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n                return;\n            }\n\n            let frameIndex = 0;\n            if (time >= frames[frames.length - 1]) // Time is after last frame.\n                frameIndex = frames.length - 1;\n            else\n                frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n\n            let attachmentName = this.attachmentNames[frameIndex];\n            skeleton.slots[this.slotIndex]\n                .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n        }\n\n        setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string) {\n            slot.attachment = attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName);\n        }\n    }\n\n    let zeros : ArrayLike<number> = null;\n\n    /** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}. */\n    export class DeformTimeline extends CurveTimeline {\n        /** The index of the slot in {@link Skeleton#getSlots()} that will be changed. */\n        slotIndex: number;\n\n        /** The attachment that will be deformed. */\n        attachment: VertexAttachment;\n\n        /** The time in seconds for each key frame. */\n        frames: ArrayLike<number>; // time, ...\n\n        /** The vertices for each key frame. */\n        frameVertices: Array<ArrayLike<number>>;\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount);\n            this.frameVertices = new Array<ArrayLike<number>>(frameCount);\n            if (zeros == null) zeros = Utils.newFloatArray(64);\n        }\n\n        getPropertyId () {\n            return (TimelineType.deform << 27) + + this.attachment.id + this.slotIndex;\n        }\n\n        /** Sets the time in seconds and the vertices for the specified key frame.\n         * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\n        setFrame (frameIndex: number, time: number, vertices: ArrayLike<number>) {\n            this.frames[frameIndex] = time;\n            this.frameVertices[frameIndex] = vertices;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let slot: Slot = skeleton.slots[this.slotIndex];\n            if (!slot.bone.active) return;\n            let slotAttachment: Attachment = slot.getAttachment();\n            if (!(slotAttachment instanceof VertexAttachment) || !((<VertexAttachment>slotAttachment).deformAttachment == this.attachment)) return;\n\n            let deformArray: Array<number> = slot.deform;\n            if (deformArray.length == 0) blend = MixBlend.setup;\n\n            let frameVertices = this.frameVertices;\n            let vertexCount = frameVertices[0].length;\n\n            let frames = this.frames;\n            if (time < frames[0]) {\n                let vertexAttachment = <VertexAttachment>slotAttachment;\n                switch (blend) {\n                    case MixBlend.setup:\n                        deformArray.length = 0;\n                        return;\n                    case MixBlend.first:\n                        if (alpha == 1) {\n                            deformArray.length = 0;\n                            break;\n                        }\n                        let deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions.\n                            let setupVertices = vertexAttachment.vertices;\n                            for (var i = 0; i < vertexCount; i++)\n                                deform[i] += (setupVertices[i] - deform[i]) * alpha;\n                        } else {\n                            // Weighted deform offsets.\n                            alpha = 1 - alpha;\n                            for (var i = 0; i < vertexCount; i++)\n                                deform[i] *= alpha;\n                        }\n                }\n                return;\n            }\n\n            let deform: Array<number> = Utils.setArraySize(deformArray, vertexCount);\n            if (time >= frames[frames.length - 1]) { // Time is after last frame.\n                let lastVertices = frameVertices[frames.length - 1];\n                if (alpha == 1) {\n                    if (blend == MixBlend.add) {\n                        let vertexAttachment = slotAttachment as VertexAttachment;\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions, with alpha.\n                            let setupVertices = vertexAttachment.vertices;\n                            for (let i = 0; i < vertexCount; i++) {\n                                deform[i] += lastVertices[i] - setupVertices[i];\n                            }\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++)\n                                deform[i] += lastVertices[i];\n                        }\n                    } else {\n                        Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\n                    }\n                } else {\n                    switch (blend) {\n                        case MixBlend.setup: {\n                            let vertexAttachment = slotAttachment as VertexAttachment;\n                            if (vertexAttachment.bones == null) {\n                                // Unweighted vertex positions, with alpha.\n                                let setupVertices = vertexAttachment.vertices;\n                                for (let i = 0; i < vertexCount; i++) {\n                                    let setup = setupVertices[i];\n                                    deform[i] = setup + (lastVertices[i] - setup) * alpha;\n                                }\n                            } else {\n                                // Weighted deform offsets, with alpha.\n                                for (let i = 0; i < vertexCount; i++)\n                                    deform[i] = lastVertices[i] * alpha;\n                            }\n                            break;\n                        }\n                        case MixBlend.first:\n                        case MixBlend.replace:\n                            for (let i = 0; i < vertexCount; i++)\n                                deform[i] += (lastVertices[i] - deform[i]) * alpha;\n                            break;\n                        case MixBlend.add:\n                            let vertexAttachment = slotAttachment as VertexAttachment;\n                            if (vertexAttachment.bones == null) {\n                                // Unweighted vertex positions, with alpha.\n                                let setupVertices = vertexAttachment.vertices;\n                                for (let i = 0; i < vertexCount; i++) {\n                                    deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n                                }\n                            } else {\n                                // Weighted deform offsets, with alpha.\n                                for (let i = 0; i < vertexCount; i++)\n                                    deform[i] += lastVertices[i] * alpha;\n                            }\n                    }\n                }\n                return;\n            }\n\n            // Interpolate between the previous frame and the current frame.\n            let frame = Animation.binarySearch(frames, time);\n            let prevVertices = frameVertices[frame - 1];\n            let nextVertices = frameVertices[frame];\n            let frameTime = frames[frame];\n            let percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n\n            if (alpha == 1) {\n                if (blend == MixBlend.add) {\n                    let vertexAttachment = slotAttachment as VertexAttachment;\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions, with alpha.\n                        let setupVertices = vertexAttachment.vertices;\n                        for (let i = 0; i < vertexCount; i++) {\n                            let prev = prevVertices[i];\n                            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) {\n                            let prev = prevVertices[i];\n                            deform[i] += prev + (nextVertices[i] - prev) * percent;\n                        }\n                    }\n                } else {\n                    for (let i = 0; i < vertexCount; i++) {\n                        let prev = prevVertices[i];\n                        deform[i] = prev + (nextVertices[i] - prev) * percent;\n                    }\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup: {\n                        let vertexAttachment = slotAttachment as VertexAttachment;\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions, with alpha.\n                            let setupVertices = vertexAttachment.vertices;\n                            for (let i = 0; i < vertexCount; i++) {\n                                let prev = prevVertices[i], setup = setupVertices[i];\n                                deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n                            }\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) {\n                                let prev = prevVertices[i];\n                                deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n                            }\n                        }\n                        break;\n                    }\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        for (let i = 0; i < vertexCount; i++) {\n                            let prev = prevVertices[i];\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\n                        }\n                        break;\n                    case MixBlend.add:\n                        let vertexAttachment = slotAttachment as VertexAttachment;\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions, with alpha.\n                            let setupVertices = vertexAttachment.vertices;\n                            for (let i = 0; i < vertexCount; i++) {\n                                let prev = prevVertices[i];\n                                deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n                            }\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) {\n                                let prev = prevVertices[i];\n                                deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n                            }\n                        }\n                }\n            }\n        }\n    }\n\n    /** Fires an {@link Event} when specific animation times are reached. */\n    export class EventTimeline implements Timeline {\n        /** The time in seconds for each key frame. */\n        frames: ArrayLike<number>; // time, ...\n\n        /** The event for each key frame. */\n        events: Array<Event>;\n\n        constructor (frameCount: number) {\n            this.frames = Utils.newFloatArray(frameCount);\n            this.events = new Array<Event>(frameCount);\n        }\n\n        getPropertyId () {\n            return TimelineType.event << 24;\n        }\n\n        /** The number of key frames for this timeline. */\n        getFrameCount () {\n            return this.frames.length;\n        }\n\n        /** Sets the time in seconds and the event for the specified key frame. */\n        setFrame (frameIndex: number, event: Event) {\n            this.frames[frameIndex] = event.time;\n            this.events[frameIndex] = event;\n        }\n\n        /** Fires events for frames > `lastTime` and <= `time`. */\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            if (firedEvents == null) return;\n            let frames = this.frames;\n            let frameCount = this.frames.length;\n\n            if (lastTime > time) { // Fire events after last time for looped animations.\n                this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n                lastTime = -1;\n            } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\n                return;\n            if (time < frames[0]) return; // Time is before first frame.\n\n            let frame = 0;\n            if (lastTime < frames[0])\n                frame = 0;\n            else {\n                frame = Animation.binarySearch(frames, lastTime);\n                let frameTime = frames[frame];\n                while (frame > 0) { // Fire multiple events with the same frame.\n                    if (frames[frame - 1] != frameTime) break;\n                    frame--;\n                }\n            }\n            for (; frame < frameCount && time >= frames[frame]; frame++)\n                firedEvents.push(this.events[frame]);\n        }\n    }\n\n    /** Changes a skeleton's {@link Skeleton#drawOrder}. */\n    export class DrawOrderTimeline implements Timeline {\n        /** The time in seconds for each key frame. */\n        frames: ArrayLike<number>; // time, ...\n\n        /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\n        drawOrders: Array<Array<number>>;\n\n        constructor (frameCount: number) {\n            this.frames = Utils.newFloatArray(frameCount);\n            this.drawOrders = new Array<Array<number>>(frameCount);\n        }\n\n        getPropertyId () {\n            return TimelineType.drawOrder << 24;\n        }\n\n        /** The number of key frames for this timeline. */\n        getFrameCount () {\n            return this.frames.length;\n        }\n\n        /** Sets the time in seconds and the draw order for the specified key frame.\n         * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\n         *           draw order. */\n        setFrame (frameIndex: number, time: number, drawOrder: Array<number>) {\n            this.frames[frameIndex] = time;\n            this.drawOrders[frameIndex] = drawOrder;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let drawOrder: Array<Slot> = skeleton.drawOrder;\n            let slots: Array<Slot> = skeleton.slots;\n            if (direction == MixDirection.mixOut && blend == MixBlend.setup) {\n                Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n                return;\n            }\n\n            let frames = this.frames;\n            if (time < frames[0]) {\n                if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n                return;\n            }\n\n            let frame = 0;\n            if (time >= frames[frames.length - 1]) // Time is after last frame.\n                frame = frames.length - 1;\n            else\n                frame = Animation.binarySearch(frames, time) - 1;\n\n            let drawOrderToSetupIndex = this.drawOrders[frame];\n            if (drawOrderToSetupIndex == null)\n                Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n            else {\n                for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n                    drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n            }\n        }\n    }\n\n    /** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\n     * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}. */\n    export class IkConstraintTimeline extends CurveTimeline {\n        static ENTRIES = 6;\n        static PREV_TIME = -6; static PREV_MIX = -5; static PREV_SOFTNESS = -4; static PREV_BEND_DIRECTION = -3; static PREV_COMPRESS = -2; static PREV_STRETCH = -1;\n        static MIX = 1; static SOFTNESS = 2; static BEND_DIRECTION = 3; static COMPRESS = 4; static STRETCH = 5;\n\n        /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\n        ikConstraintIndex: number;\n\n        /** The time in seconds, mix, softness, bend direction, compress, and stretch for each key frame. */\n        frames: ArrayLike<number>; // time, mix, softness, bendDirection, compress, stretch, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\n        }\n\n        /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\n        setFrame (frameIndex: number, time: number, mix: number, softness: number, bendDirection: number, compress: boolean, stretch: boolean) {\n            frameIndex *= IkConstraintTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n            this.frames[frameIndex + IkConstraintTimeline.SOFTNESS] = softness;\n            this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n            this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\n            this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let frames = this.frames;\n            let constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n            if (!constraint.active) return;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        constraint.mix = constraint.data.mix;\n                        constraint.softness = constraint.data.softness;\n                        constraint.bendDirection = constraint.data.bendDirection;\n                        constraint.compress = constraint.data.compress;\n                        constraint.stretch = constraint.data.stretch;\n                        return;\n                    case MixBlend.first:\n                        constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n                        constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\n                        constraint.bendDirection = constraint.data.bendDirection;\n                        constraint.compress = constraint.data.compress;\n                        constraint.stretch = constraint.data.stretch;\n                }\n                return;\n            }\n\n            if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) { // Time is after last frame.\n                if (blend == MixBlend.setup) {\n                    constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n                    constraint.softness = constraint.data.softness\n                        + (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.data.softness) * alpha;\n                    if (direction == MixDirection.mixOut) {\n                        constraint.bendDirection = constraint.data.bendDirection;\n                        constraint.compress = constraint.data.compress;\n                        constraint.stretch = constraint.data.stretch;\n                    } else {\n                        constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION]\n                        constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                        constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n                    }\n                } else {\n                    constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n                    constraint.softness += (frames[frames.length + IkConstraintTimeline.PREV_SOFTNESS] - constraint.softness) * alpha;\n                    if (direction == MixDirection.mixIn) {\n                        constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                        constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                        constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n                    }\n                }\n                return;\n            }\n\n            // Interpolate between the previous frame and the current frame.\n            let frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n            let mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n            let softness = frames[frame + IkConstraintTimeline.PREV_SOFTNESS];\n            let frameTime = frames[frame];\n            let percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n\n            if (blend == MixBlend.setup) {\n                constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\n                constraint.softness = constraint.data.softness\n                    + (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.data.softness) * alpha;\n                if (direction == MixDirection.mixOut) {\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n                } else {\n                    constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                    constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n                }\n            } else {\n                constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n                constraint.softness += (softness + (frames[frame + IkConstraintTimeline.SOFTNESS] - softness) * percent - constraint.softness) * alpha;\n                if (direction == MixDirection.mixIn) {\n                    constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n                    constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n                }\n            }\n        }\n    }\n\n    /** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\n     * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}. */\n    export class TransformConstraintTimeline extends CurveTimeline {\n        static ENTRIES = 5;\n        static PREV_TIME = -5; static PREV_ROTATE = -4; static PREV_TRANSLATE = -3; static PREV_SCALE = -2; static PREV_SHEAR = -1;\n        static ROTATE = 1; static TRANSLATE = 2; static SCALE = 3; static SHEAR = 4;\n\n        /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\n        transformConstraintIndex: number;\n\n        /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for each key frame. */\n        frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\n        }\n\n        /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\n        setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\n            frameIndex *= TransformConstraintTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n            this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n            this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n            this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let frames = this.frames;\n\n            let constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\n            if (!constraint.active) return;\n            if (time < frames[0]) {\n                let data = constraint.data;\n                switch (blend) {\n                    case MixBlend.setup:\n                        constraint.rotateMix = data.rotateMix;\n                        constraint.translateMix = data.translateMix;\n                        constraint.scaleMix = data.scaleMix;\n                        constraint.shearMix = data.shearMix;\n                        return;\n                    case MixBlend.first:\n                        constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n                        constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n                        constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n                        constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n                }\n                return;\n            }\n\n            let rotate = 0, translate = 0, scale = 0, shear = 0;\n            if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) { // Time is after last frame.\n                let i = frames.length;\n                rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\n                translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\n                scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\n                shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n                rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n                translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n                scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n                shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\n\n                rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\n                translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n                scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\n                shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\n            }\n            if (blend == MixBlend.setup) {\n                let data = constraint.data;\n                constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n                constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n                constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n                constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n            } else {\n                constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n                constraint.translateMix += (translate - constraint.translateMix) * alpha;\n                constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n                constraint.shearMix += (shear - constraint.shearMix) * alpha;\n            }\n        }\n    }\n\n    /** Changes a path constraint's {@link PathConstraint#position}. */\n    export class PathConstraintPositionTimeline extends CurveTimeline {\n        static ENTRIES = 2;\n        static PREV_TIME = -2; static PREV_VALUE = -1;\n        static VALUE = 1;\n\n        /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\n        pathConstraintIndex: number;\n\n        /** The time in seconds and path constraint position for each key frame. */\n        frames: ArrayLike<number>; // time, position, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\n        }\n\n        /** Sets the time in seconds and path constraint position for the specified key frame. */\n        setFrame (frameIndex: number, time: number, value: number) {\n            frameIndex *= PathConstraintPositionTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let frames = this.frames;\n            let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n            if (!constraint.active) return;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        constraint.position = constraint.data.position;\n                        return;\n                    case MixBlend.first:\n                        constraint.position += (constraint.data.position - constraint.position) * alpha;\n                }\n                return;\n            }\n\n            let position = 0;\n            if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) // Time is after last frame.\n                position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\n            else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n                position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\n\n                position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\n            }\n            if (blend == MixBlend.setup)\n                constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n            else\n                constraint.position += (position - constraint.position) * alpha;\n        }\n    }\n\n    /** Changes a path constraint's {@link PathConstraint#spacing}. */\n    export class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\n        constructor (frameCount: number) {\n            super(frameCount);\n        }\n\n        getPropertyId () {\n            return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let frames = this.frames;\n            let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n            if (!constraint.active) return;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        constraint.spacing = constraint.data.spacing;\n                        return;\n                    case MixBlend.first:\n                        constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n                }\n                return;\n            }\n\n            let spacing = 0;\n            if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) // Time is after last frame.\n                spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\n            else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n                spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\n\n                spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n            }\n\n            if (blend == MixBlend.setup)\n                constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n            else\n                constraint.spacing += (spacing - constraint.spacing) * alpha;\n        }\n    }\n\n    /** Changes a transform constraint's {@link PathConstraint#rotateMix} and\n     * {@link TransformConstraint#translateMix}. */\n    export class PathConstraintMixTimeline extends CurveTimeline {\n        static ENTRIES = 3;\n        static PREV_TIME = -3; static PREV_ROTATE = -2; static PREV_TRANSLATE = -1;\n        static ROTATE = 1; static TRANSLATE = 2;\n\n        /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n        pathConstraintIndex: number;\n\n        /** The time in seconds, rotate mix, and translate mix for each key frame. */\n        frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\n        }\n\n        /** The time in seconds, rotate mix, and translate mix for the specified key frame. */\n        setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number) {\n            frameIndex *= PathConstraintMixTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n            this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n            let frames = this.frames;\n            let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n            if (!constraint.active) return;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        constraint.rotateMix = constraint.data.rotateMix;\n                        constraint.translateMix = constraint.data.translateMix;\n                        return;\n                    case MixBlend.first:\n                        constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n                        constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n                }\n                return;\n            }\n\n            let rotate = 0, translate = 0;\n            if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) { // Time is after last frame.\n                rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\n                translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n                rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n                translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\n\n                rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n                translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n            }\n\n            if (blend == MixBlend.setup) {\n                constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n                constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n            } else {\n                constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n                constraint.translateMix += (translate - constraint.translateMix) * alpha;\n            }\n        }\n    }\n}\n","/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    /** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\n     * multiple animations on top of each other (layering).\n     *\n     * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide. */\n    export class AnimationState {\n        static emptyAnimation = new Animation(\"<empty>\", [], 0);\n\n        /** 1. A previously applied timeline has set this property.\n         *\n         * Result: Mix from the current pose to the timeline pose. */\n        static SUBSEQUENT = 0;\n        /** 1. This is the first timeline to set this property.\n         * 2. The next track entry applied after this one does not have a timeline to set this property.\n         *\n         * Result: Mix from the setup pose to the timeline pose. */\n        static FIRST = 1;\n        /** 1) A previously applied timeline has set this property.<br>\n         * 2) The next track entry to be applied does have a timeline to set this property.<br>\n         * 3) The next track entry after that one does not have a timeline to set this property.<br>\n         * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\n         * animations that key the same property. A subsequent timeline will set this property using a mix. */\n        static HOLD_SUBSEQUENT = 2;\n        /** 1) This is the first timeline to set this property.<br>\n         * 2) The next track entry to be applied does have a timeline to set this property.<br>\n         * 3) The next track entry after that one does not have a timeline to set this property.<br>\n         * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\n         * that key the same property. A subsequent timeline will set this property using a mix. */\n        static HOLD_FIRST = 3;\n        /** 1. This is the first timeline to set this property.\n         * 2. The next track entry to be applied does have a timeline to set this property.\n         * 3. The next track entry after that one does have a timeline to set this property.\n         * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\n         *\n         * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\n         * 2 track entries in a row have a timeline that sets the same property.\n         *\n         * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\n         * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\n         * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\n         * place. */\n        static HOLD_MIX = 4;\n\n        static SETUP = 1;\n        static CURRENT = 2;\n\n        /** The AnimationStateData to look up mix durations. */\n        data: AnimationStateData;\n\n        /** The list of tracks that currently have animations, which may contain null entries. */\n        tracks = new Array<TrackEntry>();\n\n        /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\n         * or faster. Defaults to 1.\n         *\n         * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\n        timeScale = 1;\n        unkeyedState = 0;\n\n        events = new Array<Event>();\n        listeners = new Array<AnimationStateListener>();\n        queue = new EventQueue(this);\n        propertyIDs = new IntSet();\n        animationsChanged = false;\n\n        trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\n\n        constructor (data: AnimationStateData) {\n            this.data = data;\n        }\n\n        /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\n        update (delta: number) {\n            delta *= this.timeScale;\n            let tracks = this.tracks;\n            for (let i = 0, n = tracks.length; i < n; i++) {\n                let current = tracks[i];\n                if (current == null) continue;\n\n                current.animationLast = current.nextAnimationLast;\n                current.trackLast = current.nextTrackLast;\n\n                let currentDelta = delta * current.timeScale;\n\n                if (current.delay > 0) {\n                    current.delay -= currentDelta;\n                    if (current.delay > 0) continue;\n                    currentDelta = -current.delay;\n                    current.delay = 0;\n                }\n\n                let next = current.next;\n                if (next != null) {\n                    // When the next entry's delay is passed, change to the next entry, preserving leftover time.\n                    let nextTime = current.trackLast - next.delay;\n                    if (nextTime >= 0) {\n                        next.delay = 0;\n                        next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n                        current.trackTime += currentDelta;\n                        this.setCurrent(i, next, true);\n                        while (next.mixingFrom != null) {\n                            next.mixTime += delta;\n                            next = next.mixingFrom;\n                        }\n                        continue;\n                    }\n                } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n                    tracks[i] = null;\n                    this.queue.end(current);\n                    this.disposeNext(current);\n                    continue;\n                }\n                if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n                    // End mixing from entries once all have completed.\n                    let from = current.mixingFrom;\n                    current.mixingFrom = null;\n                    if (from != null) from.mixingTo = null;\n                    while (from != null) {\n                        this.queue.end(from);\n                        from = from.mixingFrom;\n                    }\n                }\n\n                current.trackTime += currentDelta;\n            }\n\n            this.queue.drain();\n        }\n\n        /** Returns true when all mixing from entries are complete. */\n        updateMixingFrom (to: TrackEntry, delta: number): boolean {\n            let from = to.mixingFrom;\n            if (from == null) return true;\n\n            let finished = this.updateMixingFrom(from, delta);\n\n            from.animationLast = from.nextAnimationLast;\n            from.trackLast = from.nextTrackLast;\n\n            // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\n            if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n                // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\n                if (from.totalAlpha == 0 || to.mixDuration == 0) {\n                    to.mixingFrom = from.mixingFrom;\n                    if (from.mixingFrom != null) from.mixingFrom.mixingTo = to;\n                    to.interruptAlpha = from.interruptAlpha;\n                    this.queue.end(from);\n                }\n                return finished;\n            }\n\n            from.trackTime += delta * from.timeScale;\n            to.mixTime += delta;\n            return false;\n        }\n\n        /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\n         * animation state can be applied to multiple skeletons to pose them identically.\n         * @returns True if any animations were applied. */\n        apply (skeleton: Skeleton) : boolean {\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            if (this.animationsChanged) this._animationsChanged();\n\n            let events = this.events;\n            let tracks = this.tracks;\n            let applied = false;\n\n            for (let i = 0, n = tracks.length; i < n; i++) {\n                let current = tracks[i];\n                if (current == null || current.delay > 0) continue;\n                applied = true;\n                let blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\n\n                // Apply mixing from entries first.\n                let mix = current.alpha;\n                if (current.mixingFrom != null)\n                    mix *= this.applyMixingFrom(current, skeleton, blend);\n                else if (current.trackTime >= current.trackEnd && current.next == null)\n                    mix = 0;\n\n                // Apply current entry.\n                let animationLast = current.animationLast, animationTime = current.getAnimationTime();\n                let timelineCount = current.animation.timelines.length;\n                let timelines = current.animation.timelines;\n                if ((i == 0 && mix == 1) || blend == MixBlend.add) {\n                    for (let ii = 0; ii < timelineCount; ii++) {\n                        // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\n                        // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\n                        // (https://github.com/pixijs/pixi-spine/issues/302)\n                        Utils.webkit602BugfixHelper(mix, blend);\n                        var timeline = timelines[ii];\n                        if (timeline instanceof AttachmentTimeline)\n                            this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\n                        else\n                            timeline.apply(skeleton, animationLast, animationTime, events, mix, blend, MixDirection.mixIn);\n                    }\n                } else {\n                    let timelineMode = current.timelineMode;\n\n                    let firstFrame = current.timelinesRotation.length == 0;\n                    if (firstFrame) Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n                    let timelinesRotation = current.timelinesRotation;\n\n                    for (let ii = 0; ii < timelineCount; ii++) {\n                        let timeline = timelines[ii];\n                        let timelineBlend = timelineMode[ii]  == AnimationState.SUBSEQUENT ? blend : MixBlend.setup;\n                        if (timeline instanceof RotateTimeline) {\n                            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\n                        } else if (timeline instanceof AttachmentTimeline) {\n                            this.applyAttachmentTimeline(timeline, skeleton, animationTime, blend, true);\n                        } else {\n                            // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                            Utils.webkit602BugfixHelper(mix, blend);\n                            timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, MixDirection.mixIn);\n                        }\n                    }\n                }\n                this.queueEvents(current, animationTime);\n                events.length = 0;\n                current.nextAnimationLast = animationTime;\n                current.nextTrackLast = current.trackTime;\n            }\n\n            // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\n            // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\n            // the time is before the first key).\n            var setupState = this.unkeyedState + AnimationState.SETUP;\n            var slots = skeleton.slots;\n            for (var i = 0, n = skeleton.slots.length; i < n; i++) {\n                var slot = slots[i];\n                if (slot.attachmentState == setupState) {\n                    var attachmentName = slot.data.attachmentName;\n                    slot.attachment = (attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n                }\n            }\n            this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\n\n            this.queue.drain();\n            return applied;\n        }\n\n        applyMixingFrom (to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\n            let from = to.mixingFrom;\n            if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, blend);\n\n            let mix = 0;\n            if (to.mixDuration == 0) { // Single frame mix to undo mixingFrom changes.\n                mix = 1;\n                if (blend == MixBlend.first) blend = MixBlend.setup;\n            } else {\n                mix = to.mixTime / to.mixDuration;\n                if (mix > 1) mix = 1;\n                if (blend != MixBlend.first) blend = from.mixBlend;\n            }\n\n            let events = mix < from.eventThreshold ? this.events : null;\n            let attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\n            let animationLast = from.animationLast, animationTime = from.getAnimationTime();\n            let timelineCount = from.animation.timelines.length;\n            let timelines = from.animation.timelines;\n            let alphaHold = from.alpha * to.interruptAlpha, alphaMix = alphaHold * (1 - mix);\n            if (blend == MixBlend.add) {\n                for (let i = 0; i < timelineCount; i++)\n                    timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, MixDirection.mixOut);\n            } else {\n                let timelineMode = from.timelineMode;\n                let timelineHoldMix = from.timelineHoldMix;\n\n                let firstFrame = from.timelinesRotation.length == 0;\n                if (firstFrame) Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n                let timelinesRotation = from.timelinesRotation;\n\n                from.totalAlpha = 0;\n                for (let i = 0; i < timelineCount; i++) {\n                    let timeline = timelines[i];\n                    let direction = MixDirection.mixOut;\n                    let timelineBlend: MixBlend;\n                    let alpha = 0;\n                    switch (timelineMode[i]) {\n                        case AnimationState.SUBSEQUENT:\n                            if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n                            timelineBlend = blend;\n                            alpha = alphaMix;\n                            break;\n                        case AnimationState.FIRST:\n                            timelineBlend = MixBlend.setup;\n                            alpha = alphaMix;\n                            break;\n                        case AnimationState.HOLD_SUBSEQUENT:\n                            timelineBlend = blend;\n                            alpha = alphaHold;\n                            break;\n                        case AnimationState.HOLD_FIRST:\n                            timelineBlend = MixBlend.setup;\n                            alpha = alphaHold;\n                            break;\n                        default:\n                            timelineBlend = MixBlend.setup;\n                            let holdMix = timelineHoldMix[i];\n                            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n                            break;\n                    }\n                    from.totalAlpha += alpha;\n\n                    if (timeline instanceof RotateTimeline)\n                        this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);\n                    else if (timeline instanceof AttachmentTimeline)\n                        this.applyAttachmentTimeline(timeline, skeleton, animationTime, timelineBlend, attachments);\n                    else {\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                        Utils.webkit602BugfixHelper(alpha, blend);\n                        if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup)\n                            direction = MixDirection.mixIn;\n                        timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\n                    }\n                }\n            }\n\n            if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n            this.events.length = 0;\n            from.nextAnimationLast = animationTime;\n            from.nextTrackLast = from.trackTime;\n\n            return mix;\n        }\n\n        applyAttachmentTimeline (timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\n\n            var slot = skeleton.slots[timeline.slotIndex];\n            if (!slot.bone.active) return;\n\n            var frames = timeline.frames;\n            if (time < frames[0]) { // Time is before first frame.\n                if (blend == MixBlend.setup || blend == MixBlend.first)\n                    this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n            }\n            else {\n                var frameIndex;\n                if (time >= frames[frames.length - 1]) // Time is after last frame.\n                    frameIndex = frames.length - 1;\n                else\n                    frameIndex = Animation.binarySearch(frames, time) - 1;\n                this.setAttachment(skeleton, slot, timeline.attachmentNames[frameIndex], attachments);\n            }\n\n            // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\n            if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + AnimationState.SETUP;\n        }\n\n        setAttachment (skeleton: Skeleton, slot: Slot, attachmentName: string, attachments: boolean) {\n            slot.attachment = attachmentName == null ? null : skeleton.getAttachment(slot.data.index, attachmentName);\n            if (attachments) slot.attachmentState = this.unkeyedState + AnimationState.CURRENT;\n        }\n\n\n        applyRotateTimeline (timeline: Timeline, skeleton: Skeleton, time: number, alpha: number, blend: MixBlend,\n                             timelinesRotation: Array<number>, i: number, firstFrame: boolean) {\n\n            if (firstFrame) timelinesRotation[i] = 0;\n\n            if (alpha == 1) {\n                timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n                return;\n            }\n\n            let rotateTimeline = timeline as RotateTimeline;\n            let frames = rotateTimeline.frames;\n            let bone = skeleton.bones[rotateTimeline.boneIndex];\n            if (!bone.active) return;\n            let r1 = 0, r2 = 0;\n            if (time < frames[0]) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bone.rotation = bone.data.rotation;\n                    default:\n                        return;\n                    case MixBlend.first:\n                        r1 = bone.rotation;\n                        r2 = bone.data.rotation;\n                }\n            } else {\n                r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n                if (time >= frames[frames.length - RotateTimeline.ENTRIES]) // Time is after last frame.\n                    r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\n                else {\n                    // Interpolate between the previous frame and the current frame.\n                    let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n                    let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n                    let frameTime = frames[frame];\n                    let percent = rotateTimeline.getCurvePercent((frame >> 1) - 1,\n                        1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n                    r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n                    r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n                    r2 = prevRotation + r2 * percent + bone.data.rotation;\n                    r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n                }\n            }\n\n            // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\n            let total = 0, diff = r2 - r1;\n            diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\n            if (diff == 0) {\n                total = timelinesRotation[i];\n            } else {\n                let lastTotal = 0, lastDiff = 0;\n                if (firstFrame) {\n                    lastTotal = 0;\n                    lastDiff = diff;\n                } else {\n                    lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\n                    lastDiff = timelinesRotation[i + 1]; // Difference between bones.\n                }\n                let current = diff > 0, dir = lastTotal >= 0;\n                // Detect cross at 0 (not 180).\n                if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n                    // A cross after a 360 rotation is a loop.\n                    if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\n                    dir = current;\n                }\n                total = diff + lastTotal - lastTotal % 360; // Store loops as part of lastTotal.\n                if (dir != current) total += 360 * MathUtils.signum(lastTotal);\n                timelinesRotation[i] = total;\n            }\n            timelinesRotation[i + 1] = diff;\n            r1 += total * alpha;\n            bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\n        }\n\n        queueEvents (entry: TrackEntry, animationTime: number) {\n            let animationStart = entry.animationStart, animationEnd = entry.animationEnd;\n            let duration = animationEnd - animationStart;\n            let trackLastWrapped = entry.trackLast % duration;\n\n            // Queue events before complete.\n            let events = this.events;\n            let i = 0, n = events.length;\n            for (; i < n; i++) {\n                let event = events[i];\n                if (event.time < trackLastWrapped) break;\n                if (event.time > animationEnd) continue; // Discard events outside animation start/end.\n                this.queue.event(entry, event);\n            }\n\n            // Queue complete if completed a loop iteration or the animation.\n            let complete = false;\n            if (entry.loop)\n                complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n            else\n                complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n            if (complete) this.queue.complete(entry);\n\n            // Queue events after complete.\n            for (; i < n; i++) {\n                let event = events[i];\n                if (event.time < animationStart) continue; // Discard events outside animation start/end.\n                this.queue.event(entry, events[i]);\n            }\n        }\n\n        /** Removes all animations from all tracks, leaving skeletons in their current pose.\n         *\n         * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n         * rather than leaving them in their current pose. */\n        clearTracks () {\n            let oldDrainDisabled = this.queue.drainDisabled;\n            this.queue.drainDisabled = true;\n            for (let i = 0, n = this.tracks.length; i < n; i++)\n                this.clearTrack(i);\n            this.tracks.length = 0;\n            this.queue.drainDisabled = oldDrainDisabled;\n            this.queue.drain();\n        }\n\n        /** Removes all animations from the track, leaving skeletons in their current pose.\n         *\n         * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n         * rather than leaving them in their current pose. */\n        clearTrack (trackIndex: number) {\n            if (trackIndex >= this.tracks.length) return;\n            let current = this.tracks[trackIndex];\n            if (current == null) return;\n\n            this.queue.end(current);\n\n            this.disposeNext(current);\n\n            let entry = current;\n            while (true) {\n                let from = entry.mixingFrom;\n                if (from == null) break;\n                this.queue.end(from);\n                entry.mixingFrom = null;\n                entry.mixingTo = null;\n                entry = from;\n            }\n\n            this.tracks[current.trackIndex] = null;\n\n            this.queue.drain();\n        }\n\n        setCurrent (index: number, current: TrackEntry, interrupt: boolean) {\n            let from = this.expandToIndex(index);\n            this.tracks[index] = current;\n\n            if (from != null) {\n                if (interrupt) this.queue.interrupt(from);\n                current.mixingFrom = from;\n                from.mixingTo = current;\n                current.mixTime = 0;\n\n                // Store the interrupted mix percentage.\n                if (from.mixingFrom != null && from.mixDuration > 0)\n                    current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n\n                from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\n            }\n\n            this.queue.start(current);\n        }\n\n        /** Sets an animation by name.\n         *\n         * {@link #setAnimationWith(}. */\n        setAnimation (trackIndex: number, animationName: string, loop: boolean) {\n            let animation = this.data.skeletonData.findAnimation(animationName);\n            if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n            return this.setAnimationWith(trackIndex, animation, loop);\n        }\n\n        /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\n         * applied to a skeleton, it is replaced (not mixed from).\n         * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n         *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\n         * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n         *         after the {@link AnimationStateListener#dispose()} event occurs. */\n        setAnimationWith (trackIndex: number, animation: Animation, loop: boolean) {\n            if (animation == null) throw new Error(\"animation cannot be null.\");\n            let interrupt = true;\n            let current = this.expandToIndex(trackIndex);\n            if (current != null) {\n                if (current.nextTrackLast == -1) {\n                    // Don't mix from an entry that was never applied.\n                    this.tracks[trackIndex] = current.mixingFrom;\n                    this.queue.interrupt(current);\n                    this.queue.end(current);\n                    this.disposeNext(current);\n                    current = current.mixingFrom;\n                    interrupt = false;\n                } else\n                    this.disposeNext(current);\n            }\n            let entry = this.trackEntry(trackIndex, animation, loop, current);\n            this.setCurrent(trackIndex, entry, interrupt);\n            this.queue.drain();\n            return entry;\n        }\n\n        /** Queues an animation by name.\n         *\n         * See {@link #addAnimationWith()}. */\n        addAnimation (trackIndex: number, animationName: string, loop: boolean, delay: number) {\n            let animation = this.data.skeletonData.findAnimation(animationName);\n            if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n            return this.addAnimationWith(trackIndex, animation, loop, delay);\n        }\n\n        /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\n         * equivalent to calling {@link #setAnimationWith()}.\n         * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n         *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\n         *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\n         *           previous entry is looping, its next loop completion is used instead of its duration.\n         * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n         *         after the {@link AnimationStateListener#dispose()} event occurs. */\n        addAnimationWith (trackIndex: number, animation: Animation, loop: boolean, delay: number) {\n            if (animation == null) throw new Error(\"animation cannot be null.\");\n\n            let last = this.expandToIndex(trackIndex);\n            if (last != null) {\n                while (last.next != null)\n                    last = last.next;\n            }\n\n            let entry = this.trackEntry(trackIndex, animation, loop, last);\n\n            if (last == null) {\n                this.setCurrent(trackIndex, entry, true);\n                this.queue.drain();\n            } else {\n                last.next = entry;\n                if (delay <= 0) {\n                    let duration = last.animationEnd - last.animationStart;\n                    if (duration != 0) {\n                        if (last.loop)\n                            delay += duration * (1 + ((last.trackTime / duration) | 0));\n                        else\n                            delay += Math.max(duration, last.trackTime);\n                        delay -= this.data.getMix(last.animation, animation);\n                    } else\n                        delay = last.trackTime;\n                }\n            }\n\n            entry.delay = delay;\n            return entry;\n        }\n\n        /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\n         * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\n         *\n         * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\n         * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\n         * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\n         * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\n         * 0 still mixes out over one frame.\n         *\n         * Mixing in is done by first setting an empty animation, then adding an animation using\n         * {@link #addAnimation()} and on the returned track entry, set the\n         * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\n         * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\n         * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\n        setEmptyAnimation (trackIndex: number, mixDuration: number) {\n            let entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\n            entry.mixDuration = mixDuration;\n            entry.trackEnd = mixDuration;\n            return entry;\n        }\n\n        /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\n         * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\n         * {@link #setEmptyAnimation()}.\n         *\n         * See {@link #setEmptyAnimation()}.\n         * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n         *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\n         *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\n         *           loop completion is used instead of its duration.\n         * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\n         *         after the {@link AnimationStateListener#dispose()} event occurs. */\n        addEmptyAnimation (trackIndex: number, mixDuration: number, delay: number) {\n            if (delay <= 0) delay -= mixDuration;\n            let entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\n            entry.mixDuration = mixDuration;\n            entry.trackEnd = mixDuration;\n            return entry;\n        }\n\n        /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\n         * duration. */\n        setEmptyAnimations (mixDuration: number) {\n            let oldDrainDisabled = this.queue.drainDisabled;\n            this.queue.drainDisabled = true;\n            for (let i = 0, n = this.tracks.length; i < n; i++) {\n                let current = this.tracks[i];\n                if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\n            }\n            this.queue.drainDisabled = oldDrainDisabled;\n            this.queue.drain();\n        }\n\n        expandToIndex (index: number) {\n            if (index < this.tracks.length) return this.tracks[index];\n            Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n            this.tracks.length = index + 1;\n            return null;\n        }\n\n        /** @param last May be null. */\n        trackEntry (trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry) {\n            let entry = this.trackEntryPool.obtain();\n            entry.trackIndex = trackIndex;\n            entry.animation = animation;\n            entry.loop = loop;\n            entry.holdPrevious = false;\n\n            entry.eventThreshold = 0;\n            entry.attachmentThreshold = 0;\n            entry.drawOrderThreshold = 0;\n\n            entry.animationStart = 0;\n            entry.animationEnd = animation.duration;\n            entry.animationLast = -1;\n            entry.nextAnimationLast = -1;\n\n            entry.delay = 0;\n            entry.trackTime = 0;\n            entry.trackLast = -1;\n            entry.nextTrackLast = -1;\n            entry.trackEnd = Number.MAX_VALUE;\n            entry.timeScale = 1;\n\n            entry.alpha = 1;\n            entry.interruptAlpha = 1;\n            entry.mixTime = 0;\n            entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n            entry.mixBlend = MixBlend.replace;\n            return entry;\n        }\n\n        disposeNext (entry: TrackEntry) {\n            let next = entry.next;\n            while (next != null) {\n                this.queue.dispose(next);\n                next = next.next;\n            }\n            entry.next = null;\n        }\n\n        _animationsChanged () {\n            this.animationsChanged = false;\n\n            this.propertyIDs.clear();\n\n            for (let i = 0, n = this.tracks.length; i < n; i++) {\n                let entry = this.tracks[i];\n                if (entry == null) continue;\n                while (entry.mixingFrom != null)\n                    entry = entry.mixingFrom;\n\n                do {\n                    if (entry.mixingFrom == null || entry.mixBlend != MixBlend.add) this.computeHold(entry);\n                    entry = entry.mixingTo;\n                } while (entry != null)\n            }\n        }\n\n        computeHold (entry: TrackEntry) {\n            let to = entry.mixingTo;\n            let timelines = entry.animation.timelines;\n            let timelinesCount = entry.animation.timelines.length;\n            let timelineMode = Utils.setArraySize(entry.timelineMode, timelinesCount);\n            entry.timelineHoldMix.length = 0;\n            let timelineDipMix = Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\n            let propertyIDs = this.propertyIDs;\n\n            if (to != null && to.holdPrevious) {\n                for (let i = 0; i < timelinesCount; i++) {\n                    timelineMode[i] = propertyIDs.add(timelines[i].getPropertyId()) ? AnimationState.HOLD_FIRST : AnimationState.HOLD_SUBSEQUENT;\n                }\n                return;\n            }\n\n            outer:\n                for (let i = 0; i < timelinesCount; i++) {\n                    let timeline = timelines[i];\n                    let id = timeline.getPropertyId();\n                    if (!propertyIDs.add(id))\n                        timelineMode[i] = AnimationState.SUBSEQUENT;\n                    else if (to == null || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline\n                        || timeline instanceof EventTimeline || !to.animation.hasTimeline(id)) {\n                        timelineMode[i] = AnimationState.FIRST;\n                    } else {\n                        for (let next = to.mixingTo; next != null; next = next.mixingTo) {\n                            if (next.animation.hasTimeline(id)) continue;\n                            if (entry.mixDuration > 0) {\n                                timelineMode[i] = AnimationState.HOLD_MIX;\n                                timelineDipMix[i] = next;\n                                continue outer;\n                            }\n                            break;\n                        }\n                        timelineMode[i] = AnimationState.HOLD_FIRST;\n                    }\n                }\n        }\n\n        /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\n        getCurrent (trackIndex: number) {\n            if (trackIndex >= this.tracks.length) return null;\n            return this.tracks[trackIndex];\n        }\n\n        /** Adds a listener to receive events for all track entries. */\n        addListener (listener: AnimationStateListener) {\n            if (listener == null) throw new Error(\"listener cannot be null.\");\n            this.listeners.push(listener);\n        }\n\n        /** Removes the listener added with {@link #addListener()}. */\n        removeListener (listener: AnimationStateListener) {\n            let index = this.listeners.indexOf(listener);\n            if (index >= 0) this.listeners.splice(index, 1);\n        }\n\n        /** Removes all listeners added with {@link #addListener()}. */\n        clearListeners () {\n            this.listeners.length = 0;\n        }\n\n        /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\n         * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\n         * are not wanted because new animations are being set. */\n        clearListenerNotifications () {\n            this.queue.clear();\n        }\n\n        //deprecated stuff\n        onComplete: (trackIndex: number, loopCount: number) => any;\n        onEvent: (trackIndex: number, event: Event) => any;\n        onStart: (trackIndex: number) => any;\n        onEnd: (trackIndex: number) => any;\n\n        private static deprecatedWarning1: boolean = false;\n\n        setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\n            if (!AnimationState.deprecatedWarning1) {\n                AnimationState.deprecatedWarning1 = true;\n                console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\n            }\n            this.setAnimation(trackIndex, animationName, loop);\n        }\n\n        private static deprecatedWarning2: boolean = false;\n\n        addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n            if (!AnimationState.deprecatedWarning2) {\n                AnimationState.deprecatedWarning2 = true;\n                console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\n            }\n            this.addAnimation(trackIndex, animationName, loop, delay);\n        }\n\n        private static deprecatedWarning3: boolean = false;\n\n        hasAnimation(animationName: string): boolean {\n            let animation = this.data.skeletonData.findAnimation(animationName);\n            return animation !== null;\n        }\n\n        hasAnimationByName(animationName: string): boolean {\n            if (!AnimationState.deprecatedWarning3) {\n                AnimationState.deprecatedWarning3 = true;\n                console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\n            }\n            return this.hasAnimation(animationName);\n        }\n    }\n\n    /** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\n     *\n     * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs. */\n    export class TrackEntry {\n        /** The animation to apply for this track entry. */\n        animation: Animation;\n\n        /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\n        next: TrackEntry;\n\n        /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\n         * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\n        mixingFrom: TrackEntry;\n\n        /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\n         * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\n        mixingTo: TrackEntry;\n\n        /** The listener for events generated by this track entry, or null.\n         *\n         * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\n         * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\n        listener: AnimationStateListener;\n\n        /** The index of the track where this track entry is either current or queued.\n         *\n         * See {@link AnimationState#getCurrent()}. */\n        trackIndex: number;\n\n        /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n         * duration. */\n        loop: boolean;\n\n        /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\n         * of being mixed out.\n         *\n         * When mixing between animations that key the same property, if a lower track also keys that property then the value will\n         * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\n         * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\n         * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\n         * keys the property, only when a higher track also keys the property.\n         *\n         * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\n         * previous animation. */\n        holdPrevious: boolean;\n\n        /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n         * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\n         * timelines are not applied while this animation is being mixed out. */\n        eventThreshold: number;\n\n        /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\n         * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\n         * 0, so attachment timelines are not applied while this animation is being mixed out. */\n        attachmentThreshold: number;\n\n        /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n         * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\n         * so draw order timelines are not applied while this animation is being mixed out. */\n        drawOrderThreshold: number;\n\n        /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\n         *\n         * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\n         * value to prevent timeline keys before the start time from triggering. */\n        animationStart: number;\n\n        /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\n         * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\n        animationEnd: number;\n\n\n        /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\n         * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\n         * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\n         * is applied. */\n        animationLast: number;\n\n        nextAnimationLast: number;\n\n        /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\n         * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\n         * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\n         * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\n         *\n         * {@link #timeScale} affects the delay. */\n        delay: number;\n\n        /** Current time in seconds this track entry has been the current track entry. The track time determines\n         * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\n         * looping. */\n        trackTime: number;\n\n        trackLast: number; nextTrackLast: number;\n\n        /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\n         * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\n         * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\n         * properties keyed by the animation are set to the setup pose and the track is cleared.\n         *\n         * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\n         * abruptly cease being applied. */\n        trackEnd: number;\n\n        /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\n         * faster. Defaults to 1.\n         *\n         * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\n         * match the animation speed.\n         *\n         * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n         * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\n         * the time scale is not 1, the delay may need to be adjusted.\n         *\n         * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\n        timeScale: number;\n\n        /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\n         * to 1, which overwrites the skeleton's current pose with this animation.\n         *\n         * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\n         * use alpha on track 0 if the skeleton pose is from the last frame render. */\n        alpha: number;\n\n        /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\n         * slightly more than `mixDuration` when the mix is complete. */\n        mixTime: number;\n\n        /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\n         * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\n         *\n         * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\n         * properties it was animating.\n         *\n         * The `mixDuration` can be set manually rather than use the value from\n         * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\n         * track entry only before {@link AnimationState#update(float)} is first called.\n         *\n         * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n         * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\n         * afterward. */\n        mixDuration: number; interruptAlpha: number; totalAlpha: number;\n\n        /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\n         * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\n         * the values from the lower tracks.\n         *\n         * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\n         * called. */\n        mixBlend = MixBlend.replace;\n        timelineMode = new Array<number>();\n        timelineHoldMix = new Array<TrackEntry>();\n        timelinesRotation = new Array<number>();\n\n        reset () {\n            this.next = null;\n            this.mixingFrom = null;\n            this.mixingTo = null;\n            this.animation = null;\n            this.listener = null;\n            this.timelineMode.length = 0;\n            this.timelineHoldMix.length = 0;\n            this.timelinesRotation.length = 0;\n        }\n\n        /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\n         * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\n         * `animationStart` time. */\n        getAnimationTime () {\n            if (this.loop) {\n                let duration = this.animationEnd - this.animationStart;\n                if (duration == 0) return this.animationStart;\n                return (this.trackTime % duration) + this.animationStart;\n            }\n            return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n        }\n\n        setAnimationLast(animationLast: number) {\n            this.animationLast = animationLast;\n            this.nextAnimationLast = animationLast;\n        }\n\n        /** Returns true if at least one loop has been completed.\n         *\n         * See {@link AnimationStateListener#complete()}. */\n        isComplete () {\n            return this.trackTime >= this.animationEnd - this.animationStart;\n        }\n\n        /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\n         * long way around when using {@link #alpha} and starting animations on other tracks.\n         *\n         * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\n         * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\n         * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\n         * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\n        resetRotationDirections () {\n            this.timelinesRotation.length = 0;\n        }\n\n        //deprecated stuff\n        onComplete: (trackIndex: number, loopCount: number) => any;\n        onEvent: (trackIndex: number, event: Event) => any;\n        onStart: (trackIndex: number) => any;\n        onEnd: (trackIndex: number) => any;\n\n        private static deprecatedWarning1: Boolean = false;\n        private static deprecatedWarning2: Boolean = false;\n\n        get time() {\n            if (!TrackEntry.deprecatedWarning1) {\n                TrackEntry.deprecatedWarning1 = true;\n                console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n            }\n            return this.trackTime;\n        }\n\n        set time(value: number) {\n            if (!TrackEntry.deprecatedWarning1) {\n                TrackEntry.deprecatedWarning1 = true;\n                console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n            }\n            this.trackTime = value;\n        }\n\n        get endTime() {\n            if (!TrackEntry.deprecatedWarning2) {\n                TrackEntry.deprecatedWarning2 = true;\n                console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n            }\n            return this.trackTime;\n        }\n\n        set endTime(value: number) {\n            if (!TrackEntry.deprecatedWarning2) {\n                TrackEntry.deprecatedWarning2 = true;\n                console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n            }\n            this.trackTime = value;\n        }\n\n        loopsCount() {\n            return Math.floor(this.trackTime / this.trackEnd);\n        }\n    }\n\n    export class EventQueue {\n        objects: Array<any> = [];\n        drainDisabled = false;\n        animState: AnimationState;\n\n        constructor(animState: AnimationState) {\n            this.animState = animState;\n        }\n\n        start (entry: TrackEntry) {\n            this.objects.push(EventType.start);\n            this.objects.push(entry);\n            this.animState.animationsChanged = true;\n        }\n\n        interrupt (entry: TrackEntry) {\n            this.objects.push(EventType.interrupt);\n            this.objects.push(entry);\n        }\n\n        end (entry: TrackEntry) {\n            this.objects.push(EventType.end);\n            this.objects.push(entry);\n            this.animState.animationsChanged = true;\n        }\n\n        dispose (entry: TrackEntry) {\n            this.objects.push(EventType.dispose);\n            this.objects.push(entry);\n        }\n\n        complete (entry: TrackEntry) {\n            this.objects.push(EventType.complete);\n            this.objects.push(entry);\n        }\n\n        event (entry: TrackEntry, event: Event) {\n            this.objects.push(EventType.event);\n            this.objects.push(entry);\n            this.objects.push(event);\n        }\n\n        private static deprecatedWarning1: Boolean = false;\n\n        deprecateStuff() {\n            if (!EventQueue.deprecatedWarning1) {\n                EventQueue.deprecatedWarning1 = true;\n                console.warn(\"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\");\n            }\n            return true;\n        }\n\n        drain () {\n            if (this.drainDisabled) return;\n            this.drainDisabled = true;\n\n            let objects = this.objects;\n            let listeners = this.animState.listeners;\n\n            for (let i = 0; i < objects.length; i += 2) {\n                let type = objects[i] as EventType;\n                let entry = objects[i + 1] as TrackEntry;\n                switch (type) {\n                    case EventType.start:\n                        if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].start) listeners[ii].start(entry);\n                        //deprecation\n                        entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\n                        this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\n                        break;\n                    case EventType.interrupt:\n                        if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\n                        break;\n                    case EventType.end:\n                        if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].end) listeners[ii].end(entry);\n                        //deprecation\n                        entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\n                        this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\n                    // Fall through.\n                    case EventType.dispose:\n                        if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].dispose) listeners[ii].dispose(entry);\n                        this.animState.trackEntryPool.free(entry);\n                        break;\n                    case EventType.complete:\n                        if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].complete) listeners[ii].complete(entry);\n                        //deprecation\n\n                        let count = MathUtils.toInt(entry.loopsCount()) ;\n                        entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\n                        this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\n                        break;\n                    case EventType.event:\n                        let event = objects[i++ + 2] as Event;\n                        if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].event) listeners[ii].event(entry, event);\n                        //deprecation\n                        entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);\n                        this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);\n                        break;\n                }\n            }\n            this.clear();\n\n            this.drainDisabled = false;\n        }\n\n        clear () {\n            this.objects.length = 0;\n        }\n    }\n\n    export enum EventType {\n        start, interrupt, end, dispose, complete, event\n    }\n\n    export interface AnimationStateListener {\n        /** Invoked when this entry has been set as the current entry. */\n        start? (entry: TrackEntry): void;\n\n        /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\n         * mixing. */\n        interrupt? (entry: TrackEntry): void;\n\n        /** Invoked when this entry is no longer the current entry and will never be applied again. */\n        end? (entry: TrackEntry): void;\n\n        /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\n         * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\n        dispose? (entry: TrackEntry): void;\n\n        /** Invoked every time this entry's animation completes a loop. */\n        complete? (entry: TrackEntry): void;\n\n        /** Invoked when this entry's animation triggers an event. */\n        event? (entry: TrackEntry, event: Event): void;\n    }\n\n    export abstract class AnimationStateAdapter implements AnimationStateListener {\n        start (entry: TrackEntry) {\n        }\n\n        interrupt (entry: TrackEntry) {\n        }\n\n        end (entry: TrackEntry) {\n        }\n\n        dispose (entry: TrackEntry) {\n        }\n\n        complete (entry: TrackEntry) {\n        }\n\n        event (entry: TrackEntry, event: Event) {\n        }\n    }\n}\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class AnimationStateData {\r\n        skeletonData: SkeletonData;\r\n        animationToMixTime: Map<number> = {};\r\n        defaultMix = 0;\r\n\r\n        constructor(skeletonData: SkeletonData) {\r\n            if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\r\n            this.skeletonData = skeletonData;\r\n        }\r\n\r\n        setMix(fromName: string, toName: string, duration: number) {\r\n            let from = this.skeletonData.findAnimation(fromName);\r\n            if (from == null) throw new Error(\"Animation not found: \" + fromName);\r\n            let to = this.skeletonData.findAnimation(toName);\r\n            if (to == null) throw new Error(\"Animation not found: \" + toName);\r\n            this.setMixWith(from, to, duration);\r\n        }\r\n\r\n        private static deprecatedWarning1: boolean = false;\r\n\r\n        setMixByName(fromName: string, toName: string, duration: number) {\r\n            if (!AnimationStateData.deprecatedWarning1) {\r\n                AnimationStateData.deprecatedWarning1 = true;\r\n                console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\r\n            }\r\n            this.setMix(fromName, toName, duration);\r\n        }\r\n\r\n        setMixWith(from: Animation, to: Animation, duration: number) {\r\n            if (from == null) throw new Error(\"from cannot be null.\");\r\n            if (to == null) throw new Error(\"to cannot be null.\");\r\n            let key = from.name + \".\" + to.name;\r\n            this.animationToMixTime[key] = duration;\r\n        }\r\n\r\n        getMix(from: Animation, to: Animation) {\r\n            let key = from.name + \".\" + to.name;\r\n            let value = this.animationToMixTime[key];\r\n            return value === undefined ? this.defaultMix : value;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class AtlasAttachmentLoader implements AttachmentLoader {\r\n        atlas: TextureAtlas;\r\n\r\n        constructor(atlas: TextureAtlas) {\r\n            this.atlas = atlas;\r\n        }\r\n\r\n        /** @return May be null to not load an attachment. */\r\n        newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment {\r\n            let region = this.atlas.findRegion(path);\r\n            if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\r\n            let attachment = new RegionAttachment(name);\r\n            attachment.region = region;\r\n            return attachment;\r\n        }\r\n\r\n        /** @return May be null to not load an attachment. */\r\n        newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment {\r\n            let region = this.atlas.findRegion(path);\r\n            if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\r\n            let attachment = new MeshAttachment(name);\r\n            attachment.region = region;\r\n            return attachment;\r\n        }\r\n\r\n        /** @return May be null to not load an attachment. */\r\n        newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\r\n            return new BoundingBoxAttachment(name);\r\n        }\r\n\r\n        /** @return May be null to not load an attachment */\r\n        newPathAttachment(skin: Skin, name: string): PathAttachment {\r\n            return new PathAttachment(name);\r\n        }\r\n\r\n        newPointAttachment(skin: Skin, name: string): PointAttachment {\r\n            return new PointAttachment(name);\r\n        }\r\n\r\n        newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\r\n            return new ClippingAttachment(name);\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export enum BlendMode {\r\n        Normal = 0,\r\n        Additive = 1,\r\n        Multiply = 2,\r\n        Screen = 3\r\n    }\r\n}\r\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Bone implements Updatable {\n        static yDown: boolean = false;\n        //be careful! Spine b,c is c,b in pixi matrix\n        matrix = new PIXI.Matrix();\n\n        get worldX(): number {\n            return this.matrix.tx;\n        }\n\n        get worldY(): number {\n            return this.matrix.ty;\n        }\n\n        data: BoneData;\n        skeleton: Skeleton;\n        parent: Bone;\n        children = new Array<Bone>();\n        x = 0;\n        y = 0;\n        rotation = 0;\n        scaleX = 0;\n        scaleY = 0;\n        shearX = 0;\n        shearY = 0;\n        ax = 0;\n        ay = 0;\n        arotation = 0;\n        ascaleX = 0;\n        ascaleY = 0;\n        ashearX = 0;\n        ashearY = 0;\n        appliedValid = false;\n\n        sorted = false;\n        active = false;\n\n        /** @param parent May be null. */\n        constructor(data: BoneData, skeleton: Skeleton, parent: Bone) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.skeleton = skeleton;\n            this.parent = parent;\n            this.setToSetupPose();\n        }\n\n        isActive () {\n            return this.active;\n        }\n\n        /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\n        update() {\n            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n        }\n\n        /** Computes the world transform using the parent bone and this bone's local transform. */\n        updateWorldTransform() {\n            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n        }\n\n        /** Computes the world transform using the parent bone and the specified local transform. */\n        updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n            this.ax = x;\n            this.ay = y;\n            this.arotation = rotation;\n            this.ascaleX = scaleX;\n            this.ascaleY = scaleY;\n            this.ashearX = shearX;\n            this.ashearY = shearY;\n            this.appliedValid = true;\n\n            let parent = this.parent;\n            let m = this.matrix;\n\n            let sx = this.skeleton.scaleX;\n            let sy = Bone.yDown? -this.skeleton.scaleY : this.skeleton.scaleY;\n\n            if (parent == null) { // Root bone.\n                let skeleton = this.skeleton;\n                let rotationY = rotation + 90 + shearY;\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n                m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n                m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n                m.tx = x * sx + skeleton.x;\n                m.ty = y * sy + skeleton.y;\n                return;\n            }\n\n            let pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\n            m.tx = pa * x + pb * y + parent.matrix.tx;\n            m.ty = pc * x + pd * y + parent.matrix.ty;\n            switch (this.data.transformMode) {\n                case TransformMode.Normal: {\n                    let rotationY = rotation + 90 + shearY;\n                    let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                    let lb = MathUtils.cosDeg(rotationY) * scaleY;\n                    let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                    let ld = MathUtils.sinDeg(rotationY) * scaleY;\n                    m.a = pa * la + pb * lc;\n                    m.c = pa * lb + pb * ld;\n                    m.b = pc * la + pd * lc;\n                    m.d = pc * lb + pd * ld;\n                    return;\n                }\n                case TransformMode.OnlyTranslation: {\n                    let rotationY = rotation + 90 + shearY;\n                    m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                    m.c = MathUtils.cosDeg(rotationY) * scaleY;\n                    m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                    m.d = MathUtils.sinDeg(rotationY) * scaleY;\n                    break;\n                }\n                case TransformMode.NoRotationOrReflection: {\n                    let s = pa * pa + pc * pc;\n                    let prx = 0;\n                    if (s > 0.0001) {\n                        pa /= this.skeleton.scaleX;\n                        pc /= this.skeleton.scaleY;\n                        s = Math.abs(pa * pd - pb * pc) / s;\n                        pb = pc * s;\n                        pd = pa * s;\n                        prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n                    } else {\n                        pa = 0;\n                        pc = 0;\n                        prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n                    }\n                    let rx = rotation + shearX - prx;\n                    let ry = rotation + shearY - prx + 90;\n                    let la = MathUtils.cosDeg(rx) * scaleX;\n                    let lb = MathUtils.cosDeg(ry) * scaleY;\n                    let lc = MathUtils.sinDeg(rx) * scaleX;\n                    let ld = MathUtils.sinDeg(ry) * scaleY;\n                    m.a = pa * la - pb * lc;\n                    m.c = pa * lb - pb * ld;\n                    m.b = pc * la + pd * lc;\n                    m.d = pc * lb + pd * ld;\n                    break;\n                }\n                case TransformMode.NoScale:\n                case TransformMode.NoScaleOrReflection: {\n                    let cos = MathUtils.cosDeg(rotation);\n                    let sin = MathUtils.sinDeg(rotation);\n                    let za = (pa * cos + pb * sin) / sx;\n                    let zc = (pc * cos + pd * sin) / sy;\n                    let s = Math.sqrt(za * za + zc * zc);\n                    if (s > 0.00001) s = 1 / s;\n                    za *= s;\n                    zc *= s;\n                    s = Math.sqrt(za * za + zc * zc);\n                    if (\n                        this.data.transformMode == TransformMode.NoScale\n                        && (pa * pd - pb * pc < 0) != (Bone.yDown?\n                        (this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0) :\n                            (this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0))\n                    ) s = -s;\n                    let r = Math.PI / 2 + Math.atan2(zc, za);\n                    let zb = Math.cos(r) * s;\n                    let zd = Math.sin(r) * s;\n                    let la = MathUtils.cosDeg(shearX) * scaleX;\n                    let lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n                    let lc = MathUtils.sinDeg(shearX) * scaleX;\n                    let ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n                    m.a = za * la + zb * lc;\n                    m.c = za * lb + zb * ld;\n                    m.b = zc * la + zd * lc;\n                    m.d = zc * lb + zd * ld;\n                    break;\n                }\n            }\n            m.a *= sx;\n            m.c *= sx;\n            m.b *= sy;\n            m.d *= sy;\n        }\n\n        setToSetupPose() {\n            let data = this.data;\n            this.x = data.x;\n            this.y = data.y;\n            this.rotation = data.rotation;\n            this.scaleX = data.scaleX;\n            this.scaleY = data.scaleY;\n            this.shearX = data.shearX;\n            this.shearY = data.shearY;\n        }\n\n        getWorldRotationX() {\n            return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n        }\n\n        getWorldRotationY() {\n            return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n        }\n\n        getWorldScaleX() {\n            let m = this.matrix;\n            return Math.sqrt(m.a * m.a + m.c * m.c);\n        }\n\n        getWorldScaleY() {\n            let m = this.matrix;\n            return Math.sqrt(m.b * m.b + m.d * m.d);\n        }\n\n        /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\n         * the applied transform after the world transform has been modified directly (eg, by a constraint).\n         * <p>\n         * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\n        updateAppliedTransform() {\n            this.appliedValid = true;\n            let parent = this.parent;\n            let m = this.matrix;\n            if (parent == null) {\n                this.ax = m.tx;\n                this.ay = m.ty;\n                this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n                this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n                this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n                this.ashearX = 0;\n                this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n                return;\n            }\n            let pm = parent.matrix;\n            let pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n            let dx = m.tx - pm.tx, dy = m.ty - pm.ty;\n            this.ax = (dx * pm.d * pid - dy * pm.c * pid);\n            this.ay = (dy * pm.a * pid - dx * pm.b * pid);\n            let ia = pid * pm.d;\n            let id = pid * pm.a;\n            let ib = pid * pm.c;\n            let ic = pid * pm.b;\n            let ra = ia * m.a - ib * m.b;\n            let rb = ia * m.c - ib * m.d;\n            let rc = id * m.b - ic * m.a;\n            let rd = id * m.d - ic * m.c;\n            this.ashearX = 0;\n            this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n            if (this.ascaleX > 0.0001) {\n                let det = ra * rd - rb * rc;\n                this.ascaleY = det / this.ascaleX;\n                this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n                this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n            } else {\n                this.ascaleX = 0;\n                this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n                this.ashearY = 0;\n                this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n            }\n        }\n\n        worldToLocal(world: Vector2) {\n            let m = this.matrix;\n            let a = m.a, b = m.c, c = m.b, d = m.d;\n            let invDet = 1 / (a * d - b * c);\n            let x = world.x - m.tx, y = world.y - m.ty;\n            world.x = (x * d * invDet - y * b * invDet);\n            world.y = (y * a * invDet - x * c * invDet);\n            return world;\n        }\n\n        localToWorld(local: Vector2) {\n            let m = this.matrix;\n            let x = local.x, y = local.y;\n            local.x = x * m.a + y * m.c + m.tx;\n            local.y = x * m.b + y * m.d + m.ty;\n            return local;\n        }\n\n        worldToLocalRotation (worldRotation: number) {\n            let sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);\n            let mat = this.matrix;\n            return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n        }\n\n        localToWorldRotation (localRotation: number) {\n            let sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);\n            let mat = this.matrix;\n            return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n        }\n\n        rotateWorld (degrees: number) {\n            let mat = this.matrix;\n            let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n            let cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);\n            mat.a = cos * a - sin * c;\n            mat.c = cos * b - sin * d;\n            mat.b = sin * a + cos * c;\n            mat.d = sin * b + cos * d;\n            this.appliedValid = false;\n        }\n    }\n}\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class BoneData {\r\n        index: number;\r\n        name: string;\r\n        parent: BoneData;\r\n        length: number;\r\n        x = 0;\r\n        y = 0;\r\n        rotation = 0;\r\n        scaleX = 1;\r\n        scaleY = 1;\r\n        shearX = 0;\r\n        shearY = 0;\r\n        transformMode = TransformMode.Normal;\r\n        skinRequired = false;\r\n\r\n        color = new Color();\r\n\r\n        constructor(index: number, name: string, parent: BoneData) {\r\n            if (index < 0) throw new Error(\"index must be >= 0.\");\r\n            if (name == null) throw new Error(\"name cannot be null.\");\r\n            this.index = index;\r\n            this.name = name;\r\n            this.parent = parent;\r\n        }\r\n    }\r\n\r\n    export enum TransformMode {\r\n        Normal, OnlyTranslation, NoRotationOrReflection, NoScale, NoScaleOrReflection\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License v2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export abstract class ConstraintData {\r\n        constructor(public name: string, public order: number, public skinRequired: boolean) { }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class Event {\r\n        data: EventData;\r\n        intValue: number;\r\n        floatValue: number;\r\n        stringValue: string;\r\n        time: number;\r\n        volume: number;\r\n        balance: number;\r\n\r\n\r\n        constructor(time: number, data: EventData) {\r\n            if (data == null) throw new Error(\"data cannot be null.\");\r\n            this.time = time;\r\n            this.data = data;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class EventData {\r\n        name: string;\r\n        intValue: number;\r\n        floatValue: number;\r\n        stringValue: string;\r\n        audioPath: string;\r\n        volume: number;\r\n        balance: number;\r\n\r\n        constructor (name: string) {\r\n            this.name = name;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class IkConstraint implements Updatable {\n        data: IkConstraintData;\n        bones: Array<Bone>;\n        target: Bone;\n        bendDirection = 0;\n        compress = false;\n        stretch = false;\n        mix = 1;\n        softness = 0;\n        active = false;\n\n        constructor (data: IkConstraintData, skeleton: Skeleton) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.mix = data.mix;\n            this.softness = data.softness;\n            this.bendDirection = data.bendDirection;\n            this.compress = data.compress;\n            this.stretch = data.stretch;\n\n            this.bones = new Array<Bone>();\n            for (let i = 0; i < data.bones.length; i++)\n                this.bones.push(skeleton.findBone(data.bones[i].name));\n            this.target = skeleton.findBone(data.target.name);\n        }\n\n        isActive () {\n            return this.active;\n        }\n\n        apply () {\n            this.update();\n        }\n\n        update () {\n            let target = this.target;\n            let bones = this.bones;\n            switch (bones.length) {\n                case 1:\n                    this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n                    break;\n                case 2:\n                    this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.softness, this.mix);\n                    break;\n            }\n        }\n\n        /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n         * coordinate system. */\n        apply1 (bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\n            if (!bone.appliedValid) bone.updateAppliedTransform();\n            let p = bone.parent.matrix;\n\n\n            let pa = p.a, pb = p.c, pc = p.b, pd = p.d;\n            let rotationIK = -bone.ashearX - bone.arotation, tx = 0, ty = 0;\n\n            switch(bone.data.transformMode) {\n                case TransformMode.OnlyTranslation:\n                    tx = targetX - bone.worldX;\n                    ty = targetY - bone.worldY;\n                    break;\n                case TransformMode.NoRotationOrReflection:\n                    let s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\n                    let sa = pa / bone.skeleton.scaleX;\n                    let sc = pc / bone.skeleton.scaleY;\n                    pb = -sc * s * bone.skeleton.scaleX;\n                    pd = sa * s * bone.skeleton.scaleY;\n                    rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\n                // Fall through\n                default:\n                    let x = targetX - p.tx, y = targetY - p.ty;\n                    let d = pa * pd - pb * pc;\n                    tx = (x * pd - y * pb) / d - bone.ax;\n                    ty = (y * pa - x * pc) / d - bone.ay;\n            }\n            rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\n\n            if (bone.ascaleX < 0) rotationIK += 180;\n            if (rotationIK > 180)\n                rotationIK -= 360;\n            else if (rotationIK < -180) rotationIK += 360;\n            let sx = bone.ascaleX, sy = bone.ascaleY;\n            if (compress || stretch) {\n                switch (bone.data.transformMode) {\n                    case TransformMode.NoScale:\n                    case TransformMode.NoScaleOrReflection:\n                        tx = targetX - bone.worldX;\n                        ty = targetY - bone.worldY;\n                }\n                let b = bone.data.length * sx, dd = Math.sqrt(tx * tx + ty * ty);\n                if ((compress && dd < b) || (stretch && dd > b) && b > 0.0001) {\n                    let s = (dd / b - 1) * alpha + 1;\n                    sx *= s;\n                    if (uniform) sy *= s;\n                }\n            }\n            bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX,\n                bone.ashearY);\n        }\n\n        /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n         * target is specified in the world coordinate system.\n         * @param child A direct descendant of the parent bone. */\n        apply2 (parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, softness: number, alpha: number) {\n            if (alpha == 0) {\n                child.updateWorldTransform();\n                return;\n            }\n            if (!parent.appliedValid) parent.updateAppliedTransform();\n            if (!child.appliedValid) child.updateAppliedTransform();\n            let px = parent.ax, py = parent.ay, psx = parent.ascaleX, sx = psx, psy = parent.ascaleY, csx = child.ascaleX;\n            let pmat = parent.matrix;\n            let os1 = 0, os2 = 0, s2 = 0;\n            if (psx < 0) {\n                psx = -psx;\n                os1 = 180;\n                s2 = -1;\n            } else {\n                os1 = 0;\n                s2 = 1;\n            }\n            if (psy < 0) {\n                psy = -psy;\n                s2 = -s2;\n            }\n            if (csx < 0) {\n                csx = -csx;\n                os2 = 180;\n            } else\n                os2 = 0;\n            let cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pmat.a, b = pmat.c, c = pmat.b, d = pmat.d;\n            let u = Math.abs(psx - psy) <= 0.0001;\n            if (!u) {\n                cy = 0;\n                cwx = a * cx + pmat.tx;\n                cwy = c * cx + pmat.ty;\n            } else {\n                cy = child.ay;\n                cwx = a * cx + b * cy + pmat.tx;\n                cwy = c * cx + d * cy + pmat.ty;\n            }\n            let pp = parent.parent.matrix;\n            a = pp.a;\n            b = pp.c;\n            c = pp.b;\n            d = pp.d;\n            let id = 1 / (a * d - b * c), x = cwx - pp.tx, y = cwy - pp.ty;\n            let dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\n            let l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\n            if (l1 < 0.0001) {\n                this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n                child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n                return;\n            }\n            x = targetX - pp.tx;\n            y = targetY - pp.ty;\n            let tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\n            let dd = tx * tx + ty * ty;\n            if (softness != 0) {\n                softness *= psx * (csx + 1) / 2;\n                let td = Math.sqrt(dd), sd = td - l1 - l2 * psx + softness;\n                if (sd > 0) {\n                    let p = Math.min(1, sd / (softness * 2)) - 1;\n                    p = (sd - softness * (1 - p * p)) / td;\n                    tx -= p * tx;\n                    ty -= p * ty;\n                    dd = tx * tx + ty * ty;\n                }\n            }\n            outer:\n                if (u) {\n                    l2 *= psx;\n                    let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n                    if (cos < -1)\n                        cos = -1;\n                    else if (cos > 1) {\n                        cos = 1;\n                        if (stretch) sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n                    }\n                    a2 = Math.acos(cos) * bendDir;\n                    a = l1 + l2 * cos;\n                    b = l2 * Math.sin(a2);\n                    a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n                } else {\n                    a = psx * l2;\n                    b = psy * l2;\n                    let aa = a * a, bb = b * b, ta = Math.atan2(ty, tx);\n                    c = bb * l1 * l1 + aa * dd - aa * bb;\n                    let c1 = -2 * bb * l1, c2 = bb - aa;\n                    d = c1 * c1 - 4 * c2 * c;\n                    if (d >= 0) {\n                        let q = Math.sqrt(d);\n                        if (c1 < 0) q = -q;\n                        q = -(c1 + q) / 2;\n                        let r0 = q / c2, r1 = c / q;\n                        let r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                        if (r * r <= dd) {\n                            y = Math.sqrt(dd - r * r) * bendDir;\n                            a1 = ta - Math.atan2(y, r);\n                            a2 = Math.atan2(y / psy, (r - l1) / psx);\n                            break outer;\n                        }\n                    }\n                    let minAngle = MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\n                    let maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\n                    c = -a * l1 / (aa - bb);\n                    if (c >= -1 && c <= 1) {\n                        c = Math.acos(c);\n                        x = a * Math.cos(c) + l1;\n                        y = b * Math.sin(c);\n                        d = x * x + y * y;\n                        if (d < minDist) {\n                            minAngle = c;\n                            minDist = d;\n                            minX = x;\n                            minY = y;\n                        }\n                        if (d > maxDist) {\n                            maxAngle = c;\n                            maxDist = d;\n                            maxX = x;\n                            maxY = y;\n                        }\n                    }\n                    if (dd <= (minDist + maxDist) / 2) {\n                        a1 = ta - Math.atan2(minY * bendDir, minX);\n                        a2 = minAngle * bendDir;\n                    } else {\n                        a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                        a2 = maxAngle * bendDir;\n                    }\n                }\n            let os = Math.atan2(cy, cx) * s2;\n            let rotation = parent.arotation;\n            a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n            if (a1 > 180)\n                a1 -= 360;\n            else if (a1 < -180) a1 += 360;\n            parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\n            rotation = child.arotation;\n            a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n            if (a2 > 180)\n                a2 -= 360;\n            else if (a2 < -180) a2 += 360;\n            child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n        }\n    }\n}\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class IkConstraintData extends ConstraintData {\r\n        bones = new Array<BoneData>();\r\n        target: BoneData;\r\n        bendDirection = 1;\r\n        compress = false;\r\n        stretch = false;\r\n        uniform = false;\r\n        mix = 1;\r\n        softness = 0;\r\n\r\n        constructor (name: string) {\r\n            super(name, 0, false);\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class PathConstraint implements Updatable {\r\n        static NONE = -1; static BEFORE = -2; static AFTER = -3;\r\n        static epsilon = 0.00001;\r\n\r\n        data: PathConstraintData;\r\n        bones: Array<Bone>;\r\n        target: Slot;\r\n        position = 0; spacing = 0; rotateMix = 0; translateMix = 0;\r\n\r\n        spaces = new Array<number>(); positions = new Array<number>();\r\n        world = new Array<number>(); curves = new Array<number>(); lengths = new Array<number>();\r\n        segments = new Array<number>();\r\n\r\n        active = false;\r\n\r\n        constructor (data: PathConstraintData, skeleton: Skeleton) {\r\n            if (data == null) throw new Error(\"data cannot be null.\");\r\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n            this.data = data;\r\n            this.bones = new Array<Bone>();\r\n            for (let i = 0, n = data.bones.length; i < n; i++)\r\n                this.bones.push(skeleton.findBone(data.bones[i].name));\r\n            this.target = skeleton.findSlot(data.target.name);\r\n            this.position = data.position;\r\n            this.spacing = data.spacing;\r\n            this.rotateMix = data.rotateMix;\r\n            this.translateMix = data.translateMix;\r\n        }\r\n\r\n        isActive () {\r\n            return this.active;\r\n        }\r\n\r\n        apply () {\r\n            this.update();\r\n        }\r\n\r\n        update () {\r\n            let attachment = this.target.getAttachment();\r\n            if (!(attachment instanceof PathAttachment)) return;\r\n\r\n            let rotateMix = this.rotateMix, translateMix = this.translateMix;\r\n            let translate = translateMix > 0, rotate = rotateMix > 0;\r\n            if (!translate && !rotate) return;\r\n\r\n            let data = this.data;\r\n            let spacingMode = data.spacingMode;\r\n            let lengthSpacing = spacingMode == SpacingMode.Length;\r\n            let rotateMode = data.rotateMode;\r\n            let tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;\r\n            let boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\r\n            let bones = this.bones;\r\n            let spaces = Utils.setArraySize(this.spaces, spacesCount), lengths: Array<number> = null;\r\n            let spacing = this.spacing;\r\n            if (scale || lengthSpacing) {\r\n                if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\r\n                for (let i = 0, n = spacesCount - 1; i < n;) {\r\n                    let bone = bones[i];\r\n                    let setupLength = bone.data.length;\r\n                    if (setupLength < PathConstraint.epsilon) {\r\n                        if (scale) lengths[i] = 0;\r\n                        spaces[++i] = 0;\r\n                    } else {\r\n                        let x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;\r\n                        let length = Math.sqrt(x * x + y * y);\r\n                        if (scale) lengths[i] = length;\r\n                        spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\r\n                    }\r\n                }\r\n            } else {\r\n                for (let i = 1; i < spacesCount; i++)\r\n                    spaces[i] = spacing;\r\n            }\r\n\r\n            let positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents,\r\n                data.positionMode == PositionMode.Percent, spacingMode == SpacingMode.Percent);\r\n            let boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\r\n            let tip = false;\r\n            if (offsetRotation == 0)\r\n                tip = rotateMode == RotateMode.Chain;\r\n            else {\r\n                tip = false;\r\n                let p = this.target.bone.matrix;\r\n                offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n            }\r\n            for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\r\n                let bone = bones[i];\r\n                let mat = bone.matrix;\r\n                mat.tx += (boneX - mat.tx) * translateMix;\r\n                mat.ty += (boneY - mat.ty) * translateMix;\r\n                let x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\r\n                if (scale) {\r\n                    let length = lengths[i];\r\n                    if (length != 0) {\r\n                        let s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\r\n                        mat.a *= s;\r\n                        mat.b *= s;\r\n                    }\r\n                }\r\n                boneX = x;\r\n                boneY = y;\r\n                if (rotate) {\r\n                    let a = mat.a, b = mat.c, c = mat.b, d = mat.d, r = 0, cos = 0, sin = 0;\r\n                    if (tangents)\r\n                        r = positions[p - 1];\r\n                    else if (spaces[i + 1] == 0)\r\n                        r = positions[p + 2];\r\n                    else\r\n                        r = Math.atan2(dy, dx);\r\n                    r -= Math.atan2(c, a);\r\n                    if (tip) {\r\n                        cos = Math.cos(r);\r\n                        sin = Math.sin(r);\r\n                        let length = bone.data.length;\r\n                        boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\r\n                        boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\r\n                    } else {\r\n                        r += offsetRotation;\r\n                    }\r\n                    if (r > MathUtils.PI)\r\n                        r -= MathUtils.PI2;\r\n                    else if (r < -MathUtils.PI) //\r\n                        r += MathUtils.PI2;\r\n                    r *= rotateMix;\r\n                    cos = Math.cos(r);\r\n                    sin = Math.sin(r);\r\n                    mat.a = cos * a - sin * c;\r\n                    mat.c = cos * b - sin * d;\r\n                    mat.b = sin * a + cos * c;\r\n                    mat.d = sin * b + cos * d;\r\n                }\r\n                bone.appliedValid = false;\r\n            }\r\n        }\r\n\r\n        computeWorldPositions (path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean,\r\n                               percentSpacing: boolean) {\r\n            let target = this.target;\r\n            let position = this.position;\r\n            let spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world: Array<number> = null;\r\n            let closed = path.closed;\r\n            let verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\r\n\r\n            if (!path.constantSpeed) {\r\n                let lengths = path.lengths;\r\n                curveCount -= closed ? 1 : 2;\r\n                let pathLength = lengths[curveCount];\r\n                if (percentPosition) position *= pathLength;\r\n                if (percentSpacing) {\r\n                    for (let i = 0; i < spacesCount; i++)\r\n                        spaces[i] *= pathLength;\r\n                }\r\n                world = Utils.setArraySize(this.world, 8);\r\n                for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\r\n                    let space = spaces[i];\r\n                    position += space;\r\n                    let p = position;\r\n\r\n                    if (closed) {\r\n                        p %= pathLength;\r\n                        if (p < 0) p += pathLength;\r\n                        curve = 0;\r\n                    } else if (p < 0) {\r\n                        if (prevCurve != PathConstraint.BEFORE) {\r\n                            prevCurve = PathConstraint.BEFORE;\r\n                            path.computeWorldVertices(target, 2, 4, world, 0, 2);\r\n                        }\r\n                        this.addBeforePosition(p, world, 0, out, o);\r\n                        continue;\r\n                    } else if (p > pathLength) {\r\n                        if (prevCurve != PathConstraint.AFTER) {\r\n                            prevCurve = PathConstraint.AFTER;\r\n                            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\r\n                        }\r\n                        this.addAfterPosition(p - pathLength, world, 0, out, o);\r\n                        continue;\r\n                    }\r\n\r\n                    // Determine curve containing position.\r\n                    for (;; curve++) {\r\n                        let length = lengths[curve];\r\n                        if (p > length) continue;\r\n                        if (curve == 0)\r\n                            p /= length;\r\n                        else {\r\n                            let prev = lengths[curve - 1];\r\n                            p = (p - prev) / (length - prev);\r\n                        }\r\n                        break;\r\n                    }\r\n                    if (curve != prevCurve) {\r\n                        prevCurve = curve;\r\n                        if (closed && curve == curveCount) {\r\n                            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\r\n                            path.computeWorldVertices(target, 0, 4, world, 4, 2);\r\n                        } else\r\n                            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\r\n                    }\r\n                    this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o,\r\n                        tangents || (i > 0 && space == 0));\r\n                }\r\n                return out;\r\n            }\r\n\r\n            // World vertices.\r\n            if (closed) {\r\n                verticesLength += 2;\r\n                world = Utils.setArraySize(this.world, verticesLength);\r\n                path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\r\n                path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\r\n                world[verticesLength - 2] = world[0];\r\n                world[verticesLength - 1] = world[1];\r\n            } else {\r\n                curveCount--;\r\n                verticesLength -= 4;\r\n                world = Utils.setArraySize(this.world, verticesLength);\r\n                path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\r\n            }\r\n\r\n            // Curve lengths.\r\n            let curves = Utils.setArraySize(this.curves, curveCount);\r\n            let pathLength = 0;\r\n            let x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\r\n            let tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\r\n            for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\r\n                cx1 = world[w];\r\n                cy1 = world[w + 1];\r\n                cx2 = world[w + 2];\r\n                cy2 = world[w + 3];\r\n                x2 = world[w + 4];\r\n                y2 = world[w + 5];\r\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\r\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\r\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\r\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\r\n                ddfx = tmpx * 2 + dddfx;\r\n                ddfy = tmpy * 2 + dddfy;\r\n                dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\r\n                dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\r\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                dfx += ddfx;\r\n                dfy += ddfy;\r\n                ddfx += dddfx;\r\n                ddfy += dddfy;\r\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                dfx += ddfx;\r\n                dfy += ddfy;\r\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                dfx += ddfx + dddfx;\r\n                dfy += ddfy + dddfy;\r\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                curves[i] = pathLength;\r\n                x1 = x2;\r\n                y1 = y2;\r\n            }\r\n            if (percentPosition) position *= pathLength;\r\n            if (percentSpacing) {\r\n                for (let i = 0; i < spacesCount; i++)\r\n                    spaces[i] *= pathLength;\r\n            }\r\n\r\n            let segments = this.segments;\r\n            let curveLength = 0;\r\n            for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\r\n                let space = spaces[i];\r\n                position += space;\r\n                let p = position;\r\n\r\n                if (closed) {\r\n                    p %= pathLength;\r\n                    if (p < 0) p += pathLength;\r\n                    curve = 0;\r\n                } else if (p < 0) {\r\n                    this.addBeforePosition(p, world, 0, out, o);\r\n                    continue;\r\n                } else if (p > pathLength) {\r\n                    this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\r\n                    continue;\r\n                }\r\n\r\n                // Determine curve containing position.\r\n                for (;; curve++) {\r\n                    let length = curves[curve];\r\n                    if (p > length) continue;\r\n                    if (curve == 0)\r\n                        p /= length;\r\n                    else {\r\n                        let prev = curves[curve - 1];\r\n                        p = (p - prev) / (length - prev);\r\n                    }\r\n                    break;\r\n                }\r\n\r\n                // Curve segment lengths.\r\n                if (curve != prevCurve) {\r\n                    prevCurve = curve;\r\n                    let ii = curve * 6;\r\n                    x1 = world[ii];\r\n                    y1 = world[ii + 1];\r\n                    cx1 = world[ii + 2];\r\n                    cy1 = world[ii + 3];\r\n                    cx2 = world[ii + 4];\r\n                    cy2 = world[ii + 5];\r\n                    x2 = world[ii + 6];\r\n                    y2 = world[ii + 7];\r\n                    tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\r\n                    tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\r\n                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\r\n                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\r\n                    ddfx = tmpx * 2 + dddfx;\r\n                    ddfy = tmpy * 2 + dddfy;\r\n                    dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\r\n                    dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\r\n                    curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[0] = curveLength;\r\n                    for (ii = 1; ii < 8; ii++) {\r\n                        dfx += ddfx;\r\n                        dfy += ddfy;\r\n                        ddfx += dddfx;\r\n                        ddfy += dddfy;\r\n                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                        segments[ii] = curveLength;\r\n                    }\r\n                    dfx += ddfx;\r\n                    dfy += ddfy;\r\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[8] = curveLength;\r\n                    dfx += ddfx + dddfx;\r\n                    dfy += ddfy + dddfy;\r\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\r\n                    segments[9] = curveLength;\r\n                    segment = 0;\r\n                }\r\n\r\n                // Weight by segment length.\r\n                p *= curveLength;\r\n                for (;; segment++) {\r\n                    let length = segments[segment];\r\n                    if (p > length) continue;\r\n                    if (segment == 0)\r\n                        p /= length;\r\n                    else {\r\n                        let prev = segments[segment - 1];\r\n                        p = segment + (p - prev) / (length - prev);\r\n                    }\r\n                    break;\r\n                }\r\n                this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\r\n            }\r\n            return out;\r\n        }\r\n\r\n        addBeforePosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n            let x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\r\n            out[o] = x1 + p * Math.cos(r);\r\n            out[o + 1] = y1 + p * Math.sin(r);\r\n            out[o + 2] = r;\r\n        }\r\n\r\n        addAfterPosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\r\n            let x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\r\n            out[o] = x1 + p * Math.cos(r);\r\n            out[o + 1] = y1 + p * Math.sin(r);\r\n            out[o + 2] = r;\r\n        }\r\n\r\n        addCurvePosition (p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number,\r\n                          out: Array<number>, o: number, tangents: boolean) {\r\n            if (p == 0 || isNaN(p)) p = 0.0001;\r\n            let tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\r\n            let ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\r\n            let x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\r\n            out[o] = x;\r\n            out[o + 1] = y;\r\n            if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class PathConstraintData extends ConstraintData {\r\n        bones = new Array<BoneData>();\r\n        target: SlotData;\r\n        positionMode: PositionMode;\r\n        spacingMode: SpacingMode;\r\n        rotateMode: RotateMode;\r\n        offsetRotation: number;\r\n        position: number; spacing: number; rotateMix: number; translateMix: number;\r\n\r\n        constructor (name: string) {\r\n            super(name, 0, false);\r\n        }\r\n    }\r\n\r\n    export enum PositionMode {\r\n        Fixed, Percent\r\n    }\r\n\r\n    export enum SpacingMode {\r\n        Length, Fixed, Percent\r\n    }\r\n\r\n    export enum RotateMode {\r\n        Tangent, Chain, ChainScale\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class Skeleton {\r\n        data: SkeletonData;\r\n        bones: Array<Bone>;\r\n        slots: Array<Slot>;\r\n        drawOrder: Array<Slot>;\r\n        ikConstraints: Array<IkConstraint>;\r\n        transformConstraints: Array<TransformConstraint>;\r\n        pathConstraints: Array<PathConstraint>;\r\n        _updateCache = new Array<Updatable>();\r\n        updateCacheReset = new Array<Updatable>();\r\n        skin: Skin;\r\n        color: Color;\r\n        time = 0;\r\n        scaleX = 1; scaleY = 1;\r\n        x = 0; y = 0;\r\n\r\n        constructor (data: SkeletonData) {\r\n            if (data == null) throw new Error(\"data cannot be null.\");\r\n            this.data = data;\r\n\r\n            this.bones = new Array<Bone>();\r\n            for (let i = 0; i < data.bones.length; i++) {\r\n                let boneData = data.bones[i];\r\n                let bone: Bone;\r\n                if (boneData.parent == null)\r\n                    bone = new Bone(boneData, this, null);\r\n                else {\r\n                    let parent = this.bones[boneData.parent.index];\r\n                    bone = new Bone(boneData, this, parent);\r\n                    parent.children.push(bone);\r\n                }\r\n                this.bones.push(bone);\r\n            }\r\n\r\n            this.slots = new Array<Slot>();\r\n            this.drawOrder = new Array<Slot>();\r\n            for (let i = 0; i < data.slots.length; i++) {\r\n                let slotData = data.slots[i];\r\n                let bone = this.bones[slotData.boneData.index];\r\n                let slot = new Slot(slotData, bone);\r\n                this.slots.push(slot);\r\n                this.drawOrder.push(slot);\r\n            }\r\n\r\n            this.ikConstraints = new Array<IkConstraint>();\r\n            for (let i = 0; i < data.ikConstraints.length; i++) {\r\n                let ikConstraintData = data.ikConstraints[i];\r\n                this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\r\n            }\r\n\r\n            this.transformConstraints = new Array<TransformConstraint>();\r\n            for (let i = 0; i < data.transformConstraints.length; i++) {\r\n                let transformConstraintData = data.transformConstraints[i];\r\n                this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\r\n            }\r\n\r\n            this.pathConstraints = new Array<PathConstraint>();\r\n            for (let i = 0; i < data.pathConstraints.length; i++) {\r\n                let pathConstraintData = data.pathConstraints[i];\r\n                this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\r\n            }\r\n\r\n            this.color = new Color(1, 1, 1, 1);\r\n            this.updateCache();\r\n        }\r\n\r\n        updateCache () {\r\n            let updateCache = this._updateCache;\r\n            updateCache.length = 0;\r\n            this.updateCacheReset.length = 0;\r\n\r\n            let bones = this.bones;\r\n            for (let i = 0, n = bones.length; i < n; i++) {\r\n                let bone = bones[i];\r\n                bone.sorted = bone.data.skinRequired;\r\n                bone.active = !bone.sorted;\r\n            }\r\n\r\n            if (this.skin != null) {\r\n                let skinBones = this.skin.bones;\r\n                for (let i = 0, n = this.skin.bones.length; i < n; i++) {\r\n                    let bone = this.bones[skinBones[i].index];\r\n                    do {\r\n                        bone.sorted = false;\r\n                        bone.active = true;\r\n                        bone = bone.parent;\r\n                    } while (bone != null);\r\n                }\r\n            }\r\n\r\n            // IK first, lowest hierarchy depth first.\r\n            let ikConstraints = this.ikConstraints;\r\n            let transformConstraints = this.transformConstraints;\r\n            let pathConstraints = this.pathConstraints;\r\n            let ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\r\n            let constraintCount = ikCount + transformCount + pathCount;\r\n\r\n            outer:\r\n                for (let i = 0; i < constraintCount; i++) {\r\n                    for (let ii = 0; ii < ikCount; ii++) {\r\n                        let constraint = ikConstraints[ii];\r\n                        if (constraint.data.order == i) {\r\n                            this.sortIkConstraint(constraint);\r\n                            continue outer;\r\n                        }\r\n                    }\r\n                    for (let ii = 0; ii < transformCount; ii++) {\r\n                        let constraint = transformConstraints[ii];\r\n                        if (constraint.data.order == i) {\r\n                            this.sortTransformConstraint(constraint);\r\n                            continue outer;\r\n                        }\r\n                    }\r\n                    for (let ii = 0; ii < pathCount; ii++) {\r\n                        let constraint = pathConstraints[ii];\r\n                        if (constraint.data.order == i) {\r\n                            this.sortPathConstraint(constraint);\r\n                            continue outer;\r\n                        }\r\n                    }\r\n                }\r\n\r\n            for (let i = 0, n = bones.length; i < n; i++)\r\n                this.sortBone(bones[i]);\r\n        }\r\n\r\n        sortIkConstraint (constraint: IkConstraint) {\r\n            constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n            if (!constraint.active) return;\r\n\r\n            let target = constraint.target;\r\n            this.sortBone(target);\r\n\r\n            let constrained = constraint.bones;\r\n            let parent = constrained[0];\r\n            this.sortBone(parent);\r\n\r\n            if (constrained.length > 1) {\r\n                let child = constrained[constrained.length - 1];\r\n                if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\r\n            }\r\n\r\n            this._updateCache.push(constraint);\r\n\r\n            this.sortReset(parent.children);\r\n            constrained[constrained.length - 1].sorted = true;\r\n        }\r\n\r\n        sortPathConstraint (constraint: PathConstraint) {\r\n            constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n            if (!constraint.active) return;\r\n\r\n            let slot = constraint.target;\r\n            let slotIndex = slot.data.index;\r\n            let slotBone = slot.bone;\r\n            if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\r\n            if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\r\n                this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\r\n            for (let i = 0, n = this.data.skins.length; i < n; i++)\r\n                this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\r\n\r\n            let attachment = slot.getAttachment();\r\n            if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\r\n\r\n            let constrained = constraint.bones;\r\n            let boneCount = constrained.length;\r\n            for (let i = 0; i < boneCount; i++)\r\n                this.sortBone(constrained[i]);\r\n\r\n            this._updateCache.push(constraint);\r\n\r\n            for (let i = 0; i < boneCount; i++)\r\n                this.sortReset(constrained[i].children);\r\n            for (let i = 0; i < boneCount; i++)\r\n                constrained[i].sorted = true;\r\n        }\r\n\r\n        sortTransformConstraint (constraint: TransformConstraint) {\r\n            constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin != null && Utils.contains(this.skin.constraints, constraint.data, true)));\r\n            if (!constraint.active) return;\r\n\r\n            this.sortBone(constraint.target);\r\n\r\n            let constrained = constraint.bones;\r\n            let boneCount = constrained.length;\r\n            if (constraint.data.local) {\r\n                for (let i = 0; i < boneCount; i++) {\r\n                    let child = constrained[i];\r\n                    this.sortBone(child.parent);\r\n                    if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\r\n                }\r\n            } else {\r\n                for (let i = 0; i < boneCount; i++) {\r\n                    this.sortBone(constrained[i]);\r\n                }\r\n            }\r\n\r\n            this._updateCache.push(constraint);\r\n\r\n            for (let ii = 0; ii < boneCount; ii++)\r\n                this.sortReset(constrained[ii].children);\r\n            for (let ii = 0; ii < boneCount; ii++)\r\n                constrained[ii].sorted = true;\r\n        }\r\n\r\n        sortPathConstraintAttachment (skin: Skin, slotIndex: number, slotBone: Bone) {\r\n            let attachments = skin.attachments[slotIndex];\r\n            if (!attachments) return;\r\n            for (let key in attachments) {\r\n                this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\r\n            }\r\n        }\r\n\r\n        sortPathConstraintAttachmentWith (attachment: Attachment, slotBone: Bone) {\r\n            if (!(attachment instanceof PathAttachment)) return;\r\n            let pathBones = (<PathAttachment>attachment).bones;\r\n            if (pathBones == null)\r\n                this.sortBone(slotBone);\r\n            else {\r\n                let bones = this.bones;\r\n                let i = 0;\r\n                while (i < pathBones.length) {\r\n                    let boneCount = pathBones[i++];\r\n                    for (let n = i + boneCount; i < n; i++) {\r\n                        let boneIndex = pathBones[i];\r\n                        this.sortBone(bones[boneIndex]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        sortBone (bone: Bone) {\r\n            if (bone.sorted) return;\r\n            let parent = bone.parent;\r\n            if (parent != null) this.sortBone(parent);\r\n            bone.sorted = true;\r\n            this._updateCache.push(bone);\r\n        }\r\n\r\n        sortReset (bones: Array<Bone>) {\r\n            for (let i = 0, n = bones.length; i < n; i++) {\r\n                let bone = bones[i];\r\n                if (!bone.active) continue;\r\n                if (bone.sorted) this.sortReset(bone.children);\r\n                bone.sorted = false;\r\n            }\r\n        }\r\n\r\n        /** Updates the world transform for each bone and applies constraints. */\r\n        updateWorldTransform () {\r\n            let updateCacheReset = this.updateCacheReset;\r\n            for (let i = 0, n = updateCacheReset.length; i < n; i++) {\r\n                let bone = updateCacheReset[i] as Bone;\r\n                bone.ax = bone.x;\r\n                bone.ay = bone.y;\r\n                bone.arotation = bone.rotation;\r\n                bone.ascaleX = bone.scaleX;\r\n                bone.ascaleY = bone.scaleY;\r\n                bone.ashearX = bone.shearX;\r\n                bone.ashearY = bone.shearY;\r\n                bone.appliedValid = true;\r\n            }\r\n            let updateCache = this._updateCache;\r\n            for (let i = 0, n = updateCache.length; i < n; i++)\r\n                updateCache[i].update();\r\n        }\r\n\r\n        /** Sets the bones, constraints, and slots to their setup pose values. */\r\n        setToSetupPose () {\r\n            this.setBonesToSetupPose();\r\n            this.setSlotsToSetupPose();\r\n        }\r\n\r\n        /** Sets the bones and constraints to their setup pose values. */\r\n        setBonesToSetupPose () {\r\n            let bones = this.bones;\r\n            for (let i = 0, n = bones.length; i < n; i++)\r\n                bones[i].setToSetupPose();\r\n\r\n            let ikConstraints = this.ikConstraints;\r\n            for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n                let constraint = ikConstraints[i];\r\n                constraint.mix = constraint.data.mix;\r\n                constraint.softness = constraint.data.softness;\r\n                constraint.bendDirection = constraint.data.bendDirection;\r\n                constraint.compress = constraint.data.compress;\r\n                constraint.stretch = constraint.data.stretch;\r\n            }\r\n\r\n            let transformConstraints = this.transformConstraints;\r\n            for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n                let constraint = transformConstraints[i];\r\n                let data = constraint.data;\r\n                constraint.rotateMix = data.rotateMix;\r\n                constraint.translateMix = data.translateMix;\r\n                constraint.scaleMix = data.scaleMix;\r\n                constraint.shearMix = data.shearMix;\r\n            }\r\n\r\n            let pathConstraints = this.pathConstraints;\r\n            for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n                let constraint = pathConstraints[i];\r\n                let data = constraint.data;\r\n                constraint.position = data.position;\r\n                constraint.spacing = data.spacing;\r\n                constraint.rotateMix = data.rotateMix;\r\n                constraint.translateMix = data.translateMix;\r\n            }\r\n        }\r\n\r\n        setSlotsToSetupPose () {\r\n            let slots = this.slots;\r\n            Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\r\n            for (let i = 0, n = slots.length; i < n; i++)\r\n                slots[i].setToSetupPose();\r\n        }\r\n\r\n        /** @return May return null. */\r\n        getRootBone () {\r\n            if (this.bones.length == 0) return null;\r\n            return this.bones[0];\r\n        }\r\n\r\n        /** @return May be null. */\r\n        findBone (boneName: string) {\r\n            if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n            let bones = this.bones;\r\n            for (let i = 0, n = bones.length; i < n; i++) {\r\n                let bone = bones[i];\r\n                if (bone.data.name == boneName) return bone;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        /** @return -1 if the bone was not found. */\r\n        findBoneIndex (boneName: string) {\r\n            if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n            let bones = this.bones;\r\n            for (let i = 0, n = bones.length; i < n; i++)\r\n                if (bones[i].data.name == boneName) return i;\r\n            return -1;\r\n        }\r\n\r\n        /** @return May be null. */\r\n        findSlot (slotName: string) {\r\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n            let slots = this.slots;\r\n            for (let i = 0, n = slots.length; i < n; i++) {\r\n                let slot = slots[i];\r\n                if (slot.data.name == slotName) return slot;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        /** @return -1 if the bone was not found. */\r\n        findSlotIndex (slotName: string) {\r\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n            let slots = this.slots;\r\n            for (let i = 0, n = slots.length; i < n; i++)\r\n                if (slots[i].data.name == slotName) return i;\r\n            return -1;\r\n        }\r\n\r\n        /** Sets a skin by name.\r\n         * @see #setSkin(Skin) */\r\n        setSkinByName (skinName: string) {\r\n            let skin = this.data.findSkin(skinName);\r\n            if (skin == null) throw new Error(\"Skin not found: \" + skinName);\r\n            this.setSkin(skin);\r\n        }\r\n\r\n        /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\r\n         * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\r\n         * old skin, each slot's setup mode attachment is attached from the new skin.\r\n         * @param newSkin May be null. */\r\n        setSkin (newSkin: Skin) {\r\n            if (newSkin == this.skin) return;\r\n            if (newSkin != null) {\r\n                if (this.skin != null)\r\n                    newSkin.attachAll(this, this.skin);\r\n                else {\r\n                    let slots = this.slots;\r\n                    for (let i = 0, n = slots.length; i < n; i++) {\r\n                        let slot = slots[i];\r\n                        let name = slot.data.attachmentName;\r\n                        if (name != null) {\r\n                            let attachment: Attachment = newSkin.getAttachment(i, name);\r\n                            if (attachment != null) slot.setAttachment(attachment);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            this.skin = newSkin;\r\n            this.updateCache();\r\n        }\r\n\r\n        /** @return May be null. */\r\n        getAttachmentByName (slotName: string, attachmentName: string): Attachment {\r\n            return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\r\n        }\r\n\r\n        /** @return May be null. */\r\n        getAttachment (slotIndex: number, attachmentName: string): Attachment {\r\n            if (attachmentName == null) throw new Error(\"attachmentName cannot be null.\");\r\n            if (this.skin != null) {\r\n                let attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n                if (attachment != null) return attachment;\r\n            }\r\n            if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n            return null;\r\n        }\r\n\r\n        /** @param attachmentName May be null. */\r\n        setAttachment (slotName: string, attachmentName?: string) {\r\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n            let slots = this.slots;\r\n            for (let i = 0, n = slots.length; i < n; i++) {\r\n                let slot = slots[i];\r\n                if (slot.data.name == slotName) {\r\n                    let attachment: Attachment = null;\r\n                    if (attachmentName != null) {\r\n                        attachment = this.getAttachment(i, attachmentName);\r\n                        if (attachment == null)\r\n                            throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\r\n                    }\r\n                    slot.setAttachment(attachment);\r\n                    return;\r\n                }\r\n            }\r\n            throw new Error(\"Slot not found: \" + slotName);\r\n        }\r\n\r\n        /** @return May be null. */\r\n        findIkConstraint (constraintName: string) {\r\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n            let ikConstraints = this.ikConstraints;\r\n            for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n                let ikConstraint = ikConstraints[i];\r\n                if (ikConstraint.data.name == constraintName) return ikConstraint;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        /** @return May be null. */\r\n        findTransformConstraint (constraintName: string) {\r\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n            let transformConstraints = this.transformConstraints;\r\n            for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n                let constraint = transformConstraints[i];\r\n                if (constraint.data.name == constraintName) return constraint;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        /** @return May be null. */\r\n        findPathConstraint (constraintName: string) {\r\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n            let pathConstraints = this.pathConstraints;\r\n            for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n                let constraint = pathConstraints[i];\r\n                if (constraint.data.name == constraintName) return constraint;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\r\n         * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\r\n         * @param size The width and height of the AABB.\r\n         * @param temp Working memory */\r\n        getBounds (offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2)) {\r\n            if (offset == null) throw new Error(\"offset cannot be null.\");\r\n            if (size == null) throw new Error(\"size cannot be null.\");\r\n            let drawOrder = this.drawOrder;\r\n            let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n            for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n                let slot = drawOrder[i];\r\n                if (!slot.bone.active) continue;\r\n                let verticesLength = 0;\r\n                let vertices: ArrayLike<number> = null;\r\n                let attachment = slot.getAttachment();\r\n                if (attachment instanceof RegionAttachment) {\r\n                    verticesLength = 8;\r\n                    vertices = Utils.setArraySize(temp, verticesLength, 0);\r\n                    (<RegionAttachment>attachment).computeWorldVertices(slot.bone, vertices, 0, 2);\r\n                } else if (attachment instanceof MeshAttachment) {\r\n                    let mesh = (<MeshAttachment>attachment);\r\n                    verticesLength = mesh.worldVerticesLength;\r\n                    vertices = Utils.setArraySize(temp, verticesLength, 0);\r\n                    mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\r\n                }\r\n                if (vertices != null) {\r\n                    for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\r\n                        let x = vertices[ii], y = vertices[ii + 1];\r\n                        minX = Math.min(minX, x);\r\n                        minY = Math.min(minY, y);\r\n                        maxX = Math.max(maxX, x);\r\n                        maxY = Math.max(maxY, y);\r\n                    }\r\n                }\r\n            }\r\n            offset.set(minX, minY);\r\n            size.set(maxX - minX, maxY - minY);\r\n        }\r\n\r\n        update (delta: number) {\r\n            this.time += delta;\r\n        }\r\n\r\n        get flipX(): boolean {\r\n            return this.scaleX == -1;\r\n        }\r\n\r\n        set flipX(value: boolean) {\r\n            if (!Skeleton.deprecatedWarning1) {\r\n                Skeleton.deprecatedWarning1 = true;\r\n                console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\r\n            }\r\n            this.scaleX = value ? 1.0 : -1.0;\r\n        }\r\n\r\n        get flipY(): boolean {\r\n            return this.scaleY == -1;\r\n        }\r\n\r\n        set flipY(value: boolean) {\r\n            if (!Skeleton.deprecatedWarning1) {\r\n                Skeleton.deprecatedWarning1 = true;\r\n                console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\r\n            }\r\n            this.scaleY = value ? 1.0 : -1.0;\r\n        }\r\n\r\n        private static deprecatedWarning1: boolean = false;\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes License Agreement\r\n * Last updated May 1, 2019. Replaces all prior versions.\r\n *\r\n * Copyright (c) 2013-2019, Esoteric Software LLC\r\n *\r\n * Integration of the Spine Runtimes into software or otherwise creating\r\n * derivative works of the Spine Runtimes is permitted under the terms and\r\n * conditions of Section 2 of the Spine Editor License Agreement:\r\n * http://esotericsoftware.com/spine-editor-license\r\n *\r\n * Otherwise, it is permitted to integrate the Spine Runtimes into software\r\n * or otherwise create derivative works of the Spine Runtimes (collectively,\r\n * \"Products\"), provided that each user of the Products must obtain their own\r\n * Spine Editor license and redistribution of the Products in any form must\r\n * include this license and copyright notice.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY EXPRESS\r\n * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\r\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN\r\n * NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY DIRECT, INDIRECT,\r\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS\r\n * INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n\texport class SkeletonBinary {\r\n\t\tstatic AttachmentTypeValues = [ 0 /*AttachmentType.Region*/, 1/*AttachmentType.BoundingBox*/, 2/*AttachmentType.Mesh*/, 3/*AttachmentType.LinkedMesh*/, 4/*AttachmentType.Path*/, 5/*AttachmentType.Point*/, 6/*AttachmentType.Clipping*/ ];\r\n\t\tstatic TransformModeValues = [TransformMode.Normal, TransformMode.OnlyTranslation, TransformMode.NoRotationOrReflection, TransformMode.NoScale, TransformMode.NoScaleOrReflection];\r\n\t\tstatic PositionModeValues = [ PositionMode.Fixed, PositionMode.Percent ];\r\n\t\tstatic SpacingModeValues = [ SpacingMode.Length, SpacingMode.Fixed, SpacingMode.Percent];\r\n\t\tstatic RotateModeValues = [ RotateMode.Tangent, RotateMode.Chain, RotateMode.ChainScale ];\r\n\t\tstatic BlendModeValues = [ BlendMode.Normal, BlendMode.Additive, BlendMode.Multiply, BlendMode.Screen];\r\n\r\n\t\tstatic BONE_ROTATE = 0;\r\n\t\tstatic BONE_TRANSLATE = 1;\r\n\t\tstatic BONE_SCALE = 2;\r\n\t\tstatic BONE_SHEAR = 3;\r\n\r\n\t\tstatic SLOT_ATTACHMENT = 0;\r\n\t\tstatic SLOT_COLOR = 1;\r\n\t\tstatic SLOT_TWO_COLOR = 2;\r\n\r\n\t\tstatic PATH_POSITION = 0;\r\n\t\tstatic PATH_SPACING = 1;\r\n\t\tstatic PATH_MIX = 2;\r\n\r\n\t\tstatic CURVE_LINEAR = 0;\r\n\t\tstatic CURVE_STEPPED = 1;\r\n\t\tstatic CURVE_BEZIER = 2;\r\n\r\n\t\tattachmentLoader: AttachmentLoader;\r\n\t\tscale = 1;\r\n\t\tprivate linkedMeshes = new Array<LinkedMesh>();\r\n\r\n\t\tconstructor (attachmentLoader: AttachmentLoader) {\r\n\t\t\tthis.attachmentLoader = attachmentLoader;\r\n\t\t}\r\n\r\n\t\treadSkeletonData (binary: Uint8Array): SkeletonData {\r\n\t\t\tlet scale = this.scale;\r\n\r\n\t\t\tlet skeletonData = new SkeletonData();\r\n\t\t\tskeletonData.name = \"\"; // BOZO\r\n\r\n\t\t\tlet input = new BinaryInput(binary);\r\n\r\n\t\t\tskeletonData.hash = input.readString();\r\n\t\t\tskeletonData.version = input.readString();\r\n            if (skeletonData.version === '3.8.75')\r\n            {\r\n                let error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;\r\n                console.error(error);\r\n            }\r\n\t\t\tskeletonData.x = input.readFloat();\r\n\t\t\tskeletonData.y = input.readFloat();\r\n\t\t\tskeletonData.width = input.readFloat();\r\n\t\t\tskeletonData.height = input.readFloat();\r\n\r\n\t\t\tlet nonessential = input.readBoolean();\r\n\t\t\tif (nonessential) {\r\n\t\t\t\tskeletonData.fps = input.readFloat();\r\n\r\n\t\t\t\tskeletonData.imagesPath = input.readString();\r\n\t\t\t\tskeletonData.audioPath = input.readString();\r\n\t\t\t}\r\n\r\n\t\t\tlet n = 0;\r\n\t\t\t// Strings.\r\n\t\t\tn = input.readInt(true)\r\n\t\t\tfor (let i = 0; i < n; i++)\r\n\t\t\t\tinput.strings.push(input.readString());\r\n\r\n\t\t\t// Bones.\r\n\t\t\tn = input.readInt(true)\r\n\t\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\t\tlet name = input.readString();\r\n\t\t\t\tlet parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\r\n\t\t\t\tlet data = new BoneData(i, name, parent);\r\n\t\t\t\tdata.rotation = input.readFloat();\r\n\t\t\t\tdata.x = input.readFloat() * scale;\r\n\t\t\t\tdata.y = input.readFloat() * scale;\r\n\t\t\t\tdata.scaleX = input.readFloat();\r\n\t\t\t\tdata.scaleY = input.readFloat();\r\n\t\t\t\tdata.shearX = input.readFloat();\r\n\t\t\t\tdata.shearY = input.readFloat();\r\n\t\t\t\tdata.length = input.readFloat() * scale;\r\n\t\t\t\tdata.transformMode = SkeletonBinary.TransformModeValues[input.readInt(true)];\r\n\t\t\t\tdata.skinRequired = input.readBoolean();\r\n\t\t\t\tif (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\r\n\t\t\t\tskeletonData.bones.push(data);\r\n\t\t\t}\r\n\r\n\t\t\t// Slots.\r\n\t\t\tn = input.readInt(true);\r\n\t\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\t\tlet slotName = input.readString();\r\n\t\t\t\tlet boneData = skeletonData.bones[input.readInt(true)];\r\n\t\t\t\tlet data = new SlotData(i, slotName, boneData);\r\n\t\t\t\tColor.rgba8888ToColor(data.color, input.readInt32());\r\n\r\n\t\t\t\tlet darkColor = input.readInt32();\r\n\t\t\t\tif (darkColor != -1) Color.rgb888ToColor(data.darkColor = new Color(), darkColor);\r\n\r\n\t\t\t\tdata.attachmentName = input.readStringRef();\r\n\t\t\t\tdata.blendMode = SkeletonBinary.BlendModeValues[input.readInt(true)];\r\n\t\t\t\tskeletonData.slots.push(data);\r\n\t\t\t}\r\n\r\n\t\t\t// IK constraints.\r\n\t\t\tn = input.readInt(true);\r\n\t\t\tfor (let i = 0, nn; i < n; i++) {\r\n\t\t\t\tlet data = new IkConstraintData(input.readString());\r\n\t\t\t\tdata.order = input.readInt(true);\r\n\t\t\t\tdata.skinRequired = input.readBoolean();\r\n\t\t\t\tnn = input.readInt(true);\r\n\t\t\t\tfor (let ii = 0; ii < nn; ii++)\r\n\t\t\t\t\tdata.bones.push(skeletonData.bones[input.readInt(true)]);\r\n\t\t\t\tdata.target = skeletonData.bones[input.readInt(true)];\r\n\t\t\t\tdata.mix = input.readFloat();\r\n\t\t\t\tdata.softness = input.readFloat() * scale;\r\n\t\t\t\tdata.bendDirection = input.readByte();\r\n\t\t\t\tdata.compress = input.readBoolean();\r\n\t\t\t\tdata.stretch = input.readBoolean();\r\n\t\t\t\tdata.uniform = input.readBoolean();\r\n\t\t\t\tskeletonData.ikConstraints.push(data);\r\n\t\t\t}\r\n\r\n\t\t\t// Transform constraints.\r\n\t\t\tn = input.readInt(true);\r\n\t\t\tfor (let i = 0, nn; i < n; i++) {\r\n\t\t\t\tlet data = new TransformConstraintData(input.readString());\r\n\t\t\t\tdata.order = input.readInt(true);\r\n\t\t\t\tdata.skinRequired = input.readBoolean();\r\n\t\t\t\tnn = input.readInt(true);\r\n\t\t\t\tfor (let ii = 0; ii < nn; ii++)\r\n\t\t\t\t\tdata.bones.push(skeletonData.bones[input.readInt(true)]);\r\n\t\t\t\tdata.target = skeletonData.bones[input.readInt(true)];\r\n\t\t\t\tdata.local = input.readBoolean();\r\n\t\t\t\tdata.relative = input.readBoolean();\r\n\t\t\t\tdata.offsetRotation = input.readFloat();\r\n\t\t\t\tdata.offsetX = input.readFloat() * scale;\r\n\t\t\t\tdata.offsetY = input.readFloat() * scale;\r\n\t\t\t\tdata.offsetScaleX = input.readFloat();\r\n\t\t\t\tdata.offsetScaleY = input.readFloat();\r\n\t\t\t\tdata.offsetShearY = input.readFloat();\r\n\t\t\t\tdata.rotateMix = input.readFloat();\r\n\t\t\t\tdata.translateMix = input.readFloat();\r\n\t\t\t\tdata.scaleMix = input.readFloat();\r\n\t\t\t\tdata.shearMix = input.readFloat();\r\n\t\t\t\tskeletonData.transformConstraints.push(data);\r\n\t\t\t}\r\n\r\n\t\t\t// Path constraints.\r\n\t\t\tn = input.readInt(true);\r\n\t\t\tfor (let i = 0, nn; i < n; i++) {\r\n\t\t\t\tlet data = new PathConstraintData(input.readString());\r\n\t\t\t\tdata.order = input.readInt(true);\r\n\t\t\t\tdata.skinRequired = input.readBoolean();\r\n\t\t\t\tnn = input.readInt(true);\r\n\t\t\t\tfor (let ii = 0; ii < nn; ii++)\r\n\t\t\t\t\tdata.bones.push(skeletonData.bones[input.readInt(true)]);\r\n\t\t\t\tdata.target = skeletonData.slots[input.readInt(true)];\r\n\t\t\t\tdata.positionMode = SkeletonBinary.PositionModeValues[input.readInt(true)];\r\n\t\t\t\tdata.spacingMode = SkeletonBinary.SpacingModeValues[input.readInt(true)];\r\n\t\t\t\tdata.rotateMode = SkeletonBinary.RotateModeValues[input.readInt(true)];\r\n\t\t\t\tdata.offsetRotation = input.readFloat();\r\n\t\t\t\tdata.position = input.readFloat();\r\n\t\t\t\tif (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n\t\t\t\tdata.spacing = input.readFloat();\r\n\t\t\t\tif (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n\t\t\t\tdata.rotateMix = input.readFloat();\r\n\t\t\t\tdata.translateMix = input.readFloat();\r\n\t\t\t\tskeletonData.pathConstraints.push(data);\r\n\t\t\t}\r\n\r\n\t\t\t// Default skin.\r\n\t\t\tlet defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\r\n\t\t\tif (defaultSkin != null) {\r\n\t\t\t\tskeletonData.defaultSkin = defaultSkin;\r\n\t\t\t\tskeletonData.skins.push(defaultSkin);\r\n\t\t\t}\r\n\r\n\t\t\t// Skins.\r\n\t\t\t{\r\n\t\t\t\tlet i = skeletonData.skins.length;\r\n\t\t\t\tUtils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\r\n\t\t\t\tfor (; i < n; i++)\r\n\t\t\t\t\tskeletonData.skins[i] = this.readSkin(input, skeletonData, false, nonessential);\r\n\t\t\t}\r\n\r\n\t\t\t// Linked meshes.\r\n\t\t\tn = this.linkedMeshes.length;\r\n\t\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\t\tlet linkedMesh = this.linkedMeshes[i];\r\n\t\t\t\tlet skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n\t\t\t\tif (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\r\n\t\t\t\tlet parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n\t\t\t\tif (parent == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n\t\t\t\tlinkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? parent as VertexAttachment : linkedMesh.mesh;\r\n\t\t\t\tlinkedMesh.mesh.setParentMesh(parent as MeshAttachment);\r\n\t\t\t\t// linkedMesh.mesh.updateUVs();\r\n\t\t\t}\r\n\t\t\tthis.linkedMeshes.length = 0;\r\n\r\n\t\t\t// Events.\r\n\t\t\tn = input.readInt(true);\r\n\t\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\t\tlet data = new EventData(input.readStringRef());\r\n\t\t\t\tdata.intValue = input.readInt(false);\r\n\t\t\t\tdata.floatValue = input.readFloat();\r\n\t\t\t\tdata.stringValue = input.readString();\r\n\t\t\t\tdata.audioPath = input.readString();\r\n\t\t\t\tif (data.audioPath != null) {\r\n\t\t\t\t\tdata.volume = input.readFloat();\r\n\t\t\t\t\tdata.balance = input.readFloat();\r\n\t\t\t\t}\r\n\t\t\t\tskeletonData.events.push(data);\r\n\t\t\t}\r\n\r\n\t\t\t// Animations.\r\n\t\t\tn = input.readInt(true);\r\n\t\t\tfor (let i = 0; i < n; i++)\r\n\t\t\t\tskeletonData.animations.push(this.readAnimation(input, input.readString(), skeletonData));\r\n\t\t\treturn skeletonData;\r\n\t\t}\r\n\r\n\t\tprivate readSkin (input: BinaryInput, skeletonData: SkeletonData, defaultSkin: boolean, nonessential: boolean): Skin {\r\n            let skin = null;\r\n            let slotCount = 0;\r\n\r\n            if (defaultSkin) {\r\n                slotCount = input.readInt(true)\r\n                if (slotCount == 0) return null;\r\n                skin = new Skin(\"default\");\r\n            } else {\r\n                skin = new Skin(input.readStringRef());\r\n                skin.bones.length = input.readInt(true);\r\n                for (let i = 0, n = skin.bones.length; i < n; i++)\r\n                    skin.bones[i] = skeletonData.bones[input.readInt(true)];\r\n\r\n                for (let i = 0, n = input.readInt(true); i < n; i++)\r\n                    skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\r\n                for (let i = 0, n = input.readInt(true); i < n; i++)\r\n                    skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\r\n                for (let i = 0, n = input.readInt(true); i < n; i++)\r\n                    skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\r\n\r\n                slotCount = input.readInt(true);\r\n            }\r\n\r\n            for (let i = 0; i < slotCount; i++) {\r\n                let slotIndex = input.readInt(true);\r\n                for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n                    let name = input.readStringRef();\r\n                    let attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\r\n                    if (attachment != null) skin.setAttachment(slotIndex, name, attachment);\r\n                }\r\n            }\r\n            return skin;\r\n\t\t}\r\n\r\n\t\tprivate readAttachment(input: BinaryInput, skeletonData: SkeletonData, skin: Skin, slotIndex: number, attachmentName: string, nonessential: boolean): Attachment {\r\n\t\t\tlet scale = this.scale;\r\n\r\n\t\t\tlet name = input.readStringRef();\r\n\t\t\tif (name == null) name = attachmentName;\r\n\r\n\t\t\tlet typeIndex = input.readByte();\r\n\t\t\tlet type = SkeletonBinary.AttachmentTypeValues[typeIndex];\r\n\t\t\tswitch (type) {\r\n\t\t\tcase AttachmentType.Region: {\r\n\t\t\t\tlet path = input.readStringRef();\r\n\t\t\t\tlet rotation = input.readFloat();\r\n\t\t\t\tlet x = input.readFloat();\r\n\t\t\t\tlet y = input.readFloat();\r\n\t\t\t\tlet scaleX = input.readFloat();\r\n\t\t\t\tlet scaleY = input.readFloat();\r\n\t\t\t\tlet width = input.readFloat();\r\n\t\t\t\tlet height = input.readFloat();\r\n\t\t\t\tlet color = input.readInt32();\r\n\r\n\t\t\t\tif (path == null) path = name;\r\n\t\t\t\tlet region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n\t\t\t\tif (region == null) return null;\r\n\t\t\t\tregion.path = path;\r\n\t\t\t\tregion.x = x * scale;\r\n\t\t\t\tregion.y = y * scale;\r\n\t\t\t\tregion.scaleX = scaleX;\r\n\t\t\t\tregion.scaleY = scaleY;\r\n\t\t\t\tregion.rotation = rotation;\r\n\t\t\t\tregion.width = width * scale;\r\n\t\t\t\tregion.height = height * scale;\r\n\t\t\t\tColor.rgba8888ToColor(region.color, color);\r\n\t\t\t\t// region.updateOffset();\r\n\t\t\t\treturn region;\r\n\t\t\t}\r\n\t\t\tcase AttachmentType.BoundingBox: {\r\n\t\t\t\tlet vertexCount = input.readInt(true);\r\n\t\t\t\tlet vertices = this.readVertices(input, vertexCount);\r\n\t\t\t\tlet color = nonessential ? input.readInt32() : 0;\r\n\r\n\t\t\t\tlet box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n\t\t\t\tif (box == null) return null;\r\n\t\t\t\tbox.worldVerticesLength = vertexCount << 1;\r\n\t\t\t\tbox.vertices = vertices.vertices;\r\n\t\t\t\tbox.bones = vertices.bones;\r\n\t\t\t\tif (nonessential) Color.rgba8888ToColor(box.color, color);\r\n\t\t\t\treturn box;\r\n\t\t\t}\r\n\t\t\tcase AttachmentType.Mesh: {\r\n\t\t\t\tlet path = input.readStringRef();\r\n\t\t\t\tlet color = input.readInt32();\r\n\t\t\t\tlet vertexCount = input.readInt(true);\r\n\t\t\t\tlet uvs = this.readFloatArray(input, vertexCount << 1, 1);\r\n\t\t\t\tlet triangles = this.readShortArray(input);\r\n\t\t\t\tlet vertices = this.readVertices(input, vertexCount);\r\n\t\t\t\tlet hullLength = input.readInt(true);\r\n\t\t\t\tlet edges = null;\r\n\t\t\t\tlet width = 0, height = 0;\r\n\t\t\t\tif (nonessential) {\r\n\t\t\t\t\tedges = this.readShortArray(input);\r\n\t\t\t\t\twidth = input.readFloat();\r\n\t\t\t\t\theight = input.readFloat();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (path == null) path = name;\r\n\t\t\t\tlet mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n\t\t\t\tif (mesh == null) return null;\r\n\t\t\t\tmesh.path = path;\r\n\t\t\t\tColor.rgba8888ToColor(mesh.color, color);\r\n\t\t\t\tmesh.bones = vertices.bones;\r\n\t\t\t\tmesh.vertices = vertices.vertices;\r\n\t\t\t\tmesh.worldVerticesLength = vertexCount << 1;\r\n\t\t\t\tmesh.triangles = triangles;\r\n\t\t\t\tmesh.regionUVs = new Float32Array(uvs);\r\n\t\t\t\t// mesh.updateUVs();\r\n\t\t\t\tmesh.hullLength = hullLength << 1;\r\n\t\t\t\tif (nonessential) {\r\n\t\t\t\t\tmesh.edges = edges;\r\n\t\t\t\t\tmesh.width = width * scale;\r\n\t\t\t\t\tmesh.height = height * scale;\r\n\t\t\t\t}\r\n\t\t\t\treturn mesh;\r\n\t\t\t}\r\n\t\t\tcase AttachmentType.LinkedMesh: {\r\n\t\t\t\tlet path = input.readStringRef();\r\n\t\t\t\tlet color = input.readInt32();\r\n\t\t\t\tlet skinName = input.readStringRef();\r\n\t\t\t\tlet parent = input.readStringRef();\r\n\t\t\t\tlet inheritDeform = input.readBoolean();\r\n\t\t\t\tlet width = 0, height = 0;\r\n\t\t\t\tif (nonessential) {\r\n\t\t\t\t\twidth = input.readFloat();\r\n\t\t\t\t\theight = input.readFloat();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (path == null) path = name;\r\n\t\t\t\tlet mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n\t\t\t\tif (mesh == null) return null;\r\n\t\t\t\tmesh.path = path;\r\n\t\t\t\tColor.rgba8888ToColor(mesh.color, color);\r\n\t\t\t\tif (nonessential) {\r\n\t\t\t\t\tmesh.width = width * scale;\r\n\t\t\t\t\tmesh.height = height * scale;\r\n\t\t\t\t}\r\n\t\t\t\tthis.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritDeform));\r\n\t\t\t\treturn mesh;\r\n\t\t\t}\r\n\t\t\tcase AttachmentType.Path: {\r\n\t\t\t\tlet closed = input.readBoolean();\r\n\t\t\t\tlet constantSpeed = input.readBoolean();\r\n\t\t\t\tlet vertexCount = input.readInt(true);\r\n\t\t\t\tlet vertices = this.readVertices(input, vertexCount);\r\n\t\t\t\tlet lengths = Utils.newArray(vertexCount / 3, 0);\r\n\t\t\t\tfor (let i = 0, n = lengths.length; i < n; i++)\r\n\t\t\t\t\tlengths[i] = input.readFloat() * scale;\r\n\t\t\t\tlet color = nonessential ? input.readInt32() : 0;\r\n\r\n\t\t\t\tlet path = this.attachmentLoader.newPathAttachment(skin, name);\r\n\t\t\t\tif (path == null) return null;\r\n\t\t\t\tpath.closed = closed;\r\n\t\t\t\tpath.constantSpeed = constantSpeed;\r\n\t\t\t\tpath.worldVerticesLength = vertexCount << 1;\r\n\t\t\t\tpath.vertices = vertices.vertices;\r\n\t\t\t\tpath.bones = vertices.bones;\r\n\t\t\t\tpath.lengths = lengths;\r\n\t\t\t\tif (nonessential) Color.rgba8888ToColor(path.color, color);\r\n\t\t\t\treturn path;\r\n\t\t\t}\r\n\t\t\tcase AttachmentType.Point: {\r\n\t\t\t\tlet rotation = input.readFloat();\r\n\t\t\t\tlet x = input.readFloat();\r\n\t\t\t\tlet y = input.readFloat();\r\n\t\t\t\tlet color = nonessential ? input.readInt32() : 0;\r\n\r\n\t\t\t\tlet point = this.attachmentLoader.newPointAttachment(skin, name);\r\n\t\t\t\tif (point == null) return null;\r\n\t\t\t\tpoint.x = x * scale;\r\n\t\t\t\tpoint.y = y * scale;\r\n\t\t\t\tpoint.rotation = rotation;\r\n\t\t\t\tif (nonessential) Color.rgba8888ToColor(point.color, color);\r\n\t\t\t\treturn point;\r\n\t\t\t}\r\n\t\t\tcase AttachmentType.Clipping: {\r\n\t\t\t\tlet endSlotIndex = input.readInt(true);\r\n\t\t\t\tlet vertexCount = input.readInt(true);\r\n\t\t\t\tlet vertices = this.readVertices(input, vertexCount);\r\n\t\t\t\tlet color = nonessential ? input.readInt32() : 0;\r\n\r\n\t\t\t\tlet clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n\t\t\t\tif (clip == null) return null;\r\n\t\t\t\tclip.endSlot = skeletonData.slots[endSlotIndex];\r\n\t\t\t\tclip.worldVerticesLength = vertexCount << 1;\r\n\t\t\t\tclip.vertices = vertices.vertices;\r\n\t\t\t\tclip.bones = vertices.bones;\r\n\t\t\t\tif (nonessential) Color.rgba8888ToColor(clip.color, color);\r\n\t\t\t\treturn clip;\r\n\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tprivate readVertices (input: BinaryInput, vertexCount: number): Vertices {\r\n\t\t\tlet verticesLength = vertexCount << 1;\r\n\t\t\tlet vertices = new Vertices();\r\n\t\t\tlet scale = this.scale;\r\n\t\t\tif (!input.readBoolean()) {\r\n\t\t\t\tvertices.vertices = this.readFloatArray(input, verticesLength, scale);\r\n\t\t\t\treturn vertices;\r\n\t\t\t}\r\n\t\t\tlet weights = new Array<number>();\r\n\t\t\tlet bonesArray = new Array<number>();\r\n\t\t\tfor (let i = 0; i < vertexCount; i++) {\r\n\t\t\t\tlet boneCount = input.readInt(true);\r\n\t\t\t\tbonesArray.push(boneCount);\r\n\t\t\t\tfor (let ii = 0; ii < boneCount; ii++) {\r\n\t\t\t\t\tbonesArray.push(input.readInt(true));\r\n\t\t\t\t\tweights.push(input.readFloat() * scale);\r\n\t\t\t\t\tweights.push(input.readFloat() * scale);\r\n\t\t\t\t\tweights.push(input.readFloat());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvertices.vertices = Utils.toFloatArray(weights);\r\n\t\t\tvertices.bones = bonesArray;\r\n\t\t\treturn vertices;\r\n\t\t}\r\n\r\n\t\tprivate readFloatArray (input: BinaryInput, n: number, scale: number): number[] {\r\n\t\t\tlet array = new Array<number>(n);\r\n\t\t\tif (scale == 1) {\r\n\t\t\t\tfor (let i = 0; i < n; i++)\r\n\t\t\t\t\tarray[i] = input.readFloat();\r\n\t\t\t} else {\r\n\t\t\t\tfor (let i = 0; i < n; i++)\r\n\t\t\t\t\tarray[i] = input.readFloat() * scale;\r\n\t\t\t}\r\n\t\t\treturn array;\r\n\t\t}\r\n\r\n\t\tprivate readShortArray (input: BinaryInput): number[] {\r\n\t\t\tlet n = input.readInt(true);\r\n\t\t\tlet array = new Array<number>(n);\r\n\t\t\tfor (let i = 0; i < n; i++)\r\n\t\t\t\tarray[i] = input.readShort();\r\n\t\t\treturn array;\r\n\t\t}\r\n\r\n\t\tprivate readAnimation (input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\r\n\t\t\tlet timelines = new Array<Timeline>();\r\n\t\t\tlet scale = this.scale;\r\n\t\t\tlet duration = 0;\r\n\t\t\tlet tempColor1 = new Color();\r\n\t\t\tlet tempColor2 = new Color();\r\n\r\n\t\t\t// Slot timelines.\r\n\t\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\r\n\t\t\t\tlet slotIndex = input.readInt(true);\r\n\t\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n\t\t\t\t\tlet timelineType = input.readByte();\r\n\t\t\t\t\tlet frameCount = input.readInt(true);\r\n\t\t\t\t\tswitch (timelineType) {\r\n\t\t\t\t\tcase SkeletonBinary.SLOT_ATTACHMENT: {\r\n\t\t\t\t\t\tlet timeline = new AttachmentTimeline(frameCount);\r\n\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++)\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readStringRef());\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcase SkeletonBinary.SLOT_COLOR: {\r\n\t\t\t\t\t\tlet timeline = new ColorTimeline(frameCount);\r\n\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n\t\t\t\t\t\t\tlet time = input.readFloat();\r\n\t\t\t\t\t\t\tColor.rgba8888ToColor(tempColor1, input.readInt32());\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a);\r\n\t\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * ColorTimeline.ENTRIES]);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcase SkeletonBinary.SLOT_TWO_COLOR: {\r\n\t\t\t\t\t\tlet timeline = new TwoColorTimeline(frameCount);\r\n\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n\t\t\t\t\t\t\tlet time = input.readFloat();\r\n\t\t\t\t\t\t\tColor.rgba8888ToColor(tempColor1, input.readInt32());\r\n\t\t\t\t\t\t\tColor.rgb888ToColor(tempColor2, input.readInt32());\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, time, tempColor1.r, tempColor1.g, tempColor1.b, tempColor1.a, tempColor2.r,\r\n\t\t\t\t\t\t\t\ttempColor2.g, tempColor2.b);\r\n\t\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * TwoColorTimeline.ENTRIES]);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Bone timelines.\r\n\t\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\r\n\t\t\t\tlet boneIndex = input.readInt(true);\r\n\t\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n\t\t\t\t\tlet timelineType = input.readByte();\r\n\t\t\t\t\tlet frameCount = input.readInt(true);\r\n\t\t\t\t\tswitch (timelineType) {\r\n\t\t\t\t\tcase SkeletonBinary.BONE_ROTATE: {\r\n\t\t\t\t\t\tlet timeline = new RotateTimeline(frameCount);\r\n\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\r\n\t\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat());\r\n\t\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * RotateTimeline.ENTRIES]);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcase SkeletonBinary.BONE_TRANSLATE:\r\n\t\t\t\t\tcase SkeletonBinary.BONE_SCALE:\r\n\t\t\t\t\tcase SkeletonBinary.BONE_SHEAR: {\r\n\t\t\t\t\t\tlet timeline;\r\n\t\t\t\t\t\tlet timelineScale = 1;\r\n\t\t\t\t\t\tif (timelineType == SkeletonBinary.BONE_SCALE)\r\n\t\t\t\t\t\t\ttimeline = new ScaleTimeline(frameCount);\r\n\t\t\t\t\t\telse if (timelineType == SkeletonBinary.BONE_SHEAR)\r\n\t\t\t\t\t\t\ttimeline = new ShearTimeline(frameCount);\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\ttimeline = new TranslateTimeline(frameCount);\r\n\t\t\t\t\t\t\ttimelineScale = scale;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimeline.boneIndex = boneIndex;\r\n\t\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale,\r\n\t\t\t\t\t\t\t\tinput.readFloat() * timelineScale);\r\n\t\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * TranslateTimeline.ENTRIES]);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// IK constraint timelines.\r\n\t\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\r\n\t\t\t\tlet index = input.readInt(true);\r\n\t\t\t\tlet frameCount = input.readInt(true);\r\n\t\t\t\tlet timeline = new IkConstraintTimeline(frameCount);\r\n\t\t\t\ttimeline.ikConstraintIndex = index;\r\n\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat() * scale, input.readByte(), input.readBoolean(),\r\n\t\t\t\t\t\tinput.readBoolean());\r\n\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n\t\t\t\t}\r\n\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * IkConstraintTimeline.ENTRIES]);\r\n\t\t\t}\r\n\r\n\t\t\t// Transform constraint timelines.\r\n\t\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\r\n\t\t\t\tlet index = input.readInt(true);\r\n\t\t\t\tlet frameCount = input.readInt(true);\r\n\t\t\t\tlet timeline = new TransformConstraintTimeline(frameCount);\r\n\t\t\t\ttimeline.transformConstraintIndex = index;\r\n\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat(),\r\n\t\t\t\t\t\tinput.readFloat());\r\n\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n\t\t\t\t}\r\n\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * TransformConstraintTimeline.ENTRIES]);\r\n\t\t\t}\r\n\r\n\t\t\t// Path constraint timelines.\r\n\t\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\r\n\t\t\t\tlet index = input.readInt(true);\r\n\t\t\t\tlet data = skeletonData.pathConstraints[index];\r\n\t\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n\t\t\t\t\tlet timelineType = input.readByte();\r\n\t\t\t\t\tlet frameCount = input.readInt(true);\r\n\t\t\t\t\tswitch (timelineType) {\r\n\t\t\t\t\tcase SkeletonBinary.PATH_POSITION:\r\n\t\t\t\t\tcase SkeletonBinary.PATH_SPACING: {\r\n\t\t\t\t\t\tlet timeline;\r\n\t\t\t\t\t\tlet timelineScale = 1;\r\n\t\t\t\t\t\tif (timelineType == SkeletonBinary.PATH_SPACING) {\r\n\t\t\t\t\t\t\ttimeline = new PathConstraintSpacingTimeline(frameCount);\r\n\t\t\t\t\t\t\tif (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttimeline = new PathConstraintPositionTimeline(frameCount);\r\n\t\t\t\t\t\t\tif (data.positionMode == PositionMode.Fixed) timelineScale = scale;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\r\n\t\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale);\r\n\t\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintPositionTimeline.ENTRIES]);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcase SkeletonBinary.PATH_MIX: {\r\n\t\t\t\t\t\tlet timeline = new PathConstraintMixTimeline(frameCount);\r\n\t\t\t\t\t\ttimeline.pathConstraintIndex = index;\r\n\t\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readFloat());\r\n\t\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[(frameCount - 1) * PathConstraintMixTimeline.ENTRIES]);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Deform timelines.\r\n\t\t\tfor (let i = 0, n = input.readInt(true); i < n; i++) {\r\n\t\t\t\tlet skin = skeletonData.skins[input.readInt(true)];\r\n\t\t\t\tfor (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\r\n\t\t\t\t\tlet slotIndex = input.readInt(true);\r\n\t\t\t\t\tfor (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\r\n\t\t\t\t\t\tlet attachment = skin.getAttachment(slotIndex, input.readStringRef()) as VertexAttachment;\r\n\t\t\t\t\t\tlet weighted = attachment.bones != null;\r\n\t\t\t\t\t\tlet vertices = attachment.vertices;\r\n\t\t\t\t\t\tlet deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\r\n\t\t\t\t\t\tlet frameCount = input.readInt(true);\r\n\t\t\t\t\t\tlet timeline = new DeformTimeline(frameCount);\r\n\t\t\t\t\t\ttimeline.slotIndex = slotIndex;\r\n\t\t\t\t\t\ttimeline.attachment = attachment;\r\n\r\n\t\t\t\t\t\tfor (let frameIndex = 0; frameIndex < frameCount; frameIndex++) {\r\n\t\t\t\t\t\t\tlet time = input.readFloat();\r\n\t\t\t\t\t\t\tlet deform;\r\n\t\t\t\t\t\t\tlet end = input.readInt(true);\r\n\t\t\t\t\t\t\tif (end == 0)\r\n\t\t\t\t\t\t\t\tdeform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\tdeform = Utils.newFloatArray(deformLength);\r\n\t\t\t\t\t\t\t\tlet start = input.readInt(true);\r\n\t\t\t\t\t\t\t\tend += start;\r\n\t\t\t\t\t\t\t\tif (scale == 1) {\r\n\t\t\t\t\t\t\t\t\tfor (let v = start; v < end; v++)\r\n\t\t\t\t\t\t\t\t\t\tdeform[v] = input.readFloat();\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tfor (let v = start; v < end; v++)\r\n\t\t\t\t\t\t\t\t\t\tdeform[v] = input.readFloat() * scale;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (!weighted) {\r\n\t\t\t\t\t\t\t\t\tfor (let v = 0, vn = deform.length; v < vn; v++)\r\n\t\t\t\t\t\t\t\t\t\tdeform[v] += vertices[v];\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\ttimeline.setFrame(frameIndex, time, deform);\r\n\t\t\t\t\t\t\tif (frameIndex < frameCount - 1) this.readCurve(input, frameIndex, timeline);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\t\t\tduration = Math.max(duration, timeline.frames[frameCount - 1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Draw order timeline.\r\n\t\t\tlet drawOrderCount = input.readInt(true);\r\n\t\t\tif (drawOrderCount > 0) {\r\n\t\t\t\tlet timeline = new DrawOrderTimeline(drawOrderCount);\r\n\t\t\t\tlet slotCount = skeletonData.slots.length;\r\n\t\t\t\tfor (let i = 0; i < drawOrderCount; i++) {\r\n\t\t\t\t\tlet time = input.readFloat();\r\n\t\t\t\t\tlet offsetCount = input.readInt(true);\r\n\t\t\t\t\tlet drawOrder = Utils.newArray(slotCount, 0);\r\n\t\t\t\t\tfor (let ii = slotCount - 1; ii >= 0; ii--)\r\n\t\t\t\t\t\tdrawOrder[ii] = -1;\r\n\t\t\t\t\tlet unchanged = Utils.newArray(slotCount - offsetCount, 0);\r\n\t\t\t\t\tlet originalIndex = 0, unchangedIndex = 0;\r\n\t\t\t\t\tfor (let ii = 0; ii < offsetCount; ii++) {\r\n\t\t\t\t\t\tlet slotIndex = input.readInt(true);\r\n\t\t\t\t\t\t// Collect unchanged items.\r\n\t\t\t\t\t\twhile (originalIndex != slotIndex)\r\n\t\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\r\n\t\t\t\t\t\t// Set changed items.\r\n\t\t\t\t\t\tdrawOrder[originalIndex + input.readInt(true)] = originalIndex++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// Collect remaining unchanged items.\r\n\t\t\t\t\twhile (originalIndex < slotCount)\r\n\t\t\t\t\t\tunchanged[unchangedIndex++] = originalIndex++;\r\n\t\t\t\t\t// Fill in unchanged items.\r\n\t\t\t\t\tfor (let ii = slotCount - 1; ii >= 0; ii--)\r\n\t\t\t\t\t\tif (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\r\n\t\t\t\t\ttimeline.setFrame(i, time, drawOrder);\r\n\t\t\t\t}\r\n\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\tduration = Math.max(duration, timeline.frames[drawOrderCount - 1]);\r\n\t\t\t}\r\n\r\n\t\t\t// Event timeline.\r\n\t\t\tlet eventCount = input.readInt(true);\r\n\t\t\tif (eventCount > 0) {\r\n\t\t\t\tlet timeline = new EventTimeline(eventCount);\r\n\t\t\t\tfor (let i = 0; i < eventCount; i++) {\r\n\t\t\t\t\tlet time = input.readFloat();\r\n\t\t\t\t\tlet eventData = skeletonData.events[input.readInt(true)];\r\n\t\t\t\t\tlet event = new Event(time, eventData);\r\n\t\t\t\t\tevent.intValue = input.readInt(false);\r\n\t\t\t\t\tevent.floatValue = input.readFloat();\r\n\t\t\t\t\tevent.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\r\n\t\t\t\t\tif (event.data.audioPath != null) {\r\n\t\t\t\t\t\tevent.volume = input.readFloat();\r\n\t\t\t\t\t\tevent.balance = input.readFloat();\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttimeline.setFrame(i, event);\r\n\t\t\t\t}\r\n\t\t\t\ttimelines.push(timeline);\r\n\t\t\t\tduration = Math.max(duration, timeline.frames[eventCount - 1]);\r\n\t\t\t}\r\n\r\n\t\t\treturn new Animation(name, timelines, duration);\r\n\t\t}\r\n\r\n\t\tprivate readCurve (input: BinaryInput, frameIndex: number, timeline: CurveTimeline) {\r\n\t\t\tswitch (input.readByte()) {\r\n\t\t\tcase SkeletonBinary.CURVE_STEPPED:\r\n\t\t\t\ttimeline.setStepped(frameIndex);\r\n\t\t\t\tbreak;\r\n\t\t\tcase SkeletonBinary.CURVE_BEZIER:\r\n\t\t\t\tthis.setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat());\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsetCurve (timeline: CurveTimeline, frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\r\n\t\t\ttimeline.setCurve(frameIndex, cx1, cy1, cx2, cy2);\r\n\t\t}\r\n\t}\r\n\r\n\tclass BinaryInput {\r\n\t\tconstructor(data: Uint8Array, public strings = new Array<string>(), private index: number = 0, private buffer = new DataView(data.buffer)) { \r\n\r\n\t\t}\r\n\r\n\t\treadByte(): number {\r\n\t\t\treturn this.buffer.getInt8(this.index++);\r\n\t\t}\r\n\r\n\t\treadShort(): number {\r\n\t\t\tlet value = this.buffer.getInt16(this.index);\r\n\t\t\tthis.index += 2;\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\treadInt32(): number {\r\n\t\t\t let value = this.buffer.getInt32(this.index)\r\n\t\t\t this.index += 4;\r\n\t\t\t return value;\r\n\t\t}\r\n\r\n\t\treadInt(optimizePositive: boolean) {\r\n\t\t\tlet b = this.readByte();\r\n\t\t\tlet result = b & 0x7F;\r\n\t\t\tif ((b & 0x80) != 0) {\r\n\t\t\t\tb = this.readByte();\r\n\t\t\t\tresult |= (b & 0x7F) << 7;\r\n\t\t\t\tif ((b & 0x80) != 0) {\r\n\t\t\t\t\tb = this.readByte();\r\n\t\t\t\t\tresult |= (b & 0x7F) << 14;\r\n\t\t\t\t\tif ((b & 0x80) != 0) {\r\n\t\t\t\t\t\tb = this.readByte();\r\n\t\t\t\t\t\tresult |= (b & 0x7F) << 21;\r\n\t\t\t\t\t\tif ((b & 0x80) != 0) {\r\n\t\t\t\t\t\t\tb = this.readByte();\r\n\t\t\t\t\t\t\tresult |= (b & 0x7F) << 28;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn optimizePositive ? result : ((result >>> 1) ^ -(result & 1));\r\n\t\t}\r\n\r\n\t\treadStringRef (): string {\r\n\t\t\tlet index = this.readInt(true);\r\n\t\t\treturn index == 0 ? null : this.strings[index - 1];\r\n\t\t}\r\n\r\n\t\treadString (): string {\r\n\t\t\tlet byteCount = this.readInt(true);\r\n\t\t\tswitch (byteCount) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn null;\r\n\t\t\tcase 1:\r\n\t\t\t\treturn \"\";\r\n\t\t\t}\r\n\t\t\tbyteCount--;\r\n\t\t\tlet chars = \"\";\r\n\t\t\tlet charCount = 0;\r\n\t\t\tfor (let i = 0; i < byteCount;) {\r\n\t\t\t\tlet b = this.readByte();\r\n\t\t\t\tswitch (b >> 4) {\r\n\t\t\t\tcase 12:\r\n\t\t\t\tcase 13:\r\n\t\t\t\t\tchars += String.fromCharCode(((b & 0x1F) << 6 | this.readByte() & 0x3F));\r\n\t\t\t\t\ti += 2;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 14:\r\n\t\t\t\t\tchars += String.fromCharCode(((b & 0x0F) << 12 | (this.readByte() & 0x3F) << 6 | this.readByte() & 0x3F));\r\n\t\t\t\t\ti += 3;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tchars += String.fromCharCode(b);\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn chars;\r\n\t\t}\r\n\r\n\t\treadFloat (): number {\r\n\t\t\tlet value = this.buffer.getFloat32(this.index);\r\n\t\t\tthis.index += 4;\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\treadBoolean (): boolean {\r\n\t\t\treturn this.readByte() != 0;\r\n\t\t}\r\n\t}\r\n\r\n\tclass LinkedMesh {\r\n\t\tparent: string; skin: string;\r\n\t\tslotIndex: number;\r\n\t\tmesh: MeshAttachment;\r\n\t\tinheritDeform: boolean;\r\n\r\n\t\tconstructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\r\n\t\t\tthis.mesh = mesh;\r\n\t\t\tthis.skin = skin;\r\n\t\t\tthis.slotIndex = slotIndex;\r\n\t\t\tthis.parent = parent;\r\n\t\t\tthis.inheritDeform = inheritDeform;\r\n\t\t}\r\n\t}\r\n\r\n\tclass Vertices {\r\n\t\tconstructor(public bones: Array<number> = null, public vertices: Array<number> | Float32Array = null) { }\r\n\t}\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class SkeletonBounds {\r\n        minX = 0; minY = 0; maxX = 0; maxY = 0;\r\n        boundingBoxes = new Array<BoundingBoxAttachment>();\r\n        polygons = new Array<ArrayLike<number>>();\r\n        private polygonPool = new Pool<ArrayLike<number>>(() => {\r\n            return Utils.newFloatArray(16);\r\n        });\r\n\r\n        update (skeleton: Skeleton, updateAabb: boolean) {\r\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n            let boundingBoxes = this.boundingBoxes;\r\n            let polygons = this.polygons;\r\n            let polygonPool = this.polygonPool;\r\n            let slots = skeleton.slots;\r\n            let slotCount = slots.length;\r\n\r\n            boundingBoxes.length = 0;\r\n            polygonPool.freeAll(polygons);\r\n            polygons.length = 0;\r\n\r\n            for (let i = 0; i < slotCount; i++) {\r\n                let slot = slots[i];\r\n                if (!slot.bone.active) continue;\r\n                let attachment = slot.getAttachment();\r\n                if (attachment instanceof BoundingBoxAttachment) {\r\n                    let boundingBox = attachment as BoundingBoxAttachment;\r\n                    boundingBoxes.push(boundingBox);\r\n\r\n                    let polygon = polygonPool.obtain();\r\n                    if (polygon.length != boundingBox.worldVerticesLength) {\r\n                        polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\r\n                    }\r\n                    polygons.push(polygon);\r\n                    boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\r\n                }\r\n            }\r\n\r\n            if (updateAabb) {\r\n                this.aabbCompute();\r\n            } else {\r\n                this.minX = Number.POSITIVE_INFINITY;\r\n                this.minY = Number.POSITIVE_INFINITY;\r\n                this.maxX = Number.NEGATIVE_INFINITY;\r\n                this.maxY = Number.NEGATIVE_INFINITY;\r\n            }\r\n        }\r\n\r\n        aabbCompute () {\r\n            let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\r\n            let polygons = this.polygons;\r\n            for (let i = 0, n = polygons.length; i < n; i++) {\r\n                let polygon = polygons[i];\r\n                let vertices = polygon;\r\n                for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\r\n                    let x = vertices[ii];\r\n                    let y = vertices[ii + 1];\r\n                    minX = Math.min(minX, x);\r\n                    minY = Math.min(minY, y);\r\n                    maxX = Math.max(maxX, x);\r\n                    maxY = Math.max(maxY, y);\r\n                }\r\n            }\r\n            this.minX = minX;\r\n            this.minY = minY;\r\n            this.maxX = maxX;\r\n            this.maxY = maxY;\r\n        }\r\n\r\n        /** Returns true if the axis aligned bounding box contains the point. */\r\n        aabbContainsPoint (x: number, y: number) {\r\n            return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n        }\r\n\r\n        /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n        aabbIntersectsSegment (x1: number, y1: number, x2: number, y2: number) {\r\n            let minX = this.minX;\r\n            let minY = this.minY;\r\n            let maxX = this.maxX;\r\n            let maxY = this.maxY;\r\n            if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n                return false;\r\n            let m = (y2 - y1) / (x2 - x1);\r\n            let y = m * (minX - x1) + y1;\r\n            if (y > minY && y < maxY) return true;\r\n            y = m * (maxX - x1) + y1;\r\n            if (y > minY && y < maxY) return true;\r\n            let x = (minY - y1) / m + x1;\r\n            if (x > minX && x < maxX) return true;\r\n            x = (maxY - y1) / m + x1;\r\n            if (x > minX && x < maxX) return true;\r\n            return false;\r\n        }\r\n\r\n        /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n        aabbIntersectsSkeleton (bounds: SkeletonBounds) {\r\n            return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n        }\r\n\r\n        /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n         * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\r\n        containsPoint (x: number, y: number): BoundingBoxAttachment {\r\n            let polygons = this.polygons;\r\n            for (let i = 0, n = polygons.length; i < n; i++)\r\n                if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\r\n            return null;\r\n        }\r\n\r\n        /** Returns true if the polygon contains the point. */\r\n        containsPointPolygon (polygon: ArrayLike<number>, x: number, y: number) {\r\n            let vertices = polygon;\r\n            let nn = polygon.length;\r\n\r\n            let prevIndex = nn - 2;\r\n            let inside = false;\r\n            for (let ii = 0; ii < nn; ii += 2) {\r\n                let vertexY = vertices[ii + 1];\r\n                let prevY = vertices[prevIndex + 1];\r\n                if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\r\n                    let vertexX = vertices[ii];\r\n                    if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\r\n                }\r\n                prevIndex = ii;\r\n            }\r\n            return inside;\r\n        }\r\n\r\n        /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\r\n         * is usually more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns\r\n         * true. */\r\n        intersectsSegment (x1: number, y1: number, x2: number, y2: number) {\r\n            let polygons = this.polygons;\r\n            for (let i = 0, n = polygons.length; i < n; i++)\r\n                if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n            return null;\r\n        }\r\n\r\n        /** Returns true if the polygon contains any part of the line segment. */\r\n        intersectsSegmentPolygon (polygon: ArrayLike<number>, x1: number, y1: number, x2: number, y2: number) {\r\n            let vertices = polygon;\r\n            let nn = polygon.length;\r\n\r\n            let width12 = x1 - x2, height12 = y1 - y2;\r\n            let det1 = x1 * y2 - y1 * x2;\r\n            let x3 = vertices[nn - 2], y3 = vertices[nn - 1];\r\n            for (let ii = 0; ii < nn; ii += 2) {\r\n                let x4 = vertices[ii], y4 = vertices[ii + 1];\r\n                let det2 = x3 * y4 - y3 * x4;\r\n                let width34 = x3 - x4, height34 = y3 - y4;\r\n                let det3 = width12 * height34 - height12 * width34;\r\n                let x = (det1 * width34 - width12 * det2) / det3;\r\n                if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\r\n                    let y = (det1 * height34 - height12 * det2) / det3;\r\n                    if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n                }\r\n                x3 = x4;\r\n                y3 = y4;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /** Returns the polygon for the specified bounding box, or null. */\r\n        getPolygon (boundingBox: BoundingBoxAttachment) {\r\n            if (boundingBox == null) throw new Error(\"boundingBox cannot be null.\");\r\n            let index = this.boundingBoxes.indexOf(boundingBox);\r\n            return index == -1 ? null : this.polygons[index];\r\n        }\r\n\r\n        getWidth () {\r\n            return this.maxX - this.minX;\r\n        }\r\n\r\n        getHeight () {\r\n            return this.maxY - this.minY;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License v2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n\texport class SkeletonClipping {\r\n\t\tprivate triangulator = new Triangulator();\r\n\t\tprivate clippingPolygon = new Array<number>();\r\n\t\tprivate clipOutput = new Array<number>();\r\n\t\tclippedVertices = new Array<number>();\r\n\t\tclippedTriangles = new Array<number>();\r\n\t\tprivate scratch = new Array<number>();\r\n\r\n\t\tprivate clipAttachment: ClippingAttachment;\r\n\t\tprivate clippingPolygons: Array<Array<number>>;\r\n\r\n\t\tclipStart (slot: Slot, clip: ClippingAttachment): number {\r\n\t\t\tif (this.clipAttachment != null) return 0;\r\n\t\t\tthis.clipAttachment = clip;\r\n\r\n\t\t\tlet n = clip.worldVerticesLength;\r\n\t\t\tlet vertices = Utils.setArraySize(this.clippingPolygon, n);\r\n\t\t\tclip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n\t\t\tlet clippingPolygon = this.clippingPolygon;\r\n\t\t\tSkeletonClipping.makeClockwise(clippingPolygon);\r\n\t\t\tlet clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\r\n\t\t\tfor (let i = 0, n = clippingPolygons.length; i < n; i++) {\r\n\t\t\t\tlet polygon = clippingPolygons[i];\r\n\t\t\t\tSkeletonClipping.makeClockwise(polygon);\r\n\t\t\t\tpolygon.push(polygon[0]);\r\n\t\t\t\tpolygon.push(polygon[1]);\r\n\t\t\t}\r\n\r\n\t\t\treturn clippingPolygons.length;\r\n\t\t}\r\n\r\n\t\tclipEndWithSlot (slot: Slot) {\r\n\t\t\tif (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data) this.clipEnd();\r\n\t\t}\r\n\r\n\t\tclipEnd () {\r\n\t\t\tif (this.clipAttachment == null) return;\r\n\t\t\tthis.clipAttachment = null;\r\n\t\t\tthis.clippingPolygons = null;\r\n\t\t\tthis.clippedVertices.length = 0;\r\n\t\t\tthis.clippedTriangles.length = 0;\r\n\t\t\tthis.clippingPolygon.length = 0;\r\n\t\t}\r\n\r\n\t\tisClipping (): boolean {\r\n\t\t\treturn this.clipAttachment != null;\r\n\t\t}\r\n\r\n\t\tclipTriangles (vertices: ArrayLike<number>, verticesLength: number, triangles: ArrayLike<number>, trianglesLength: number, uvs: ArrayLike<number>,\r\n\t\t\tlight: Color, dark: Color, twoColor: boolean) {\r\n\r\n\t\t\tlet clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\r\n\t\t\tlet clippedTriangles = this.clippedTriangles;\r\n\t\t\tlet polygons = this.clippingPolygons;\r\n\t\t\tlet polygonsCount = this.clippingPolygons.length;\r\n\t\t\tlet vertexSize = twoColor ? 12 : 8;\r\n\r\n\t\t\tlet index = 0;\r\n\t\t\tclippedVertices.length = 0;\r\n\t\t\tclippedTriangles.length = 0;\r\n\t\t\touter:\r\n\t\t\tfor (let i = 0; i < trianglesLength; i += 3) {\r\n\t\t\t\tlet vertexOffset = triangles[i] << 1;\r\n\t\t\t\tlet x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\r\n\t\t\t\tlet u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\r\n\r\n\t\t\t\tvertexOffset = triangles[i + 1] << 1;\r\n\t\t\t\tlet x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\r\n\t\t\t\tlet u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\r\n\r\n\t\t\t\tvertexOffset = triangles[i + 2] << 1;\r\n\t\t\t\tlet x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\r\n\t\t\t\tlet u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\r\n\r\n\t\t\t\tfor (let p = 0; p < polygonsCount; p++) {\r\n\t\t\t\t\tlet s = clippedVertices.length;\r\n\t\t\t\t\tif (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\r\n\t\t\t\t\t\tlet clipOutputLength = clipOutput.length;\r\n\t\t\t\t\t\tif (clipOutputLength == 0) continue;\r\n\t\t\t\t\t\tlet d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\r\n\t\t\t\t\t\tlet d = 1 / (d0 * d2 + d1 * (y1 - y3));\r\n\r\n\t\t\t\t\t\tlet clipOutputCount = clipOutputLength >> 1;\r\n\t\t\t\t\t\tlet clipOutputItems = this.clipOutput;\r\n\t\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\r\n\t\t\t\t\t\tfor (let ii = 0; ii < clipOutputLength; ii += 2) {\r\n\t\t\t\t\t\t\tlet x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\r\n\t\t\t\t\t\t\tclippedVerticesItems[s] = x;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 1] = y;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\r\n\t\t\t\t\t\t\tlet c0 = x - x3, c1 = y - y3;\r\n\t\t\t\t\t\t\tlet a = (d0 * c0 + d1 * c1) * d;\r\n\t\t\t\t\t\t\tlet b = (d4 * c0 + d2 * c1) * d;\r\n\t\t\t\t\t\t\tlet c = 1 - a - b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\r\n\t\t\t\t\t\t\tif (twoColor) {\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\r\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\ts += vertexSize;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ts = clippedTriangles.length;\r\n\t\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\r\n\t\t\t\t\t\tclipOutputCount--;\r\n\t\t\t\t\t\tfor (let ii = 1; ii < clipOutputCount; ii++) {\r\n\t\t\t\t\t\t\tclippedTrianglesItems[s] = index;\r\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + ii);\r\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + ii + 1);\r\n\t\t\t\t\t\t\ts += 3;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tindex += clipOutputCount + 1;\r\n\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\r\n\t\t\t\t\t\tclippedVerticesItems[s] = x1;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 1] = y1;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\r\n\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\r\n\t\t\t\t\t\tif (!twoColor) {\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\r\n\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = x2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = y2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = u2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = v2;\r\n\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = x3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = y3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = u3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = v3;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\r\n\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = x2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = y2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = u2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = v2;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = dark.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = dark.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = dark.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = dark.a;\r\n\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 24] = x3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 25] = y3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 26] = light.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 27] = light.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 28] = light.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 29] = light.a;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 30] = u3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 31] = v3;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 32] = dark.r;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 33] = dark.g;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 34] = dark.b;\r\n\t\t\t\t\t\t\tclippedVerticesItems[s + 35] = dark.a;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ts = clippedTriangles.length;\r\n\t\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3);\r\n\t\t\t\t\t\tclippedTrianglesItems[s] = index;\r\n\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + 1);\r\n\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + 2);\r\n\t\t\t\t\t\tindex += 3;\r\n\t\t\t\t\t\tcontinue outer;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/** Clips the input triangle against the convex, clockwise clipping area. If the triangle lies entirely within the clipping\r\n\t\t * area, false is returned. The clipping area must duplicate the first vertex at the end of the vertices list. */\r\n\t\tclip (x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, clippingArea: Array<number>, output: Array<number>) {\r\n\t\t\tlet originalOutput = output;\r\n\t\t\tlet clipped = false;\r\n\r\n\t\t\t// Avoid copy at the end.\r\n\t\t\tlet input: Array<number> = null;\r\n\t\t\tif (clippingArea.length % 4 >= 2) {\r\n\t\t\t\tinput = output;\r\n\t\t\t\toutput = this.scratch;\r\n\t\t\t} else\r\n\t\t\t\tinput = this.scratch;\r\n\r\n\t\t\tinput.length = 0;\r\n\t\t\tinput.push(x1);\r\n\t\t\tinput.push(y1);\r\n\t\t\tinput.push(x2);\r\n\t\t\tinput.push(y2);\r\n\t\t\tinput.push(x3);\r\n\t\t\tinput.push(y3);\r\n\t\t\tinput.push(x1);\r\n\t\t\tinput.push(y1);\r\n\t\t\toutput.length = 0;\r\n\r\n\t\t\tlet clippingVertices = clippingArea;\r\n\t\t\tlet clippingVerticesLast = clippingArea.length - 4;\r\n\t\t\tfor (let i = 0;; i += 2) {\r\n\t\t\t\tlet edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];\r\n\t\t\t\tlet edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];\r\n\t\t\t\tlet deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;\r\n\r\n\t\t\t\tlet inputVertices = input;\r\n\t\t\t\tlet inputVerticesLength = input.length - 2, outputStart = output.length;\r\n\t\t\t\tfor (let ii = 0; ii < inputVerticesLength; ii += 2) {\r\n\t\t\t\t\tlet inputX = inputVertices[ii], inputY = inputVertices[ii + 1];\r\n\t\t\t\t\tlet inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];\r\n\t\t\t\t\tlet side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\r\n\t\t\t\t\tif (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\r\n\t\t\t\t\t\tif (side2) { // v1 inside, v2 inside\r\n\t\t\t\t\t\t\toutput.push(inputX2);\r\n\t\t\t\t\t\t\toutput.push(inputY2);\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// v1 inside, v2 outside\r\n\t\t\t\t\t\tlet c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n\t\t\t\t\t\tlet ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\r\n\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\r\n\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\r\n\t\t\t\t\t} else if (side2) { // v1 outside, v2 inside\r\n\t\t\t\t\t\tlet c0 = inputY2 - inputY, c2 = inputX2 - inputX;\r\n\t\t\t\t\t\tlet ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\r\n\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\r\n\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\r\n\t\t\t\t\t\toutput.push(inputX2);\r\n\t\t\t\t\t\toutput.push(inputY2);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclipped = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (outputStart == output.length) { // All edges outside.\r\n\t\t\t\t\toriginalOutput.length = 0;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\toutput.push(output[0]);\r\n\t\t\t\toutput.push(output[1]);\r\n\r\n\t\t\t\tif (i == clippingVerticesLast) break;\r\n\t\t\t\tlet temp = output;\r\n\t\t\t\toutput = input;\r\n\t\t\t\toutput.length = 0;\r\n\t\t\t\tinput = temp;\r\n\t\t\t}\r\n\r\n\t\t\tif (originalOutput != output) {\r\n\t\t\t\toriginalOutput.length = 0;\r\n\t\t\t\tfor (let i = 0, n = output.length - 2; i < n; i++)\r\n\t\t\t\t\toriginalOutput[i] = output[i];\r\n\t\t\t} else\r\n\t\t\t\toriginalOutput.length = originalOutput.length - 2;\r\n\r\n\t\t\treturn clipped;\r\n\t\t}\r\n\r\n\t\tpublic static makeClockwise (polygon: ArrayLike<number>) {\r\n\t\t\tlet vertices = polygon;\r\n\t\t\tlet verticeslength = polygon.length;\r\n\r\n\t\t\tlet area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;\r\n\t\t\tfor (let i = 0, n = verticeslength - 3; i < n; i += 2) {\r\n\t\t\t\tp1x = vertices[i];\r\n\t\t\t\tp1y = vertices[i + 1];\r\n\t\t\t\tp2x = vertices[i + 2];\r\n\t\t\t\tp2y = vertices[i + 3];\r\n\t\t\t\tarea += p1x * p2y - p2x * p1y;\r\n\t\t\t}\r\n\t\t\tif (area < 0) return;\r\n\r\n\t\t\tfor (let i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\r\n\t\t\t\tlet x = vertices[i], y = vertices[i + 1];\r\n\t\t\t\tlet other = lastX - i;\r\n\t\t\t\tvertices[i] = vertices[other];\r\n\t\t\t\tvertices[i + 1] = vertices[other + 1];\r\n\t\t\t\tvertices[other] = x;\r\n\t\t\t\tvertices[other + 1] = y;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class SkeletonData {\r\n        name: string;\r\n        bones = new Array<BoneData>(); // Ordered parents first.\r\n        slots = new Array<SlotData>(); // Setup pose draw order.\r\n        skins = new Array<Skin>();\r\n        defaultSkin: Skin;\r\n        events = new Array<EventData>();\r\n        animations = new Array<Animation>();\r\n        ikConstraints = new Array<IkConstraintData>();\r\n        transformConstraints = new Array<TransformConstraintData>();\r\n        pathConstraints = new Array<PathConstraintData>();\r\n        x: number; y: number; width: number; height: number;\r\n        version: string; hash: string;\r\n\r\n        // Nonessential\r\n        fps = 0;\r\n        imagesPath: string;\r\n        audioPath: string;\r\n\r\n        findBone (boneName: string) {\r\n            if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n            let bones = this.bones;\r\n            for (let i = 0, n = bones.length; i < n; i++) {\r\n                let bone = bones[i];\r\n                if (bone.name == boneName) return bone;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        findBoneIndex (boneName: string) {\r\n            if (boneName == null) throw new Error(\"boneName cannot be null.\");\r\n            let bones = this.bones;\r\n            for (let i = 0, n = bones.length; i < n; i++)\r\n                if (bones[i].name == boneName) return i;\r\n            return -1;\r\n        }\r\n\r\n        findSlot (slotName: string) {\r\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n            let slots = this.slots;\r\n            for (let i = 0, n = slots.length; i < n; i++) {\r\n                let slot = slots[i];\r\n                if (slot.name == slotName) return slot;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        findSlotIndex (slotName: string) {\r\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\r\n            let slots = this.slots;\r\n            for (let i = 0, n = slots.length; i < n; i++)\r\n                if (slots[i].name == slotName) return i;\r\n            return -1;\r\n        }\r\n\r\n        findSkin (skinName: string) {\r\n            if (skinName == null) throw new Error(\"skinName cannot be null.\");\r\n            let skins = this.skins;\r\n            for (let i = 0, n = skins.length; i < n; i++) {\r\n                let skin = skins[i];\r\n                if (skin.name == skinName) return skin;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        findEvent (eventDataName: string) {\r\n            if (eventDataName == null) throw new Error(\"eventDataName cannot be null.\");\r\n            let events = this.events;\r\n            for (let i = 0, n = events.length; i < n; i++) {\r\n                let event = events[i];\r\n                if (event.name == eventDataName) return event;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        findAnimation (animationName: string) {\r\n            if (animationName == null) throw new Error(\"animationName cannot be null.\");\r\n            let animations = this.animations;\r\n            for (let i = 0, n = animations.length; i < n; i++) {\r\n                let animation = animations[i];\r\n                if (animation.name == animationName) return animation;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        findIkConstraint (constraintName: string) {\r\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n            let ikConstraints = this.ikConstraints;\r\n            for (let i = 0, n = ikConstraints.length; i < n; i++) {\r\n                let constraint = ikConstraints[i];\r\n                if (constraint.name == constraintName) return constraint;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        findTransformConstraint (constraintName: string) {\r\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n            let transformConstraints = this.transformConstraints;\r\n            for (let i = 0, n = transformConstraints.length; i < n; i++) {\r\n                let constraint = transformConstraints[i];\r\n                if (constraint.name == constraintName) return constraint;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        findPathConstraint (constraintName: string) {\r\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\r\n            let pathConstraints = this.pathConstraints;\r\n            for (let i = 0, n = pathConstraints.length; i < n; i++) {\r\n                let constraint = pathConstraints[i];\r\n                if (constraint.name == constraintName) return constraint;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        findPathConstraintIndex (pathConstraintName: string) {\r\n            if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\r\n            let pathConstraints = this.pathConstraints;\r\n            for (let i = 0, n = pathConstraints.length; i < n; i++)\r\n                if (pathConstraints[i].name == pathConstraintName) return i;\r\n            return -1;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    /**\r\n     * pixi-spine gives option to not fail at certain parsing errors\r\n     * spine-ts fails here\r\n     */\r\n    export let FAIL_ON_NON_EXISTING_SKIN = false;\r\n\r\n    export class SkeletonJson {\r\n        attachmentLoader: AttachmentLoader;\r\n        scale = 1;\r\n        private linkedMeshes = new Array<LinkedMesh>();\r\n\r\n        constructor (attachmentLoader: AttachmentLoader) {\r\n            this.attachmentLoader = attachmentLoader;\r\n        }\r\n\r\n        readSkeletonData (json: string | any): SkeletonData {\r\n            let scale = this.scale;\r\n            let skeletonData = new SkeletonData();\r\n            let root = typeof(json) === \"string\" ? JSON.parse(json) : json;\r\n\r\n            // Skeleton\r\n            let skeletonMap = root.skeleton;\r\n            if (skeletonMap != null) {\r\n                skeletonData.hash = skeletonMap.hash;\r\n                skeletonData.version = skeletonMap.spine;\r\n                if (skeletonData.version.substr(0, 3) !== '3.8') {\r\n                    let error = `PixiJS Spine plugin supports only format for Spine 3.8. Your model has version ${skeletonMap.spine}. Please look in pixi-spine repository README for another branch.`;\r\n                    console.error(error);\r\n                }\r\n                if (skeletonData.version === '3.8.75')\r\n                {\r\n                    let error = `Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine.`;\r\n                    console.error(error);\r\n                }\r\n                skeletonData.x = skeletonMap.x;\r\n                skeletonData.y = skeletonMap.y;\r\n                skeletonData.width = skeletonMap.width;\r\n                skeletonData.height = skeletonMap.height;\r\n                skeletonData.fps = skeletonMap.fps;\r\n                skeletonData.imagesPath = skeletonMap.images;\r\n            }\r\n\r\n            // Bones\r\n            if (root.bones) {\r\n                for (let i = 0; i < root.bones.length; i++) {\r\n                    let boneMap = root.bones[i];\r\n\r\n                    let parent: BoneData = null;\r\n                    let parentName: string = this.getValue(boneMap, \"parent\", null);\r\n                    if (parentName != null) {\r\n                        parent = skeletonData.findBone(parentName);\r\n                        if (parent == null) throw new Error(\"Parent bone not found: \" + parentName);\r\n                    }\r\n                    let data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\r\n                    data.length = this.getValue(boneMap, \"length\", 0) * scale;\r\n                    data.x = this.getValue(boneMap, \"x\", 0) * scale;\r\n                    data.y = this.getValue(boneMap, \"y\", 0) * scale;\r\n                    data.rotation = this.getValue(boneMap, \"rotation\", 0);\r\n                    data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\r\n                    data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\r\n                    data.shearX = this.getValue(boneMap, \"shearX\", 0);\r\n                    data.shearY = this.getValue(boneMap, \"shearY\", 0);\r\n                    data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\r\n                    data.skinRequired = this.getValue(boneMap, \"skin\", false);\r\n\r\n                    skeletonData.bones.push(data);\r\n                }\r\n            }\r\n\r\n            // Slots.\r\n            if (root.slots) {\r\n                for (let i = 0; i < root.slots.length; i++) {\r\n                    let slotMap = root.slots[i];\r\n                    let slotName: string = slotMap.name;\r\n                    let boneName: string = slotMap.bone;\r\n                    let boneData = skeletonData.findBone(boneName);\r\n                    if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\r\n                    let data = new SlotData(skeletonData.slots.length, slotName, boneData);\r\n\r\n                    let color: string = this.getValue(slotMap, \"color\", null);\r\n                    if (color != null) data.color.setFromString(color);\r\n\r\n                    let dark: string = this.getValue(slotMap, \"dark\", null);\r\n                    if (dark != null) {\r\n                        data.darkColor = new Color(1, 1, 1, 1);\r\n                        data.darkColor.setFromString(dark);\r\n                    }\r\n\r\n                    data.attachmentName = this.getValue(slotMap, \"attachment\", null);\r\n                    data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\r\n                    skeletonData.slots.push(data);\r\n                }\r\n            }\r\n\r\n            // IK constraints\r\n            if (root.ik) {\r\n                for (let i = 0; i < root.ik.length; i++) {\r\n                    let constraintMap = root.ik[i];\r\n                    let data = new IkConstraintData(constraintMap.name);\r\n                    data.order = this.getValue(constraintMap, \"order\", 0);\r\n                    data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n\r\n                    for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                        let boneName = constraintMap.bones[j];\r\n                        let bone = skeletonData.findBone(boneName);\r\n                        if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\r\n                        data.bones.push(bone);\r\n                    }\r\n\r\n                    let targetName: string = constraintMap.target;\r\n                    data.target = skeletonData.findBone(targetName);\r\n                    if (data.target == null) throw new Error(\"IK target bone not found: \" + targetName);\r\n\r\n                    data.mix = this.getValue(constraintMap, \"mix\", 1);\r\n                    data.softness = this.getValue(constraintMap, \"softness\", 0) * scale;\r\n                    data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\r\n                    data.compress = this.getValue(constraintMap, \"compress\", false);\r\n                    data.stretch = this.getValue(constraintMap, \"stretch\", false);\r\n                    data.uniform = this.getValue(constraintMap, \"uniform\", false);\r\n\r\n                    skeletonData.ikConstraints.push(data);\r\n                }\r\n            }\r\n\r\n            // Transform constraints.\r\n            if (root.transform) {\r\n                for (let i = 0; i < root.transform.length; i++) {\r\n                    let constraintMap = root.transform[i];\r\n                    let data = new TransformConstraintData(constraintMap.name);\r\n                    data.order = this.getValue(constraintMap, \"order\", 0);\r\n                    data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n\r\n                    for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                        let boneName = constraintMap.bones[j];\r\n                        let bone = skeletonData.findBone(boneName);\r\n                        if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                        data.bones.push(bone);\r\n                    }\r\n\r\n                    let targetName: string = constraintMap.target;\r\n                    data.target = skeletonData.findBone(targetName);\r\n                    if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\r\n\r\n                    data.local = this.getValue(constraintMap, \"local\", false);\r\n                    data.relative = this.getValue(constraintMap, \"relative\", false);\r\n                    data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                    data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\r\n                    data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\r\n                    data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\r\n                    data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\r\n                    data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\r\n\r\n                    data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                    data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n                    data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\r\n                    data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\r\n\r\n                    skeletonData.transformConstraints.push(data);\r\n                }\r\n            }\r\n\r\n            // Path constraints.\r\n            if (root.path) {\r\n                for (let i = 0; i < root.path.length; i++) {\r\n                    let constraintMap = root.path[i];\r\n                    let data = new PathConstraintData(constraintMap.name);\r\n                    data.order = this.getValue(constraintMap, \"order\", 0);\r\n                    data.skinRequired = this.getValue(constraintMap, \"skin\", false);\r\n\r\n                    for (let j = 0; j < constraintMap.bones.length; j++) {\r\n                        let boneName = constraintMap.bones[j];\r\n                        let bone = skeletonData.findBone(boneName);\r\n                        if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\r\n                        data.bones.push(bone);\r\n                    }\r\n\r\n                    let targetName: string = constraintMap.target;\r\n                    data.target = skeletonData.findSlot(targetName);\r\n                    if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\r\n\r\n                    data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\r\n                    data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\r\n                    data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\r\n                    data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\r\n                    data.position = this.getValue(constraintMap, \"position\", 0);\r\n                    if (data.positionMode == PositionMode.Fixed) data.position *= scale;\r\n                    data.spacing = this.getValue(constraintMap, \"spacing\", 0);\r\n                    if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\r\n                    data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\r\n                    data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\r\n\r\n                    skeletonData.pathConstraints.push(data);\r\n                }\r\n            }\r\n\r\n            // Skins.\r\n            if (root.skins) {\r\n                for (let i = 0; i < root.skins.length; i++) {\r\n                    let skinMap = root.skins[i]\r\n                    let skin = new Skin(skinMap.name);\r\n\r\n                    if (skinMap.bones) {\r\n                        for (let ii = 0; ii < skinMap.bones.length; ii++) {\r\n                            let bone = skeletonData.findBone(skinMap.bones[ii]);\r\n                            if (bone == null) throw new Error(\"Skin bone not found: \" + skinMap.bones[i]);\r\n                            skin.bones.push(bone);\r\n                        }\r\n                    }\r\n\r\n                    if (skinMap.ik) {\r\n                        for (let ii = 0; ii < skinMap.ik.length; ii++) {\r\n                            let constraint = skeletonData.findIkConstraint(skinMap.ik[ii]);\r\n                            if (constraint == null) throw new Error(\"Skin IK constraint not found: \" + skinMap.ik[i]);\r\n                            skin.constraints.push(constraint);\r\n                        }\r\n                    }\r\n\r\n                    if (skinMap.transform) {\r\n                        for (let ii = 0; ii < skinMap.transform.length; ii++) {\r\n                            let constraint = skeletonData.findTransformConstraint(skinMap.transform[ii]);\r\n                            if (constraint == null) throw new Error(\"Skin transform constraint not found: \" + skinMap.transform[i]);\r\n                            skin.constraints.push(constraint);\r\n                        }\r\n                    }\r\n\r\n                    if (skinMap.path) {\r\n                        for (let ii = 0; ii < skinMap.path.length; ii++) {\r\n                            let constraint = skeletonData.findPathConstraint(skinMap.path[ii]);\r\n                            if (constraint == null) throw new Error(\"Skin path constraint not found: \" + skinMap.path[i]);\r\n                            skin.constraints.push(constraint);\r\n                        }\r\n                    }\r\n\r\n                    for (let slotName in skinMap.attachments) {\r\n                        let slot = skeletonData.findSlot(slotName);\r\n                        if (slot == null) throw new Error(\"Slot not found: \" + slotName);\r\n                        let slotMap = skinMap.attachments[slotName];\r\n                        for (let entryName in slotMap) {\r\n                            let attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\r\n                            if (attachment != null) skin.setAttachment(slot.index, entryName, attachment);\r\n                        }\r\n                    }\r\n                    skeletonData.skins.push(skin);\r\n                    if (skin.name == \"default\") skeletonData.defaultSkin = skin;\r\n                }\r\n            }\r\n\r\n            // Linked meshes.\r\n            for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\r\n                let linkedMesh = this.linkedMeshes[i];\r\n                let skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\r\n                if (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\r\n                let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n                if (parent == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\r\n                linkedMesh.mesh.deformAttachment = linkedMesh.inheritDeform ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\r\n                linkedMesh.mesh.setParentMesh(<MeshAttachment> parent);\r\n                // linkedMesh.mesh.updateUVs();\r\n            }\r\n            this.linkedMeshes.length = 0;\r\n\r\n            // Events.\r\n            if (root.events) {\r\n                for (let eventName in root.events) {\r\n                    let eventMap = root.events[eventName];\r\n                    let data = new EventData(eventName);\r\n                    data.intValue = this.getValue(eventMap, \"int\", 0);\r\n                    data.floatValue = this.getValue(eventMap, \"float\", 0);\r\n                    data.stringValue = this.getValue(eventMap, \"string\", \"\");\r\n                    data.audioPath = this.getValue(eventMap, \"audio\", null);\r\n                    if (data.audioPath != null) {\r\n                        data.volume = this.getValue(eventMap, \"volume\", 1);\r\n                        data.balance = this.getValue(eventMap, \"balance\", 0);\r\n                    }\r\n                    skeletonData.events.push(data);\r\n                }\r\n            }\r\n\r\n            // Animations.\r\n            if (root.animations) {\r\n                for (let animationName in root.animations) {\r\n                    let animationMap = root.animations[animationName];\r\n                    this.readAnimation(animationMap, animationName, skeletonData);\r\n                }\r\n            }\r\n\r\n            return skeletonData;\r\n        }\r\n\r\n        readAttachment (map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\r\n            let scale = this.scale;\r\n            name = this.getValue(map, \"name\", name);\r\n\r\n            let type = this.getValue(map, \"type\", \"region\");\r\n\r\n            switch (type) {\r\n                case \"region\": {\r\n                    let path = this.getValue(map, \"path\", name);\r\n                    let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n                    if (region == null) return null;\r\n                    region.path = path;\r\n                    region.x = this.getValue(map, \"x\", 0) * scale;\r\n                    region.y = this.getValue(map, \"y\", 0) * scale;\r\n                    region.scaleX = this.getValue(map, \"scaleX\", 1);\r\n                    region.scaleY = this.getValue(map, \"scaleY\", 1);\r\n                    region.rotation = this.getValue(map, \"rotation\", 0);\r\n                    region.width = map.width * scale;\r\n                    region.height = map.height * scale;\r\n\r\n                    let color: string = this.getValue(map, \"color\", null);\r\n                    if (color != null) region.color.setFromString(color);\r\n\r\n                    // region.updateOffset();\r\n                    return region;\r\n                }\r\n                case \"boundingbox\": {\r\n                    let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n                    if (box == null) return null;\r\n                    this.readVertices(map, box, map.vertexCount << 1);\r\n                    let color: string = this.getValue(map, \"color\", null);\r\n                    if (color != null) box.color.setFromString(color);\r\n                    return box;\r\n                }\r\n                case \"mesh\":\r\n                case \"linkedmesh\": {\r\n                    let path = this.getValue(map, \"path\", name);\r\n                    let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                    if (mesh == null) return null;\r\n                    mesh.path = path;\r\n\r\n                    let color = this.getValue(map, \"color\", null);\r\n                    if (color != null) mesh.color.setFromString(color);\r\n\r\n                    mesh.width = this.getValue(map, \"width\", 0) * scale;\r\n                    mesh.height = this.getValue(map, \"height\", 0) * scale;\r\n\r\n                    let parent: string = this.getValue(map, \"parent\", null);\r\n                    if (parent != null) {\r\n                        this.linkedMeshes.push(new LinkedMesh(mesh, <string> this.getValue(map, \"skin\", null), slotIndex, parent, this.getValue(map, \"deform\", true)));\r\n                        return mesh;\r\n                    }\r\n\r\n                    let uvs: Array<number> = map.uvs;\r\n                    this.readVertices(map, mesh, uvs.length);\r\n                    mesh.triangles = map.triangles;\r\n                    mesh.regionUVs = new Float32Array(uvs);\r\n                    // mesh.updateUVs();\r\n\r\n                    mesh.edges = this.getValue(map, \"edges\", null);\r\n                    mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\r\n                    return mesh;\r\n                }\r\n                case \"path\": {\r\n                    let path = this.attachmentLoader.newPathAttachment(skin, name);\r\n                    if (path == null) return null;\r\n                    path.closed = this.getValue(map, \"closed\", false);\r\n                    path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\r\n\r\n                    let vertexCount = map.vertexCount;\r\n                    this.readVertices(map, path, vertexCount << 1);\r\n\r\n                    let lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\r\n                    for (let i = 0; i < map.lengths.length; i++)\r\n                        lengths[i] = map.lengths[i] * scale;\r\n                    path.lengths = lengths;\r\n\r\n                    let color: string = this.getValue(map, \"color\", null);\r\n                    if (color != null) path.color.setFromString(color);\r\n                    return path;\r\n                }\r\n                case \"point\": {\r\n                    let point = this.attachmentLoader.newPointAttachment(skin, name);\r\n                    if (point == null) return null;\r\n                    point.x = this.getValue(map, \"x\", 0) * scale;\r\n                    point.y = this.getValue(map, \"y\", 0) * scale;\r\n                    point.rotation = this.getValue(map, \"rotation\", 0);\r\n\r\n                    let color = this.getValue(map, \"color\", null);\r\n                    if (color != null) point.color.setFromString(color);\r\n                    return point;\r\n                }\r\n                case \"clipping\": {\r\n                    let clip = this.attachmentLoader.newClippingAttachment(skin, name);\r\n                    if (clip == null) return null;\r\n\r\n                    let end = this.getValue(map, \"end\", null);\r\n                    if (end != null) {\r\n                        let slot = skeletonData.findSlot(end);\r\n                        if (slot == null) throw new Error(\"Clipping end slot not found: \" + end);\r\n                        clip.endSlot = slot;\r\n                    }\r\n\r\n                    let vertexCount = map.vertexCount;\r\n                    this.readVertices(map, clip, vertexCount << 1);\r\n\r\n                    let color: string = this.getValue(map, \"color\", null);\r\n                    if (color != null) clip.color.setFromString(color);\r\n                    return clip;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        readVertices (map: any, attachment: VertexAttachment, verticesLength: number) {\r\n            let scale = this.scale;\r\n            attachment.worldVerticesLength = verticesLength;\r\n            let vertices: Array<number> = map.vertices;\r\n            if (verticesLength == vertices.length) {\r\n                let scaledVertices = Utils.toFloatArray(vertices);\r\n                if (scale != 1) {\r\n                    for (let i = 0, n = vertices.length; i < n; i++)\r\n                        scaledVertices[i] *= scale;\r\n                }\r\n                attachment.vertices = scaledVertices;\r\n                return;\r\n            }\r\n            let weights = new Array<number>();\r\n            let bones = new Array<number>();\r\n            for (let i = 0, n = vertices.length; i < n;) {\r\n                let boneCount = vertices[i++];\r\n                bones.push(boneCount);\r\n                for (let nn = i + boneCount * 4; i < nn; i += 4) {\r\n                    bones.push(vertices[i]);\r\n                    weights.push(vertices[i + 1] * scale);\r\n                    weights.push(vertices[i + 2] * scale);\r\n                    weights.push(vertices[i + 3]);\r\n                }\r\n            }\r\n            attachment.bones = bones;\r\n            attachment.vertices = Utils.toFloatArray(weights);\r\n        }\r\n\r\n        readAnimation (map: any, name: string, skeletonData: SkeletonData) {\r\n            let scale = this.scale;\r\n            let timelines = new Array<Timeline>();\r\n            let duration = 0;\r\n\r\n            // Slot timelines.\r\n            if (map.slots) {\r\n                for (let slotName in map.slots) {\r\n                    let slotMap = map.slots[slotName];\r\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\r\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\r\n                    for (let timelineName in slotMap) {\r\n                        let timelineMap = slotMap[timelineName];\r\n                        if (timelineName == \"attachment\") {\r\n                            let timeline = new AttachmentTimeline(timelineMap.length);\r\n                            timeline.slotIndex = slotIndex;\r\n\r\n                            let frameIndex = 0;\r\n                            for (let i = 0; i < timelineMap.length; i++) {\r\n                                let valueMap = timelineMap[i];\r\n                                timeline.setFrame(frameIndex++, this.getValue(valueMap, \"time\", 0), valueMap.name);\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                        } else if (timelineName == \"color\") {\r\n                            let timeline = new ColorTimeline(timelineMap.length);\r\n                            timeline.slotIndex = slotIndex;\r\n\r\n                            let frameIndex = 0;\r\n                            for (let i = 0; i < timelineMap.length; i++) {\r\n                                let valueMap = timelineMap[i];\r\n                                let color = new Color();\r\n                                color.setFromString(valueMap.color || \"ffffffff\");\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), color.r, color.g, color.b, color.a);\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\r\n\r\n                        } else if (timelineName == \"twoColor\") {\r\n                            let timeline = new TwoColorTimeline(timelineMap.length);\r\n                            timeline.slotIndex = slotIndex;\r\n\r\n                            let frameIndex = 0;\r\n                            for (let i = 0; i < timelineMap.length; i++) {\r\n                                let valueMap = timelineMap[i];\r\n                                let light = new Color();\r\n                                let dark = new Color();\r\n                                light.setFromString(valueMap.light);\r\n                                dark.setFromString(valueMap.dark);\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\r\n\r\n                        } else\r\n                            throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Bone timelines.\r\n            if (map.bones) {\r\n                for (let boneName in map.bones) {\r\n                    let boneMap = map.bones[boneName];\r\n                    let boneIndex = skeletonData.findBoneIndex(boneName);\r\n                    if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\r\n                    for (let timelineName in boneMap) {\r\n                        let timelineMap = boneMap[timelineName];\r\n                        if (timelineName === \"rotate\") {\r\n                            let timeline = new RotateTimeline(timelineMap.length);\r\n                            timeline.boneIndex = boneIndex;\r\n\r\n                            let frameIndex = 0;\r\n                            for (let i = 0; i < timelineMap.length; i++) {\r\n                                let valueMap = timelineMap[i];\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"angle\", 0));\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\r\n\r\n                        } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\r\n                            let timeline: TranslateTimeline = null;\r\n                            let timelineScale = 1, defaultValue = 0;\r\n                            if (timelineName === \"scale\") {\r\n                                timeline = new ScaleTimeline(timelineMap.length);\r\n                                defaultValue = 1;\r\n                            } else if (timelineName === \"shear\")\r\n                                timeline = new ShearTimeline(timelineMap.length);\r\n                            else {\r\n                                timeline = new TranslateTimeline(timelineMap.length);\r\n                                timelineScale = scale;\r\n                            }\r\n                            timeline.boneIndex = boneIndex;\r\n\r\n                            let frameIndex = 0;\r\n                            for (let i = 0; i < timelineMap.length; i++) {\r\n                                let valueMap = timelineMap[i];\r\n                                let x = this.getValue(valueMap, \"x\", defaultValue), y = this.getValue(valueMap, \"y\", defaultValue);\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), x * timelineScale, y * timelineScale);\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\r\n\r\n                        } else\r\n                            throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\r\n                    }\r\n                }\r\n            }\r\n\r\n            // IK constraint timelines.\r\n            if (map.ik) {\r\n                for (let constraintName in map.ik) {\r\n                    let constraintMap = map.ik[constraintName];\r\n                    let constraint = skeletonData.findIkConstraint(constraintName);\r\n                    let timeline = new IkConstraintTimeline(constraintMap.length);\r\n                    timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\r\n                    let frameIndex = 0;\r\n                    for (let i = 0; i < constraintMap.length; i++) {\r\n                        let valueMap = constraintMap[i];\r\n                        timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"softness\", 0) * scale,\r\n                            this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1, this.getValue(valueMap, \"compress\", false), this.getValue(valueMap, \"stretch\", false));\r\n                        this.readCurve(valueMap, timeline, frameIndex);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\r\n                }\r\n            }\r\n\r\n            // Transform constraint timelines.\r\n            if (map.transform) {\r\n                for (let constraintName in map.transform) {\r\n                    let constraintMap = map.transform[constraintName];\r\n                    let constraint = skeletonData.findTransformConstraint(constraintName);\r\n                    let timeline = new TransformConstraintTimeline(constraintMap.length);\r\n                    timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\r\n                    let frameIndex = 0;\r\n                    for (let i = 0; i < constraintMap.length; i++) {\r\n                        let valueMap = constraintMap[i];\r\n                        timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1),\r\n                            this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\r\n                        this.readCurve(valueMap, timeline, frameIndex);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration,\r\n                        timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\r\n                }\r\n            }\r\n\r\n            // Path constraint timelines.\r\n            if (map.path) {\r\n                for (let constraintName in map.path) {\r\n                    let constraintMap = map.path[constraintName];\r\n                    let index = skeletonData.findPathConstraintIndex(constraintName);\r\n                    if (index == -1) throw new Error(\"Path constraint not found: \" + constraintName);\r\n                    let data = skeletonData.pathConstraints[index];\r\n                    for (let timelineName in constraintMap) {\r\n                        let timelineMap = constraintMap[timelineName];\r\n                        if (timelineName === \"position\" || timelineName === \"spacing\") {\r\n                            let timeline: PathConstraintPositionTimeline = null;\r\n                            let timelineScale = 1;\r\n                            if (timelineName === \"spacing\") {\r\n                                timeline = new PathConstraintSpacingTimeline(timelineMap.length);\r\n                                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\r\n                            } else {\r\n                                timeline = new PathConstraintPositionTimeline(timelineMap.length);\r\n                                if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\r\n                            }\r\n                            timeline.pathConstraintIndex = index;\r\n                            let frameIndex = 0;\r\n                            for (let i = 0; i < timelineMap.length; i++) {\r\n                                let valueMap = timelineMap[i];\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, timelineName, 0) * timelineScale);\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration,\r\n                                timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\r\n                        } else if (timelineName === \"mix\") {\r\n                            let timeline = new PathConstraintMixTimeline(timelineMap.length);\r\n                            timeline.pathConstraintIndex = index;\r\n                            let frameIndex = 0;\r\n                            for (let i = 0; i < timelineMap.length; i++) {\r\n                                let valueMap = timelineMap[i];\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), this.getValue(valueMap, \"rotateMix\", 1),\r\n                                    this.getValue(valueMap, \"translateMix\", 1));\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration,\r\n                                timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Deform timelines.\r\n            if (map.deform) {\r\n                for (let deformName in map.deform) {\r\n                    let deformMap = map.deform[deformName];\r\n                    let skin = skeletonData.findSkin(deformName);\r\n                    if (skin == null) {\r\n                       if (FAIL_ON_NON_EXISTING_SKIN) {\r\n                           throw new Error(\"Skin not found: \" + deformName);\r\n                       } else {\r\n                           continue;\r\n                       }\r\n                    }\r\n                    for (let slotName in deformMap) {\r\n                        let slotMap = deformMap[slotName];\r\n                        let slotIndex = skeletonData.findSlotIndex(slotName);\r\n                        if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\r\n                        for (let timelineName in slotMap) {\r\n                            let timelineMap = slotMap[timelineName];\r\n                            let attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\r\n                            if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\r\n                            let weighted = attachment.bones != null;\r\n                            let vertices = attachment.vertices;\r\n                            let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\r\n\r\n                            let timeline = new DeformTimeline(timelineMap.length);\r\n                            timeline.slotIndex = slotIndex;\r\n                            timeline.attachment = attachment;\r\n\r\n                            let frameIndex = 0;\r\n                            for (let j = 0; j < timelineMap.length; j++) {\r\n                                let valueMap = timelineMap[j];\r\n                                let deform: ArrayLike<number>;\r\n                                let verticesValue: Array<Number> = this.getValue(valueMap, \"vertices\", null);\r\n                                if (verticesValue == null)\r\n                                    deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\r\n                                else {\r\n                                    deform = Utils.newFloatArray(deformLength);\r\n                                    let start = <number>this.getValue(valueMap, \"offset\", 0);\r\n                                    Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\r\n                                    if (scale != 1) {\r\n                                        for (let i = start, n = i + verticesValue.length; i < n; i++)\r\n                                            deform[i] *= scale;\r\n                                    }\r\n                                    if (!weighted) {\r\n                                        for (let i = 0; i < deformLength; i++)\r\n                                            deform[i] += vertices[i];\r\n                                    }\r\n                                }\r\n\r\n                                timeline.setFrame(frameIndex, this.getValue(valueMap, \"time\", 0), deform);\r\n                                this.readCurve(valueMap, timeline, frameIndex);\r\n                                frameIndex++;\r\n                            }\r\n                            timelines.push(timeline);\r\n                            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Draw order timeline.\r\n            let drawOrderNode = map.drawOrder;\r\n            if (drawOrderNode == null) drawOrderNode = map.draworder;\r\n            if (drawOrderNode != null) {\r\n                let timeline = new DrawOrderTimeline(drawOrderNode.length);\r\n                let slotCount = skeletonData.slots.length;\r\n                let frameIndex = 0;\r\n                for (let j = 0; j < drawOrderNode.length; j++) {\r\n                    let drawOrderMap = drawOrderNode[j];\r\n                    let drawOrder: Array<number> = null;\r\n                    let offsets = this.getValue(drawOrderMap, \"offsets\", null);\r\n                    if (offsets != null) {\r\n                        drawOrder = Utils.newArray<number>(slotCount, -1);\r\n                        let unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\r\n                        let originalIndex = 0, unchangedIndex = 0;\r\n                        for (let i = 0; i < offsets.length; i++) {\r\n                            let offsetMap = offsets[i];\r\n                            let slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\r\n                            if (slotIndex == -1) throw new Error(\"Slot not found: \" + offsetMap.slot);\r\n                            // Collect unchanged items.\r\n                            while (originalIndex != slotIndex)\r\n                                unchanged[unchangedIndex++] = originalIndex++;\r\n                            // Set changed items.\r\n                            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\r\n                        }\r\n                        // Collect remaining unchanged items.\r\n                        while (originalIndex < slotCount)\r\n                            unchanged[unchangedIndex++] = originalIndex++;\r\n                        // Fill in unchanged items.\r\n                        for (let i = slotCount - 1; i >= 0; i--)\r\n                            if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\r\n                    }\r\n                    timeline.setFrame(frameIndex++, this.getValue(drawOrderMap, \"time\", 0), drawOrder);\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n            }\r\n\r\n            // Event timeline.\r\n            if (map.events) {\r\n                let timeline = new EventTimeline(map.events.length);\r\n                let frameIndex = 0;\r\n                for (let i = 0; i < map.events.length; i++) {\r\n                    let eventMap = map.events[i];\r\n                    let eventData = skeletonData.findEvent(eventMap.name);\r\n                    if (eventData == null) throw new Error(\"Event not found: \" + eventMap.name);\r\n                    let event = new Event(Utils.toSinglePrecision(this.getValue(eventMap, \"time\", 0)), eventData);\r\n                    event.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\r\n                    event.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\r\n                    event.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\r\n                    if (event.data.audioPath != null) {\r\n                        event.volume = this.getValue(eventMap, \"volume\", 1);\r\n                        event.balance = this.getValue(eventMap, \"balance\", 0);\r\n                    }\r\n                    timeline.setFrame(frameIndex++, event);\r\n                }\r\n                timelines.push(timeline);\r\n                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n            }\r\n\r\n            if (isNaN(duration)) {\r\n                throw new Error(\"Error while parsing animation, duration is NaN\");\r\n            }\r\n\r\n            skeletonData.animations.push(new Animation(name, timelines, duration));\r\n        }\r\n\r\n        readCurve (map: any, timeline: CurveTimeline, frameIndex: number) {\r\n            if (!map.hasOwnProperty(\"curve\")) return;\r\n            if (map.curve === \"stepped\")\r\n                timeline.setStepped(frameIndex);\r\n            else {\r\n                let curve: number = map.curve;\r\n                timeline.setCurve(frameIndex, curve, this.getValue(map, \"c2\", 0), this.getValue(map, \"c3\", 1), this.getValue(map, \"c4\", 1));\r\n            }\r\n        }\r\n\r\n        getValue (map: any, prop: string, defaultValue: any) {\r\n            return map[prop] !== undefined ? map[prop] : defaultValue;\r\n        }\r\n\r\n        static blendModeFromString (str: string) {\r\n            str = str.toLowerCase();\r\n            if (str == \"normal\") return BlendMode.Normal;\r\n            if (str == \"additive\") return BlendMode.Additive;\r\n            if (str == \"multiply\") return BlendMode.Multiply;\r\n            if (str == \"screen\") return BlendMode.Screen;\r\n            throw new Error(`Unknown blend mode: ${str}`);\r\n        }\r\n\r\n        static positionModeFromString (str: string) {\r\n            str = str.toLowerCase();\r\n            if (str == \"fixed\") return PositionMode.Fixed;\r\n            if (str == \"percent\") return PositionMode.Percent;\r\n            throw new Error(`Unknown position mode: ${str}`);\r\n        }\r\n\r\n        static spacingModeFromString (str: string) {\r\n            str = str.toLowerCase();\r\n            if (str == \"length\") return SpacingMode.Length;\r\n            if (str == \"fixed\") return SpacingMode.Fixed;\r\n            if (str == \"percent\") return SpacingMode.Percent;\r\n            throw new Error(`Unknown position mode: ${str}`);\r\n        }\r\n\r\n        static rotateModeFromString (str: string) {\r\n            str = str.toLowerCase();\r\n            if (str == \"tangent\") return RotateMode.Tangent;\r\n            if (str == \"chain\") return RotateMode.Chain;\r\n            if (str == \"chainscale\") return RotateMode.ChainScale;\r\n            throw new Error(`Unknown rotate mode: ${str}`);\r\n        }\r\n\r\n        static transformModeFromString(str: string) {\r\n            str = str.toLowerCase();\r\n            if (str == \"normal\") return TransformMode.Normal;\r\n            if (str == \"onlytranslation\") return TransformMode.OnlyTranslation;\r\n            if (str == \"norotationorreflection\") return TransformMode.NoRotationOrReflection;\r\n            if (str == \"noscale\") return TransformMode.NoScale;\r\n            if (str == \"noscaleorreflection\") return TransformMode.NoScaleOrReflection;\r\n            throw new Error(`Unknown transform mode: ${str}`);\r\n        }\r\n    }\r\n\r\n    class LinkedMesh {\r\n        parent: string; skin: string;\r\n        slotIndex: number;\r\n        mesh: MeshAttachment;\r\n        inheritDeform: boolean;\r\n\r\n        constructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\r\n            this.mesh = mesh;\r\n            this.skin = skin;\r\n            this.slotIndex = slotIndex;\r\n            this.parent = parent;\r\n            this.inheritDeform = inheritDeform;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class SkinEntry {\r\n        constructor(public slotIndex: number, public name: string, public attachment: Attachment) { }\r\n    }\r\n\r\n    export class Skin {\r\n        name: string;\r\n        attachments = new Array<Map<Attachment>>();\r\n        bones = Array<BoneData>();\r\n        constraints = new Array<ConstraintData>();\r\n\r\n        constructor (name: string) {\r\n            if (name == null) throw new Error(\"name cannot be null.\");\r\n            this.name = name;\r\n        }\r\n\r\n        setAttachment (slotIndex: number, name: string, attachment: Attachment) {\r\n            if (attachment == null) throw new Error(\"attachment cannot be null.\");\r\n            let attachments = this.attachments;\r\n            if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\r\n            if (!attachments[slotIndex]) attachments[slotIndex] = { };\r\n            attachments[slotIndex][name] = attachment;\r\n        }\r\n\r\n        addSkin (skin: Skin) {\r\n            for(let i = 0; i < skin.bones.length; i++) {\r\n                let bone = skin.bones[i];\r\n                let contained = false;\r\n                for (let j = 0; j < this.bones.length; j++) {\r\n                    if (this.bones[j] == bone) {\r\n                        contained = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!contained) this.bones.push(bone);\r\n            }\r\n\r\n            for(let i = 0; i < skin.constraints.length; i++) {\r\n                let constraint = skin.constraints[i];\r\n                let contained = false;\r\n                for (let j = 0; j < this.constraints.length; j++) {\r\n                    if (this.constraints[j] == constraint) {\r\n                        contained = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!contained) this.constraints.push(constraint);\r\n            }\r\n\r\n            let attachments = skin.getAttachments();\r\n            for (let i = 0; i < attachments.length; i++) {\r\n                var attachment = attachments[i];\r\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n            }\r\n        }\r\n\r\n        copySkin (skin: Skin) {\r\n            for(let i = 0; i < skin.bones.length; i++) {\r\n                let bone = skin.bones[i];\r\n                let contained = false;\r\n                for (let j = 0; j < this.bones.length; j++) {\r\n                    if (this.bones[j] == bone) {\r\n                        contained = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!contained) this.bones.push(bone);\r\n            }\r\n\r\n            for(let i = 0; i < skin.constraints.length; i++) {\r\n                let constraint = skin.constraints[i];\r\n                let contained = false;\r\n                for (let j = 0; j < this.constraints.length; j++) {\r\n                    if (this.constraints[j] == constraint) {\r\n                        contained = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!contained) this.constraints.push(constraint);\r\n            }\r\n\r\n            let attachments = skin.getAttachments();\r\n            for (let i = 0; i < attachments.length; i++) {\r\n                var attachment = attachments[i];\r\n                if (attachment.attachment == null) continue;\r\n                if (attachment.attachment instanceof MeshAttachment) {\r\n                    attachment.attachment = attachment.attachment.newLinkedMesh();\r\n                    this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n                } else {\r\n                    attachment.attachment = attachment.attachment.copy();\r\n                    this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\r\n                }\r\n            }\r\n        }\r\n\r\n        /** @return May be null. */\r\n        getAttachment (slotIndex: number, name: string): Attachment {\r\n            let dictionary = this.attachments[slotIndex];\r\n            return dictionary ? dictionary[name] : null;\r\n        }\r\n\r\n        removeAttachment (slotIndex: number, name: string) {\r\n            let dictionary = this.attachments[slotIndex];\r\n            if (dictionary) dictionary[name] = null;\r\n        }\r\n\r\n        getAttachments (): Array<SkinEntry> {\r\n            let entries = new Array<SkinEntry>();\r\n            for (var i = 0; i < this.attachments.length; i++) {\r\n                let slotAttachments = this.attachments[i];\r\n                if (slotAttachments) {\r\n                    for (let name in slotAttachments) {\r\n                        let attachment = slotAttachments[name];\r\n                        if (attachment) entries.push(new SkinEntry(i, name, attachment));\r\n                    }\r\n                }\r\n            }\r\n            return entries;\r\n        }\r\n\r\n        getAttachmentsForSlot (slotIndex: number, attachments: Array<SkinEntry>) {\r\n            let slotAttachments = this.attachments[slotIndex];\r\n            if (slotAttachments) {\r\n                for (let name in slotAttachments) {\r\n                    let attachment = slotAttachments[name];\r\n                    if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\r\n                }\r\n            }\r\n        }\r\n\r\n        clear () {\r\n            this.attachments.length = 0;\r\n            this.bones.length = 0;\r\n            this.constraints.length = 0;\r\n        }\r\n\r\n        /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\r\n        attachAll (skeleton: Skeleton, oldSkin: Skin) {\r\n            let slotIndex = 0;\r\n            for (let i = 0; i < skeleton.slots.length; i++) {\r\n                let slot = skeleton.slots[i];\r\n                let slotAttachment = slot.getAttachment();\r\n                if (slotAttachment && slotIndex < oldSkin.attachments.length) {\r\n                    let dictionary = oldSkin.attachments[slotIndex];\r\n                    for (let key in dictionary) {\r\n                        let skinAttachment:Attachment = dictionary[key];\r\n                        if (slotAttachment == skinAttachment) {\r\n                            let attachment = this.getAttachment(slotIndex, key);\r\n                            if (attachment != null) slot.setAttachment(attachment);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                slotIndex++;\r\n            }\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Slot {\n        //this is for PIXI\n        currentMesh: any;\n        currentSprite: any;\n        currentGraphics: any;\n        clippingContainer: any;\n\n        meshes: any;\n        currentMeshName: string;\n        sprites: any;\n        currentSpriteName: string;\n\n        blendMode: number;\n        //assign hack region a bit later\n        hackRegion: TextureRegion;\n        hackAttachment: Attachment;\n\n        //this is canon\n        data: SlotData;\n        bone: Bone;\n        color: Color;\n        darkColor: Color;\n        attachment: Attachment;\n        private attachmentTime: number;\n        attachmentState: number;\n        deform = new Array<number>();\n\n        constructor (data: SlotData, bone: Bone) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            if (bone == null) throw new Error(\"bone cannot be null.\");\n            this.data = data;\n            this.bone = bone;\n            this.color = new Color();\n            this.darkColor = data.darkColor == null ? null : new Color();\n            this.setToSetupPose();\n\n            this.blendMode = this.data.blendMode;\n        }\n\n        /** @return May be null. */\n        getAttachment (): Attachment {\n            return this.attachment;\n        }\n\n        /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\n         * @param attachment May be null. */\n        setAttachment (attachment: Attachment) {\n            if (this.attachment == attachment) return;\n            this.attachment = attachment;\n            this.attachmentTime = this.bone.skeleton.time;\n            this.deform.length = 0;\n        }\n\n        setAttachmentTime (time: number) {\n            this.attachmentTime = this.bone.skeleton.time - time;\n        }\n\n        /** Returns the time since the attachment was set. */\n        getAttachmentTime (): number {\n            return this.bone.skeleton.time - this.attachmentTime;\n        }\n\n        setToSetupPose () {\n            this.color.setFromColor(this.data.color);\n            if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\n            if (this.data.attachmentName == null)\n                this.attachment = null;\n            else {\n                this.attachment = null;\n                this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n            }\n        }\n    }\n}\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class SlotData {\r\n        index: number;\r\n        name: string;\r\n        boneData: BoneData;\r\n        color = new Color(1, 1, 1, 1);\r\n        darkColor: Color;\r\n        attachmentName: string;\r\n        blendMode: BlendMode;\r\n\r\n        constructor (index: number, name: string, boneData: BoneData) {\r\n            if (index < 0) throw new Error(\"index must be >= 0.\");\r\n            if (name == null) throw new Error(\"name cannot be null.\");\r\n            if (boneData == null) throw new Error(\"boneData cannot be null.\");\r\n            this.index = index;\r\n            this.name = name;\r\n            this.boneData = boneData;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export abstract class Texture {\r\n        protected _image: HTMLImageElement;\r\n\r\n        constructor (image: HTMLImageElement) {\r\n            this._image = image;\r\n        }\r\n\r\n        getImage (): HTMLImageElement {\r\n            return this._image;\r\n        }\r\n\r\n        abstract setFilters (minFilter: TextureFilter, magFilter: TextureFilter): void;\r\n        abstract setWraps (uWrap: TextureWrap, vWrap: TextureWrap): void;\r\n        abstract dispose (): void;\r\n\r\n\r\n        public static filterFromString (text: string): TextureFilter {\r\n            switch (text.toLowerCase()) {\r\n                case \"nearest\": return TextureFilter.Nearest;\r\n                case \"linear\": return TextureFilter.Linear;\r\n                case \"mipmap\": return TextureFilter.MipMap;\r\n                case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\r\n                case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\r\n                case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\r\n                case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\r\n                default: throw new Error(`Unknown texture filter ${text}`);\r\n            }\r\n        }\r\n\r\n        public static wrapFromString (text: string): TextureWrap {\r\n            switch (text.toLowerCase()) {\r\n                case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\r\n                case \"clamptoedge\": return TextureWrap.ClampToEdge;\r\n                case \"repeat\": return TextureWrap.Repeat;\r\n                default: throw new Error(`Unknown texture wrap ${text}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    export enum TextureFilter {\r\n        Nearest = 9728, // WebGLRenderingContext.NEAREST\r\n        Linear = 9729, // WebGLRenderingContext.LINEAR\r\n        MipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n        MipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\r\n        MipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\r\n        MipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\r\n        MipMapLinearLinear = 9987 // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\r\n    }\r\n\r\n    export enum TextureWrap {\r\n        MirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\r\n        ClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\r\n        Repeat = 10497 // WebGLRenderingContext.REPEAT\r\n    }\r\n\r\n    export class TextureRegion {\r\n        texture: PIXI.Texture;\r\n\r\n        //thats for overrides\r\n        size: PIXI.Rectangle = null;\r\n\r\n        get width(): number {\r\n            const tex = this.texture;\r\n            if (PIXI.VERSION[0] == '3') {\r\n                return (tex as any).crop.width;\r\n            }\r\n            if (tex.trim) {\r\n                return tex.trim.width;\r\n            }\r\n            return tex.orig.width;\r\n        }\r\n\r\n        get height(): number {\r\n            const tex = this.texture;\r\n            if (PIXI.VERSION[0] == '3') {\r\n                return (tex as any).crop.height;\r\n            }\r\n            if (tex.trim) {\r\n                return tex.trim.height;\r\n            }\r\n            return tex.orig.height;\r\n        }\r\n\r\n        get u(): number {\r\n            return (this.texture as any)._uvs.x0;\r\n        }\r\n\r\n        get v(): number {\r\n            return (this.texture as any)._uvs.y0;\r\n        }\r\n\r\n        get u2(): number {\r\n            return (this.texture as any)._uvs.x2;\r\n        }\r\n\r\n        get v2(): number {\r\n            return (this.texture as any)._uvs.y2;\r\n        }\r\n\r\n        get offsetX(): number {\r\n            const tex = this.texture;\r\n            return tex.trim ? tex.trim.x : 0;\r\n        }\r\n\r\n        get offsetY(): number {\r\n            console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\r\n            return this.spineOffsetY;\r\n        }\r\n\r\n        get pixiOffsetY(): number {\r\n            const tex = this.texture;\r\n            return tex.trim ? tex.trim.y : 0;\r\n        }\r\n\r\n        get spineOffsetY(): number {\r\n            let tex = this.texture;\r\n            return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\r\n        }\r\n\r\n        get originalWidth(): number {\r\n            let tex = this.texture;\r\n            if (PIXI.VERSION[0] == '3') {\r\n                if (tex.trim) {\r\n                    return tex.trim.width;\r\n                }\r\n                return (tex as any).crop.width;\r\n            }\r\n            return tex.orig.width;\r\n        }\r\n\r\n        get originalHeight(): number {\r\n            const tex = this.texture;\r\n            if (PIXI.VERSION[0] == '3') {\r\n                if (tex.trim) {\r\n                    return tex.trim.height;\r\n                }\r\n                return (tex as any).crop.height;\r\n            }\r\n            return tex.orig.height;\r\n        }\r\n\r\n        get x(): number {\r\n            return this.texture.frame.x;\r\n        }\r\n\r\n        get y(): number {\r\n            return this.texture.frame.y;\r\n        }\r\n\r\n        get rotate(): boolean {\r\n            return this.texture.rotate !== 0;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class TextureAtlas implements Disposable {\r\n        pages = new Array<TextureAtlasPage>();\r\n        regions = new Array<TextureAtlasRegion>();\r\n\r\n        constructor(atlasText?: string, textureLoader?: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback?: (obj: TextureAtlas) => any) {\r\n            if (atlasText) {\r\n                this.addSpineAtlas(atlasText, textureLoader, callback);\r\n            }\r\n        }\r\n\r\n        addTexture(name: string, texture: PIXI.Texture) {\r\n            let pages = this.pages;\r\n            let page: TextureAtlasPage = null;\r\n            for (let i = 0; i < pages.length; i++) {\r\n                if (pages[i].baseTexture === texture.baseTexture) {\r\n                    page = pages[i];\r\n                    break;\r\n                }\r\n            }\r\n            if (page === null) {\r\n                page = new TextureAtlasPage();\r\n                page.name = 'texturePage';\r\n                let baseTexture = texture.baseTexture;\r\n                page.width = baseTexture.realWidth;\r\n                page.height = baseTexture.realHeight;\r\n                page.baseTexture = baseTexture;\r\n                //those fields are not relevant in Pixi\r\n                page.minFilter = page.magFilter = TextureFilter.Nearest;\r\n                page.uWrap = TextureWrap.ClampToEdge;\r\n                page.vWrap = TextureWrap.ClampToEdge;\r\n                pages.push(page);\r\n            }\r\n            let region = new TextureAtlasRegion();\r\n            region.name = name;\r\n            region.page = page;\r\n            region.texture = texture;\r\n            region.index = -1;\r\n            this.regions.push(region);\r\n            return region;\r\n        }\r\n\r\n        addTextureHash(textures: Map<PIXI.Texture>, stripExtension: boolean) {\r\n            for (let key in textures) {\r\n                if (textures.hasOwnProperty(key)) {\r\n                    this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n                }\r\n            }\r\n        }\r\n\r\n        public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture)  => any) => any, callback: (obj: TextureAtlas) => any) {\r\n            return this.load(atlasText, textureLoader, callback);\r\n        }\r\n\r\n        private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\r\n            if (textureLoader == null)\r\n                throw new Error(\"textureLoader cannot be null.\");\r\n\r\n            let reader = new TextureAtlasReader(atlasText);\r\n            let tuple = new Array<string>(4);\r\n            let page: TextureAtlasPage = null;\r\n\r\n            let iterateParser = () => {\r\n                while (true) {\r\n                    let line = reader.readLine();\r\n                    if (line == null) {\r\n                        return callback && callback(this);\r\n                    }\r\n                    line = line.trim();\r\n                    if (line.length == 0)\r\n                        page = null;\r\n                    else if (!page) {\r\n                        page = new TextureAtlasPage();\r\n                        page.name = line;\r\n\r\n                        if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\r\n                            page.width = parseInt(tuple[0]);\r\n                            page.height = parseInt(tuple[1]);\r\n                            reader.readTuple(tuple);\r\n                        }\r\n                        // page.format = Format[tuple[0]]; we don't need format in WebGL\r\n\r\n                        reader.readTuple(tuple);\r\n                        page.minFilter = Texture.filterFromString(tuple[0]);\r\n                        page.magFilter = Texture.filterFromString(tuple[1]);\r\n\r\n                        let direction = reader.readValue();\r\n                        page.uWrap = TextureWrap.ClampToEdge;\r\n                        page.vWrap = TextureWrap.ClampToEdge;\r\n                        if (direction == \"x\")\r\n                            page.uWrap = TextureWrap.Repeat;\r\n                        else if (direction == \"y\")\r\n                            page.vWrap = TextureWrap.Repeat;\r\n                        else if (direction == \"xy\")\r\n                            page.uWrap = page.vWrap = TextureWrap.Repeat;\r\n\r\n                        textureLoader(line, (texture: PIXI.BaseTexture) => {\r\n                            if (texture === null) {\r\n                                this.pages.splice(this.pages.indexOf(page), 1);\r\n                                return callback && callback(null);\r\n                            }\r\n                            page.baseTexture = texture;\r\n                            if (!texture.valid) {\r\n                                texture.setSize(page.width, page.height);\r\n                            }\r\n                            this.pages.push(page);\r\n                            page.setFilters();\r\n\r\n                            if (!page.width || !page.height) {\r\n                                page.width = texture.realWidth;\r\n                                page.height = texture.realHeight;\r\n                                if (!page.width || !page.height) {\r\n                                    console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                                }\r\n                            }\r\n                            iterateParser();\r\n                        });\r\n                        this.pages.push(page);\r\n                        break;\r\n                    } else {\r\n                        let region: TextureAtlasRegion = new TextureAtlasRegion();\r\n                        region.name = line;\r\n                        region.page = page;\r\n\r\n                        let rotateValue = reader.readValue();\r\n                        let rotate = 0;\r\n                        if (rotateValue.toLocaleLowerCase() == \"true\") {\r\n                            rotate = 6;\r\n                        } else if (rotateValue.toLocaleLowerCase() == \"false\") {\r\n                            rotate = 0;\r\n                        } else {\r\n                            rotate = ((720 - parseFloat(rotateValue))% 360) / 45;\r\n                        }\r\n\r\n                        reader.readTuple(tuple);\r\n                        let x = parseInt(tuple[0]);\r\n                        let y = parseInt(tuple[1]);\r\n\r\n                        reader.readTuple(tuple);\r\n                        let width = parseInt(tuple[0]);\r\n                        let height = parseInt(tuple[1]);\r\n\r\n                        let resolution = page.baseTexture.resolution;\r\n                        x /= resolution;\r\n                        y /= resolution;\r\n                        width /= resolution;\r\n                        height /= resolution;\r\n\r\n                        const swapWH = rotate % 4 != 0;\r\n                        let frame = new PIXI.Rectangle(x, y, swapWH ? height : width, swapWH ? width : height);\r\n\r\n                        if (reader.readTuple(tuple) == 4) { // split is optional\r\n                            // region.splits = new Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\r\n\r\n                            if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\r\n                                //region.pads = Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\r\n\r\n                                reader.readTuple(tuple);\r\n                            }\r\n                        }\r\n\r\n                        let originalWidth = parseInt(tuple[0]) / resolution;\r\n                        let originalHeight = parseInt(tuple[1]) / resolution;\r\n                        reader.readTuple(tuple);\r\n                        let offsetX = parseInt(tuple[0]) / resolution;\r\n                        let offsetY = parseInt(tuple[1]) / resolution;\r\n\r\n                        let orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\r\n                        let trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\r\n\r\n                        //TODO: pixiv3 uses different frame/crop/trim\r\n\r\n                        if (PIXI.VERSION[0] != '3') {\r\n                            // pixi v4 or v5\r\n                            region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);\r\n                        } else {\r\n                            // pixi v3.0.11\r\n                            let frame2 = new PIXI.Rectangle(x, y, width, height);\r\n                            let crop = frame2.clone();\r\n                            trim.width = originalWidth;\r\n                            trim.height = originalHeight;\r\n                            region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate);\r\n                        }\r\n\r\n                        region.index = parseInt(reader.readValue());\r\n                        region.texture.updateUvs();\r\n\r\n                        this.regions.push(region);\r\n                    }\r\n                }\r\n            };\r\n\r\n            iterateParser();\r\n        }\r\n\r\n        findRegion(name: string): TextureAtlasRegion {\r\n            for (let i = 0; i < this.regions.length; i++) {\r\n                if (this.regions[i].name == name) {\r\n                    return this.regions[i];\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        dispose() {\r\n            for (let i = 0; i < this.pages.length; i++) {\r\n                this.pages[i].baseTexture.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    class TextureAtlasReader {\r\n        lines: Array<string>;\r\n        index: number = 0;\r\n\r\n        constructor(text: string) {\r\n            this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n        }\r\n\r\n        readLine(): string {\r\n            if (this.index >= this.lines.length)\r\n                return null;\r\n            return this.lines[this.index++];\r\n        }\r\n\r\n        readValue(): string {\r\n            let line = this.readLine();\r\n            let colon = line.indexOf(\":\");\r\n            if (colon == -1)\r\n                throw new Error(\"Invalid line: \" + line);\r\n            return line.substring(colon + 1).trim();\r\n        }\r\n\r\n        readTuple(tuple: Array<string>): number {\r\n            let line = this.readLine();\r\n            let colon = line.indexOf(\":\");\r\n            if (colon == -1)\r\n                throw new Error(\"Invalid line: \" + line);\r\n            let i = 0, lastMatch = colon + 1;\r\n            for (; i < 3; i++) {\r\n                let comma = line.indexOf(\",\", lastMatch);\r\n                if (comma == -1) break;\r\n                tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\r\n                lastMatch = comma + 1;\r\n            }\r\n            tuple[i] = line.substring(lastMatch).trim();\r\n            return i + 1;\r\n        }\r\n    }\r\n\r\n    export class TextureAtlasPage {\r\n        name: string;\r\n        minFilter: TextureFilter;\r\n        magFilter: TextureFilter;\r\n        uWrap: TextureWrap;\r\n        vWrap: TextureWrap;\r\n        baseTexture: PIXI.BaseTexture;\r\n        width: number;\r\n        height: number;\r\n\r\n        public setFilters() {\r\n            let tex = this.baseTexture;\r\n            let filter = this.minFilter;\r\n            if (filter == TextureFilter.Linear) {\r\n                tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\r\n            } else if (this.minFilter == TextureFilter.Nearest) {\r\n                tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\r\n            } else {\r\n                tex.mipmap = PIXI.MIPMAP_MODES.POW2;\r\n                if (filter == TextureFilter.MipMapNearestNearest) {\r\n                    tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\r\n                } else {\r\n                    tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    export class TextureAtlasRegion extends TextureRegion {\r\n        page: TextureAtlasPage;\r\n        name: string;\r\n        index: number;\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class TransformConstraint implements Updatable {\r\n        data: TransformConstraintData;\r\n        bones: Array<Bone>;\r\n        target: Bone;\r\n        rotateMix = 0;\r\n        translateMix = 0;\r\n        scaleMix = 0;\r\n        shearMix = 0;\r\n        temp = new Vector2();\r\n        active = false;\r\n\r\n        constructor(data: TransformConstraintData, skeleton: Skeleton) {\r\n            if (data == null) throw new Error(\"data cannot be null.\");\r\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\r\n            this.data = data;\r\n            this.rotateMix = data.rotateMix;\r\n            this.translateMix = data.translateMix;\r\n            this.scaleMix = data.scaleMix;\r\n            this.shearMix = data.shearMix;\r\n            this.bones = new Array<Bone>();\r\n            for (let i = 0; i < data.bones.length; i++)\r\n                this.bones.push(skeleton.findBone(data.bones[i].name));\r\n            this.target = skeleton.findBone(data.target.name);\r\n        }\r\n\r\n        isActive () {\r\n            return this.active;\r\n        }\r\n\r\n        apply() {\r\n            this.update();\r\n        }\r\n\r\n        update() {\r\n            if (this.data.local) {\r\n                if (this.data.relative)\r\n                    this.applyRelativeLocal();\r\n                else\r\n                    this.applyAbsoluteLocal();\r\n\r\n            } else {\r\n                if (this.data.relative)\r\n                    this.applyRelativeWorld();\r\n                else\r\n                    this.applyAbsoluteWorld();\r\n            }\r\n        }\r\n\r\n        applyAbsoluteWorld() {\r\n            let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\r\n                shearMix = this.shearMix;\r\n            let target = this.target;\r\n            let targetMat = target.matrix;\r\n            let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\r\n            let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n            let offsetRotation = this.data.offsetRotation * degRadReflect;\r\n            let offsetShearY = this.data.offsetShearY * degRadReflect;\r\n            let bones = this.bones;\r\n            for (let i = 0, n = bones.length; i < n; i++) {\r\n                let bone = bones[i];\r\n                let modified = false;\r\n                let mat = bone.matrix;\r\n\r\n                if (rotateMix != 0) {\r\n                    let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                    let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\r\n                    if (r > MathUtils.PI)\r\n                        r -= MathUtils.PI2;\r\n                    else if (r < -MathUtils.PI)\r\n                        r += MathUtils.PI2;\r\n                    r *= rotateMix;\r\n                    let cos = Math.cos(r), sin = Math.sin(r);\r\n                    mat.a = cos * a - sin * c;\r\n                    mat.c = cos * b - sin * d;\r\n                    mat.b = sin * a + cos * c;\r\n                    mat.d = sin * b + cos * d;\r\n                    modified = true;\r\n                }\r\n\r\n                if (translateMix != 0) {\r\n                    let temp = this.temp;\r\n                    target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                    mat.tx += (temp.x - mat.tx) * translateMix;\r\n                    mat.ty += (temp.y - mat.ty) * translateMix;\r\n                    modified = true;\r\n                }\r\n\r\n                if (scaleMix > 0) {\r\n                    let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\r\n                    let ts = Math.sqrt(ta * ta + tc * tc);\r\n                    if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\r\n                    mat.a *= s;\r\n                    mat.b *= s;\r\n                    s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\r\n                    ts = Math.sqrt(tb * tb + td * td);\r\n                    if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\r\n                    mat.c *= s;\r\n                    mat.d *= s;\r\n                    modified = true;\r\n                }\r\n\r\n                if (shearMix > 0) {\r\n                    let b = mat.c, d = mat.d;\r\n                    let by = Math.atan2(d, b);\r\n                    let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\r\n                    if (r > MathUtils.PI)\r\n                        r -= MathUtils.PI2;\r\n                    else if (r < -MathUtils.PI)\r\n                        r += MathUtils.PI2;\r\n                    r = by + (r + offsetShearY) * shearMix;\r\n                    let s = Math.sqrt(b * b + d * d);\r\n                    mat.c = Math.cos(r) * s;\r\n                    mat.d = Math.sin(r) * s;\r\n                    modified = true;\r\n                }\r\n\r\n                if (modified) bone.appliedValid = false;\r\n            }\r\n        }\r\n\r\n        applyRelativeWorld() {\r\n            let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\r\n                shearMix = this.shearMix;\r\n            let target = this.target;\r\n            let targetMat = target.matrix;\r\n            let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\r\n            let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\r\n            let offsetRotation = this.data.offsetRotation * degRadReflect,\r\n                offsetShearY = this.data.offsetShearY * degRadReflect;\r\n            let bones = this.bones;\r\n            for (let i = 0, n = bones.length; i < n; i++) {\r\n                let bone = bones[i];\r\n                let modified = false;\r\n                let mat = bone.matrix;\r\n\r\n                if (rotateMix != 0) {\r\n                    let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                    let r = Math.atan2(tc, ta) + offsetRotation;\r\n                    if (r > MathUtils.PI)\r\n                        r -= MathUtils.PI2;\r\n                    else if (r < -MathUtils.PI) r += MathUtils.PI2;\r\n                    r *= rotateMix;\r\n                    let cos = Math.cos(r), sin = Math.sin(r);\r\n                    mat.a = cos * a - sin * c;\r\n                    mat.c = cos * b - sin * d;\r\n                    mat.b = sin * a + cos * c;\r\n                    mat.d = sin * b + cos * d;\r\n                    modified = true;\r\n                }\r\n\r\n                if (translateMix != 0) {\r\n                    let temp = this.temp;\r\n                    target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\r\n                    mat.tx += temp.x * translateMix;\r\n                    mat.ty += temp.y * translateMix;\r\n                    modified = true;\r\n                }\r\n\r\n                if (scaleMix > 0) {\r\n                    let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\r\n                    mat.a *= s;\r\n                    mat.b *= s;\r\n                    s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\r\n                    mat.c *= s;\r\n                    mat.d *= s;\r\n                    modified = true;\r\n                }\r\n\r\n                if (shearMix > 0) {\r\n                    let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\r\n                    if (r > MathUtils.PI)\r\n                        r -= MathUtils.PI2;\r\n                    else if (r < -MathUtils.PI) r += MathUtils.PI2;\r\n                    let b = mat.c, d = mat.d;\r\n                    r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\r\n                    let s = Math.sqrt(b * b + d * d);\r\n                    mat.c = Math.cos(r) * s;\r\n                    mat.d = Math.sin(r) * s;\r\n                    modified = true;\r\n                }\r\n\r\n                if (modified) bone.appliedValid = false;\r\n            }\r\n        }\r\n\r\n        applyAbsoluteLocal() {\r\n            let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\r\n                shearMix = this.shearMix;\r\n            let target = this.target;\r\n            if (!target.appliedValid) target.updateAppliedTransform();\r\n            let bones = this.bones;\r\n            for (let i = 0, n = bones.length; i < n; i++) {\r\n                let bone = bones[i];\r\n                if (!bone.appliedValid) bone.updateAppliedTransform();\r\n\r\n                let rotation = bone.arotation;\r\n                if (rotateMix != 0) {\r\n                    let r = target.arotation - rotation + this.data.offsetRotation;\r\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                    rotation += r * rotateMix;\r\n                }\r\n\r\n                let x = bone.ax, y = bone.ay;\r\n                if (translateMix != 0) {\r\n                    x += (target.ax - x + this.data.offsetX) * translateMix;\r\n                    y += (target.ay - y + this.data.offsetY) * translateMix;\r\n                }\r\n\r\n                let scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n                if (scaleMix > 0) {\r\n                    if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\r\n                    if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\r\n                }\r\n\r\n                let shearY = bone.ashearY;\r\n                if (shearMix > 0) {\r\n                    let r = target.ashearY - shearY + this.data.offsetShearY;\r\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\r\n                    bone.shearY += r * shearMix;\r\n                }\r\n\r\n                bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n            }\r\n        }\r\n\r\n        applyRelativeLocal() {\r\n            let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\r\n                shearMix = this.shearMix;\r\n            let target = this.target;\r\n            if (!target.appliedValid) target.updateAppliedTransform();\r\n            let bones = this.bones;\r\n            for (let i = 0, n = bones.length; i < n; i++) {\r\n                let bone = bones[i];\r\n                if (!bone.appliedValid) bone.updateAppliedTransform();\r\n\r\n                let rotation = bone.arotation;\r\n                if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\r\n\r\n                let x = bone.ax, y = bone.ay;\r\n                if (translateMix != 0) {\r\n                    x += (target.ax + this.data.offsetX) * translateMix;\r\n                    y += (target.ay + this.data.offsetY) * translateMix;\r\n                }\r\n\r\n                let scaleX = bone.ascaleX, scaleY = bone.ascaleY;\r\n                if (scaleMix > 0) {\r\n                    if (scaleX > 0.00001) scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\r\n                    if (scaleY > 0.00001) scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\r\n                }\r\n\r\n                let shearY = bone.ashearY;\r\n                if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\r\n\r\n                bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class TransformConstraintData extends ConstraintData {\r\n        bones = new Array<BoneData>();\r\n        target: BoneData;\r\n        rotateMix = 0; translateMix = 0; scaleMix = 0; shearMix = 0;\r\n        offsetRotation = 0; offsetX = 0; offsetY = 0; offsetScaleX = 0; offsetScaleY = 0; offsetShearY = 0;\r\n        relative = false;\r\n        local = false;\r\n\r\n        constructor (name: string) {\r\n            super(name, 0, false);\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License v2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n\texport class Triangulator {\r\n\t\tprivate convexPolygons = new Array<Array<number>>();\r\n\t\tprivate convexPolygonsIndices = new Array<Array<number>>();\r\n\r\n\t\tprivate indicesArray = new Array<number>();\r\n\t\tprivate isConcaveArray = new Array<boolean>();\r\n\t\tprivate triangles = new Array<number>();\r\n\r\n\t\tprivate polygonPool = new Pool<Array<number>>(() => {\r\n\t\t\treturn new Array<number>();\r\n\t\t});\r\n\r\n\t\tprivate polygonIndicesPool = new Pool<Array<number>>(() => {\r\n\t\t\treturn new Array<number>();\r\n\t\t});\r\n\r\n\t\tpublic triangulate (verticesArray: ArrayLike<number>): Array<number> {\r\n\t\t\tlet vertices = verticesArray;\r\n\t\t\tlet vertexCount = verticesArray.length >> 1;\r\n\r\n\t\t\tlet indices = this.indicesArray;\r\n\t\t\tindices.length = 0;\r\n\t\t\tfor (let i = 0; i < vertexCount; i++)\r\n\t\t\t\tindices[i] = i;\r\n\r\n\t\t\tlet isConcave = this.isConcaveArray;\r\n\t\t\tisConcave.length = 0;\r\n\t\t\tfor (let i = 0, n = vertexCount; i < n; ++i)\r\n\t\t\t\tisConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\r\n\r\n\t\t\tlet triangles = this.triangles;\r\n\t\t\ttriangles.length = 0;\r\n\r\n\t\t\twhile (vertexCount > 3) {\r\n\t\t\t\t// Find ear tip.\r\n\t\t\t\tlet previous = vertexCount - 1, i = 0, next = 1;\r\n\t\t\t\twhile (true) {\r\n\t\t\t\t\touter:\r\n\t\t\t\t\tif (!isConcave[i]) {\r\n\t\t\t\t\t\tlet p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;\r\n\t\t\t\t\t\tlet p1x = vertices[p1], p1y = vertices[p1 + 1];\r\n\t\t\t\t\t\tlet p2x = vertices[p2], p2y = vertices[p2 + 1];\r\n\t\t\t\t\t\tlet p3x = vertices[p3], p3y = vertices[p3 + 1];\r\n\t\t\t\t\t\tfor (let ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\r\n\t\t\t\t\t\t\tif (!isConcave[ii]) continue;\r\n\t\t\t\t\t\t\tlet v = indices[ii] << 1;\r\n\t\t\t\t\t\t\tlet vx = vertices[v], vy = vertices[v + 1];\r\n\t\t\t\t\t\t\tif (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\r\n\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\r\n\t\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy)) break outer;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (next == 0) {\r\n\t\t\t\t\t\tdo {\r\n\t\t\t\t\t\t\tif (!isConcave[i]) break;\r\n\t\t\t\t\t\t\ti--;\r\n\t\t\t\t\t\t} while (i > 0);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tprevious = i;\r\n\t\t\t\t\ti = next;\r\n\t\t\t\t\tnext = (next + 1) % vertexCount;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Cut ear tip.\r\n\t\t\t\ttriangles.push(indices[(vertexCount + i - 1) % vertexCount]);\r\n\t\t\t\ttriangles.push(indices[i]);\r\n\t\t\t\ttriangles.push(indices[(i + 1) % vertexCount]);\r\n\t\t\t\tindices.splice(i, 1);\r\n\t\t\t\tisConcave.splice(i, 1);\r\n\t\t\t\tvertexCount--;\r\n\r\n\t\t\t\tlet previousIndex = (vertexCount + i - 1) % vertexCount;\r\n\t\t\t\tlet nextIndex = i == vertexCount ? 0 : i;\r\n\t\t\t\tisConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\r\n\t\t\t\tisConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\r\n\t\t\t}\r\n\r\n\t\t\tif (vertexCount == 3) {\r\n\t\t\t\ttriangles.push(indices[2]);\r\n\t\t\t\ttriangles.push(indices[0]);\r\n\t\t\t\ttriangles.push(indices[1]);\r\n\t\t\t}\r\n\r\n\t\t\treturn triangles;\r\n\t\t}\r\n\r\n\t\tdecompose (verticesArray: Array<number>, triangles: Array<number>) : Array<Array<number>> {\r\n\t\t\tlet vertices = verticesArray;\r\n\t\t\tlet convexPolygons = this.convexPolygons;\r\n\t\t\tthis.polygonPool.freeAll(convexPolygons);\r\n\t\t\tconvexPolygons.length = 0;\r\n\r\n\t\t\tlet convexPolygonsIndices = this.convexPolygonsIndices;\r\n\t\t\tthis.polygonIndicesPool.freeAll(convexPolygonsIndices);\r\n\t\t\tconvexPolygonsIndices.length = 0;\r\n\r\n\t\t\tlet polygonIndices = this.polygonIndicesPool.obtain();\r\n\t\t\tpolygonIndices.length = 0;\r\n\r\n\t\t\tlet polygon = this.polygonPool.obtain();\r\n\t\t\tpolygon.length = 0;\r\n\r\n\t\t\t// Merge subsequent triangles if they form a triangle fan.\r\n\t\t\tlet fanBaseIndex = -1, lastWinding = 0;\r\n\t\t\tfor (let i = 0, n = triangles.length; i < n; i += 3) {\r\n\t\t\t\tlet t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;\r\n\t\t\t\tlet x1 = vertices[t1], y1 = vertices[t1 + 1];\r\n\t\t\t\tlet x2 = vertices[t2], y2 = vertices[t2 + 1];\r\n\t\t\t\tlet x3 = vertices[t3], y3 = vertices[t3 + 1];\r\n\r\n\t\t\t\t// If the base of the last triangle is the same as this triangle, check if they form a convex polygon (triangle fan).\r\n\t\t\t\tlet merged = false;\r\n\t\t\t\tif (fanBaseIndex == t1) {\r\n\t\t\t\t\tlet o = polygon.length - 4;\r\n\t\t\t\t\tlet winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\r\n\t\t\t\t\tlet winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\r\n\t\t\t\t\tif (winding1 == lastWinding && winding2 == lastWinding) {\r\n\t\t\t\t\t\tpolygon.push(x3);\r\n\t\t\t\t\t\tpolygon.push(y3);\r\n\t\t\t\t\t\tpolygonIndices.push(t3);\r\n\t\t\t\t\t\tmerged = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Otherwise make this triangle the new base.\r\n\t\t\t\tif (!merged) {\r\n\t\t\t\t\tif (polygon.length > 0) {\r\n\t\t\t\t\t\tconvexPolygons.push(polygon);\r\n\t\t\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.polygonPool.free(polygon)\r\n\t\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpolygon = this.polygonPool.obtain();\r\n\t\t\t\t\tpolygon.length = 0;\r\n\t\t\t\t\tpolygon.push(x1);\r\n\t\t\t\t\tpolygon.push(y1);\r\n\t\t\t\t\tpolygon.push(x2);\r\n\t\t\t\t\tpolygon.push(y2);\r\n\t\t\t\t\tpolygon.push(x3);\r\n\t\t\t\t\tpolygon.push(y3);\r\n\t\t\t\t\tpolygonIndices = this.polygonIndicesPool.obtain();\r\n\t\t\t\t\tpolygonIndices.length = 0;\r\n\t\t\t\t\tpolygonIndices.push(t1);\r\n\t\t\t\t\tpolygonIndices.push(t2);\r\n\t\t\t\t\tpolygonIndices.push(t3);\r\n\t\t\t\t\tlastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\r\n\t\t\t\t\tfanBaseIndex = t1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (polygon.length > 0) {\r\n\t\t\t\tconvexPolygons.push(polygon);\r\n\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\r\n\t\t\t}\r\n\r\n\t\t\t// Go through the list of polygons and try to merge the remaining triangles with the found triangle fans.\r\n\t\t\tfor (let i = 0, n = convexPolygons.length; i < n; i++) {\r\n\t\t\t\tpolygonIndices = convexPolygonsIndices[i];\r\n\t\t\t\tif (polygonIndices.length == 0) continue;\r\n\t\t\t\tlet firstIndex = polygonIndices[0];\r\n\t\t\t\tlet lastIndex = polygonIndices[polygonIndices.length - 1];\r\n\r\n\t\t\t\tpolygon = convexPolygons[i];\r\n\t\t\t\tlet o = polygon.length - 4;\r\n\t\t\t\tlet prevPrevX = polygon[o], prevPrevY = polygon[o + 1];\r\n\t\t\t\tlet prevX = polygon[o + 2], prevY = polygon[o + 3];\r\n\t\t\t\tlet firstX = polygon[0], firstY = polygon[1];\r\n\t\t\t\tlet secondX = polygon[2], secondY = polygon[3];\r\n\t\t\t\tlet winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\r\n\r\n\t\t\t\tfor (let ii = 0; ii < n; ii++) {\r\n\t\t\t\t\tif (ii == i) continue;\r\n\t\t\t\t\tlet otherIndices = convexPolygonsIndices[ii];\r\n\t\t\t\t\tif (otherIndices.length != 3) continue;\r\n\t\t\t\t\tlet otherFirstIndex = otherIndices[0];\r\n\t\t\t\t\tlet otherSecondIndex = otherIndices[1];\r\n\t\t\t\t\tlet otherLastIndex = otherIndices[2];\r\n\r\n\t\t\t\t\tlet otherPoly = convexPolygons[ii];\r\n\t\t\t\t\tlet x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];\r\n\r\n\t\t\t\t\tif (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex) continue;\r\n\t\t\t\t\tlet winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\r\n\t\t\t\t\tlet winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\r\n\t\t\t\t\tif (winding1 == winding && winding2 == winding) {\r\n\t\t\t\t\t\totherPoly.length = 0;\r\n\t\t\t\t\t\totherIndices.length = 0;\r\n\t\t\t\t\t\tpolygon.push(x3);\r\n\t\t\t\t\t\tpolygon.push(y3);\r\n\t\t\t\t\t\tpolygonIndices.push(otherLastIndex);\r\n\t\t\t\t\t\tprevPrevX = prevX;\r\n\t\t\t\t\t\tprevPrevY = prevY;\r\n\t\t\t\t\t\tprevX = x3;\r\n\t\t\t\t\t\tprevY = y3;\r\n\t\t\t\t\t\tii = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Remove empty polygons that resulted from the merge step above.\r\n\t\t\tfor (let i = convexPolygons.length - 1; i >= 0; i--) {\r\n\t\t\t\tpolygon = convexPolygons[i];\r\n\t\t\t\tif (polygon.length == 0) {\r\n\t\t\t\t\tconvexPolygons.splice(i, 1);\r\n\t\t\t\t\tthis.polygonPool.free(polygon);\r\n\t\t\t\t\tpolygonIndices = convexPolygonsIndices[i]\r\n\t\t\t\t\tconvexPolygonsIndices.splice(i, 1)\r\n\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn convexPolygons;\r\n\t\t}\r\n\r\n\t\tprivate static isConcave (index: number, vertexCount: number, vertices: ArrayLike<number>, indices: ArrayLike<number>): boolean {\r\n\t\t\tlet previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\r\n\t\t\tlet current = indices[index] << 1;\r\n\t\t\tlet next = indices[(index + 1) % vertexCount] << 1;\r\n\t\t\treturn !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next],\r\n\t\t\t\tvertices[next + 1]);\r\n\t\t}\r\n\r\n\t\tprivate static positiveArea (p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): boolean {\r\n\t\t\treturn p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\r\n\t\t}\r\n\r\n\t\tprivate static winding (p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): number {\r\n\t\t\tlet px = p2x - p1x, py = p2y - p1y;\r\n\t\t\treturn p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\r\n\t\t}\r\n\t}\r\n}\r\n","/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export interface Map<T> {\n        [key: string]: T;\n    }\n\n    export class IntSet {\n        array = new Array<number>();\n\n        add (value: number): boolean {\n            let contains = this.contains(value);\n            this.array[value | 0] = value | 0;\n            return !contains;\n        }\n\n        contains (value: number) {\n            return this.array[value | 0] != undefined;\n        }\n\n        remove (value: number) {\n            this.array[value | 0] = undefined;\n        }\n\n        clear () {\n            this.array.length = 0;\n        }\n    }\n\n    export interface Disposable {\n        dispose (): void;\n    }\n\n    export interface Restorable {\n        restore (): void;\n    }\n\n    export class Color {\n        public static WHITE = new Color(1, 1, 1, 1);\n        public static RED = new Color(1, 0, 0, 1);\n        public static GREEN = new Color(0, 1, 0, 1);\n        public static BLUE = new Color(0, 0, 1, 1);\n        public static MAGENTA = new Color(1, 0, 1, 1);\n\n        constructor (public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {\n        }\n\n        set (r: number, g: number, b: number, a: number) {\n            this.r = r;\n            this.g = g;\n            this.b = b;\n            this.a = a;\n            this.clamp();\n            return this;\n        }\n\n        setFromColor (c: Color) {\n            this.r = c.r;\n            this.g = c.g;\n            this.b = c.b;\n            this.a = c.a;\n            return this;\n        }\n\n        setFromString (hex: string) {\n            hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n            this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\n            this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\n            this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\n            this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\n            return this;\n        }\n\n        add (r: number, g: number, b: number, a: number) {\n            this.r += r;\n            this.g += g;\n            this.b += b;\n            this.a += a;\n            this.clamp();\n            return this;\n        }\n\n        clamp () {\n            if (this.r < 0) this.r = 0;\n            else if (this.r > 1) this.r = 1;\n\n            if (this.g < 0) this.g = 0;\n            else if (this.g > 1) this.g = 1;\n\n            if (this.b < 0) this.b = 0;\n            else if (this.b > 1) this.b = 1;\n\n            if (this.a < 0) this.a = 0;\n            else if (this.a > 1) this.a = 1;\n            return this;\n        }\n\n        static rgba8888ToColor(color: Color, value: number) {\n            color.r = ((value & 0xff000000) >>> 24) / 255;\n            color.g = ((value & 0x00ff0000) >>> 16) / 255;\n            color.b = ((value & 0x0000ff00) >>> 8) / 255;\n            color.a = ((value & 0x000000ff)) / 255;\n        }\n\n        static rgb888ToColor (color: Color, value: number) {\n            color.r = ((value & 0x00ff0000) >>> 16) / 255;\n            color.g = ((value & 0x0000ff00) >>> 8) / 255;\n            color.b = ((value & 0x000000ff)) / 255;\n        }\n    }\n\n    export class MathUtils {\n        static PI = 3.1415927;\n        static PI2 = MathUtils.PI * 2;\n        static radiansToDegrees = 180 / MathUtils.PI;\n        static radDeg = MathUtils.radiansToDegrees;\n        static degreesToRadians = MathUtils.PI / 180;\n        static degRad = MathUtils.degreesToRadians;\n\n        static clamp (value: number, min: number, max: number) {\n            if (value < min) return min;\n            if (value > max) return max;\n            return value;\n        }\n\n        static cosDeg (degrees: number) {\n            return Math.cos(degrees * MathUtils.degRad);\n        }\n\n        static sinDeg (degrees: number) {\n            return Math.sin(degrees * MathUtils.degRad);\n        }\n\n        static signum (value: number): number {\n            return value > 0 ? 1 : value < 0 ? -1 : 0;\n        }\n\n        static toInt (x: number) {\n            return x > 0 ? Math.floor(x) : Math.ceil(x);\n        }\n\n        static cbrt (x: number) {\n            let y = Math.pow(Math.abs(x), 1/3);\n            return x < 0 ? -y : y;\n        }\n\n        static randomTriangular (min: number, max: number): number {\n            return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n        }\n\n        static randomTriangularWith (min: number, max: number, mode: number): number {\n            let u = Math.random();\n            let d = max - min;\n            if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\n            return max - Math.sqrt((1 - u) * d * (max - mode));\n        }\n    }\n\n    export abstract class Interpolation {\n        protected abstract applyInternal (a: number): number;\n        apply(start: number, end: number, a: number): number {\n            return start + (end - start) * this.applyInternal(a);\n        }\n    }\n\n    export class Pow extends Interpolation {\n        protected power = 2;\n\n        constructor (power: number) {\n            super();\n            this.power = power;\n        }\n\n        applyInternal (a: number): number {\n            if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\n            return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n        }\n    }\n\n    export class PowOut extends Pow {\n        constructor (power: number) {\n            super(power);\n        }\n\n        applyInternal (a: number) : number {\n            return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n        }\n    }\n\n    export class Utils {\n        static SUPPORTS_TYPED_ARRAYS = typeof(Float32Array) !== \"undefined\";\n\n        static arrayCopy<T> (source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\n            for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n                dest[j] = source[i];\n            }\n        }\n\n        static setArraySize<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\n            let oldSize = array.length;\n            if (oldSize == size) return array;\n            array.length = size;\n            if (oldSize < size) {\n                for (let i = oldSize; i < size; i++) array[i] = value;\n            }\n            return array;\n        }\n\n        static ensureArrayCapacity<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\n            if (array.length >= size) return array;\n            return Utils.setArraySize(array, size, value);\n        }\n\n        static newArray<T> (size: number, defaultValue: T): Array<T> {\n            let array = new Array<T>(size);\n            for (let i = 0; i < size; i++) array[i] = defaultValue;\n            return array;\n        }\n\n        static newFloatArray (size: number): ArrayLike<number> {\n            if (Utils.SUPPORTS_TYPED_ARRAYS) {\n                return new Float32Array(size)\n            } else {\n                let array = new Array<number>(size);\n                for (let i = 0; i < array.length; i++) array[i] = 0;\n                return array;\n            }\n        }\n\n        static newShortArray (size: number): ArrayLike<number> {\n            if (Utils.SUPPORTS_TYPED_ARRAYS) {\n                return new Int16Array(size)\n            } else {\n                let array = new Array<number>(size);\n                for (let i = 0; i < array.length; i++) array[i] = 0;\n                return array;\n            }\n        }\n\n        static toFloatArray (array: Array<number>) {\n            return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n        }\n\n        static toSinglePrecision (value: number) {\n            return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\n        }\n\n        // This function is used to fix WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n        static webkit602BugfixHelper (alpha: number, blend: MixBlend) {\n\n        }\n\n        static contains<T> (array: Array<T>, element: T, identity = true) {\n            for (let i = 0; i < array.length; i++) {\n                if (array[i] == element) return true;\n            }\n            return false;\n        }\n    }\n\n    export class DebugUtils {\n        static logBones(skeleton: Skeleton) {\n            for (let i = 0; i < skeleton.bones.length; i++) {\n                let bone = skeleton.bones[i];\n                let mat = bone.matrix;\n                console.log(bone.data.name + \", \" + mat.a + \", \" + mat.b + \", \" + mat.c + \", \" + mat.d + \", \" + mat.tx + \", \" + mat.ty);\n            }\n        }\n    }\n\n    export class Pool<T> {\n        private items = new Array<T>();\n        private instantiator: () => T;\n\n        constructor (instantiator: () => T) {\n            this.instantiator = instantiator;\n        }\n\n        obtain () {\n            return this.items.length > 0 ? this.items.pop() : this.instantiator();\n        }\n\n        free (item: T) {\n            if ((item as any).reset) (item as any).reset();\n            this.items.push(item);\n        }\n\n        freeAll (items: ArrayLike<T>) {\n            for (let i = 0; i < items.length; i++) {\n                this.free(items[i]);\n            }\n        }\n\n        clear () {\n            this.items.length = 0;\n        }\n    }\n\n    export class Vector2 {\n        constructor (public x = 0, public y = 0) {\n        }\n\n        set (x: number, y: number): Vector2 {\n            this.x = x;\n            this.y = y;\n            return this;\n        }\n\n        length () {\n            let x = this.x;\n            let y = this.y;\n            return Math.sqrt(x * x + y * y);\n        }\n\n        normalize () {\n            let len = this.length();\n            if (len != 0) {\n                this.x /= len;\n                this.y /= len;\n            }\n            return this;\n        }\n    }\n\n    export class TimeKeeper {\n        maxDelta = 0.064;\n        framesPerSecond = 0;\n        delta = 0;\n        totalTime = 0;\n\n        private lastTime = Date.now() / 1000;\n        private frameCount = 0;\n        private frameTime = 0;\n\n        update () {\n            let now = Date.now() / 1000;\n            this.delta = now - this.lastTime;\n            this.frameTime += this.delta;\n            this.totalTime += this.delta;\n            if (this.delta > this.maxDelta) this.delta = this.maxDelta;\n            this.lastTime = now;\n\n            this.frameCount++;\n            if (this.frameTime > 1) {\n                this.framesPerSecond = this.frameCount / this.frameTime;\n                this.frameTime = 0;\n                this.frameCount = 0;\n            }\n        }\n    }\n\n    export interface ArrayLike<T> {\n        length: number;\n        [n: number]: T;\n    }\n\n    export class WindowedMean {\n        values: Array<number>;\n        addedValues = 0;\n        lastValue = 0;\n        mean = 0;\n        dirty = true;\n\n        constructor (windowSize: number = 32) {\n            this.values = new Array<number>(windowSize);\n        }\n\n        hasEnoughData () {\n            return this.addedValues >= this.values.length;\n        }\n\n        addValue (value: number) {\n            if (this.addedValues < this.values.length)\n                this.addedValues++;\n            this.values[this.lastValue++] = value;\n            if (this.lastValue > this.values.length - 1) this.lastValue = 0;\n            this.dirty = true;\n        }\n\n        getMean () {\n            if (this.hasEnoughData()) {\n                if (this.dirty) {\n                    let mean = 0;\n                    for (let i = 0; i < this.values.length; i++) {\n                        mean += this.values[i];\n                    }\n                    this.mean = mean / this.values.length;\n                    this.dirty = false;\n                }\n                return this.mean;\n            } else {\n                return 0;\n            }\n        }\n    }\n}\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export abstract class Attachment {\r\n        name: string;\r\n\r\n        constructor(name: string) {\r\n            if (name == null) throw new Error(\"name cannot be null.\");\r\n            this.name = name;\r\n        }\r\n\r\n        abstract copy (): Attachment;\r\n    }\r\n\r\n    export abstract class VertexAttachment extends Attachment {\r\n        private static nextID = 0;\r\n\r\n        id = (VertexAttachment.nextID++ & 65535) << 11;\r\n        bones: Array<number>;\r\n        vertices: ArrayLike<number>;\r\n        worldVerticesLength = 0;\r\n        deformAttachment: VertexAttachment = this;\r\n\r\n        constructor(name: string) {\r\n            super(name);\r\n        }\r\n\r\n        computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\r\n            this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\r\n        }\r\n\r\n        /** Transforms local vertices to world coordinates.\r\n         * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\r\n         * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\r\n         * @param worldVertices The output world vertices. Must have a length >= offset + count.\r\n         * @param offset The worldVertices index to begin writing values. */\r\n        computeWorldVertices (slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number) {\r\n            count = offset + (count >> 1) * stride;\r\n            let skeleton = slot.bone.skeleton;\r\n            let deformArray = slot.deform;\r\n            let vertices = this.vertices;\r\n            let bones = this.bones;\r\n            if (bones == null) {\r\n                if (deformArray.length > 0) vertices = deformArray;\r\n                let mat = slot.bone.matrix;\r\n                let x = mat.tx;\r\n                let y = mat.ty;\r\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\r\n                for (let v = start, w = offset; w < count; v += 2, w += stride) {\r\n                    let vx = vertices[v], vy = vertices[v + 1];\r\n                    worldVertices[w] = vx * a + vy * b + x;\r\n                    worldVertices[w + 1] = vx * c + vy * d + y;\r\n                }\r\n                return;\r\n            }\r\n            let v = 0, skip = 0;\r\n            for (let i = 0; i < start; i += 2) {\r\n                let n = bones[v];\r\n                v += n + 1;\r\n                skip += n;\r\n            }\r\n            let skeletonBones = skeleton.bones;\r\n            if (deformArray.length == 0) {\r\n                for (let w = offset, b = skip * 3; w < count; w += stride) {\r\n                    let wx = 0, wy = 0;\r\n                    let n = bones[v++];\r\n                    n += v;\r\n                    for (; v < n; v++, b += 3) {\r\n                        let mat = skeletonBones[bones[v]].matrix;\r\n                        let vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\r\n                        wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                        wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                    }\r\n                    worldVertices[w] = wx;\r\n                    worldVertices[w + 1] = wy;\r\n                }\r\n            } else {\r\n                let deform = deformArray;\r\n                for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\r\n                    let wx = 0, wy = 0;\r\n                    let n = bones[v++];\r\n                    n += v;\r\n                    for (; v < n; v++, b += 3, f += 2) {\r\n                        let mat = skeletonBones[bones[v]].matrix;\r\n                        let vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1], weight = vertices[b + 2];\r\n                        wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\r\n                        wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\r\n                    }\r\n                    worldVertices[w] = wx;\r\n                    worldVertices[w + 1] = wy;\r\n                }\r\n            }\r\n        }\r\n\r\n        copyTo (attachment: VertexAttachment) {\r\n            if (this.bones != null) {\r\n                attachment.bones = new Array<number>(this.bones.length);\r\n                Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\r\n            } else\r\n                attachment.bones = null;\r\n\r\n            if (this.vertices != null) {\r\n                attachment.vertices = Utils.newFloatArray(this.vertices.length);\r\n                Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\r\n            } else\r\n                attachment.vertices = null;\r\n\r\n            attachment.worldVerticesLength = this.worldVerticesLength;\r\n            attachment.deformAttachment = this.deformAttachment;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export enum AttachmentType {\r\n        Region, BoundingBox, Mesh, LinkedMesh, Path, Point, Clipping\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class BoundingBoxAttachment extends VertexAttachment {\r\n        color = new Color(1, 1, 1, 1);\r\n\r\n        constructor (name: string) {\r\n            super(name);\r\n        }\r\n\r\n        copy (): Attachment {\r\n            let copy = new BoundingBoxAttachment(name);\r\n            this.copyTo(copy);\r\n            copy.color.setFromColor(this.color);\r\n            return copy;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License v2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class ClippingAttachment extends VertexAttachment {\r\n        endSlot: SlotData;\r\n\r\n        // Nonessential.\r\n        color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\r\n\r\n        constructor (name: string) {\r\n            super(name);\r\n        }\r\n\r\n        copy (): Attachment {\r\n            let copy = new ClippingAttachment(name);\r\n            this.copyTo(copy);\r\n            copy.endSlot = this.endSlot;\r\n            copy.color.setFromColor(this.color);\r\n            return copy;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class MeshAttachment extends VertexAttachment {\r\n        region: TextureRegion;\r\n        path: string;\r\n        regionUVs: Float32Array; uvs: ArrayLike<number>;\r\n        triangles: Array<number>;\r\n        color = new Color(1, 1, 1, 1);\r\n        width: number;\r\n        height: number;\r\n        hullLength: number;\r\n        edges: Array<number>;\r\n        private parentMesh: MeshAttachment;\r\n        tempColor = new Color(0, 0, 0, 0);\r\n\r\n        constructor (name: string) {\r\n            super(name);\r\n        }\r\n\r\n        getParentMesh () {\r\n            return this.parentMesh;\r\n        }\r\n\r\n        /** @param parentMesh May be null. */\r\n        setParentMesh (parentMesh: MeshAttachment) {\r\n            this.parentMesh = parentMesh;\r\n            if (parentMesh != null) {\r\n                this.bones = parentMesh.bones;\r\n                this.vertices = parentMesh.vertices;\r\n                this.worldVerticesLength = parentMesh.worldVerticesLength;\r\n                this.regionUVs = parentMesh.regionUVs;\r\n                this.triangles = parentMesh.triangles;\r\n                this.hullLength = parentMesh.hullLength;\r\n                this.worldVerticesLength = parentMesh.worldVerticesLength\r\n            }\r\n        }\r\n\r\n        copy (): Attachment {\r\n            if (this.parentMesh != null) return this.newLinkedMesh();\r\n\r\n            let copy = new MeshAttachment(this.name);\r\n            copy.region = this.region;\r\n            copy.path = this.path;\r\n            copy.color.setFromColor(this.color);\r\n\r\n            this.copyTo(copy);\r\n            copy.regionUVs = new Float32Array(this.regionUVs.length);\r\n            Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\r\n            copy.uvs = new Array<number>(this.uvs.length);\r\n            Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, this.uvs.length);\r\n            copy.triangles = new Array<number>(this.triangles.length);\r\n            Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\r\n            copy.hullLength = this.hullLength;\r\n\r\n            // Nonessential.\r\n            if (this.edges != null) {\r\n                copy.edges = new Array<number>(this.edges.length);\r\n                Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\r\n            }\r\n            copy.width = this.width;\r\n            copy.height = this.height;\r\n\r\n            return copy;\r\n        }\r\n\r\n        newLinkedMesh (): MeshAttachment {\r\n            let copy = new MeshAttachment(this.name);\r\n            copy.region = this.region;\r\n            copy.path = this.path;\r\n            copy.color.setFromColor(this.color);\r\n            copy.deformAttachment = this.deformAttachment;\r\n            copy.setParentMesh(this.parentMesh != null ? this.parentMesh : this);\r\n            // copy.updateUVs();\r\n            return copy;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class PathAttachment extends VertexAttachment {\r\n        lengths: Array<number>;\r\n        closed = false; constantSpeed = false;\r\n        color = new Color(1, 1, 1, 1);\r\n\r\n        constructor (name: string) {\r\n            super(name);\r\n        }\r\n\r\n        copy (): Attachment {\r\n            let copy = new PathAttachment(name);\r\n            this.copyTo(copy);\r\n            copy.lengths = new Array<number>(this.lengths.length);\r\n            Utils.arrayCopy(this.lengths, 0, copy.lengths, 0, this.lengths.length);\r\n            copy.closed = closed;\r\n            copy.constantSpeed = this.constantSpeed;\r\n            copy.color.setFromColor(this.color);\r\n            return copy;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License v2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n    export class PointAttachment extends VertexAttachment {\r\n        x: number; y: number; rotation: number;\r\n        color = new Color(0.38, 0.94, 0, 1);\r\n\r\n        constructor (name: string) {\r\n            super(name);\r\n        }\r\n\r\n        computeWorldPosition(bone: Bone, point: Vector2) {\r\n            const mat = bone.matrix;\r\n            point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\r\n            point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\r\n            return point;\r\n        }\r\n\r\n        computeWorldRotation(bone: Bone) {\r\n            const mat = bone.matrix;\r\n            let cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);\r\n            let x = cos * mat.a + sin * mat.c;\r\n            let y = cos * mat.b + sin * mat.d;\r\n            return Math.atan2(y, x) * MathUtils.radDeg;\r\n        }\r\n\r\n        copy (): Attachment {\r\n            let copy = new PointAttachment(name);\r\n            copy.x = this.x;\r\n            copy.y = this.y;\r\n            copy.rotation = this.rotation;\r\n            copy.color.setFromColor(this.color);\r\n            return copy;\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class RegionAttachment extends Attachment {\n        static OX1 = 0;\n        static OY1 = 1;\n        static OX2 = 2;\n        static OY2 = 3;\n        static OX3 = 4;\n        static OY3 = 5;\n        static OX4 = 6;\n        static OY4 = 7;\n\n        static X1 = 0;\n        static Y1 = 1;\n        static C1R = 2;\n        static C1G = 3;\n        static C1B = 4;\n        static C1A = 5;\n        static U1 = 6;\n        static V1 = 7;\n\n        static X2 = 8;\n        static Y2 = 9;\n        static C2R = 10;\n        static C2G = 11;\n        static C2B = 12;\n        static C2A = 13;\n        static U2 = 14;\n        static V2 = 15;\n\n        static X3 = 16;\n        static Y3 = 17;\n        static C3R = 18;\n        static C3G = 19;\n        static C3B = 20;\n        static C3A = 21;\n        static U3 = 22;\n        static V3 = 23;\n\n        static X4 = 24;\n        static Y4 = 25;\n        static C4R = 26;\n        static C4G = 27;\n        static C4B = 28;\n        static C4A = 29;\n        static U4 = 30;\n        static V4 = 31;\n\n        x = 0;\n        y = 0;\n        scaleX = 1;\n        scaleY = 1;\n        rotation = 0;\n        width = 0;\n        height = 0;\n        color = new Color(1, 1, 1, 1);\n\n        path: string;\n        rendererObject: any;\n        region: TextureRegion;\n\n        offset = Utils.newFloatArray(8);\n        uvs = Utils.newFloatArray(8);\n\n        tempColor = new Color(1, 1, 1, 1);\n\n        constructor(name: string) {\n            super(name);\n        }\n\n        updateOffset(): void {\n            let regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n            let regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n            let localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n            let localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n            let localX2 = localX + this.region.width * regionScaleX;\n            let localY2 = localY + this.region.height * regionScaleY;\n            let radians = this.rotation * Math.PI / 180;\n            let cos = Math.cos(radians);\n            let sin = Math.sin(radians);\n            let localXCos = localX * cos + this.x;\n            let localXSin = localX * sin;\n            let localYCos = localY * cos + this.y;\n            let localYSin = localY * sin;\n            let localX2Cos = localX2 * cos + this.x;\n            let localX2Sin = localX2 * sin;\n            let localY2Cos = localY2 * cos + this.y;\n            let localY2Sin = localY2 * sin;\n            let offset = this.offset;\n            offset[RegionAttachment.OX1] = localXCos - localYSin;\n            offset[RegionAttachment.OY1] = localYCos + localXSin;\n            offset[RegionAttachment.OX2] = localXCos - localY2Sin;\n            offset[RegionAttachment.OY2] = localY2Cos + localXSin;\n            offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n            offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n            offset[RegionAttachment.OX4] = localX2Cos - localYSin;\n            offset[RegionAttachment.OY4] = localYCos + localX2Sin;\n        }\n\n        setRegion(region: TextureRegion): void {\n            this.region = region;\n            let uvs = this.uvs;\n            if (region.rotate) {\n                uvs[2] = region.u;\n                uvs[3] = region.v2;\n                uvs[4] = region.u;\n                uvs[5] = region.v;\n                uvs[6] = region.u2;\n                uvs[7] = region.v;\n                uvs[0] = region.u2;\n                uvs[1] = region.v2;\n            } else {\n                uvs[0] = region.u;\n                uvs[1] = region.v2;\n                uvs[2] = region.u;\n                uvs[3] = region.v;\n                uvs[4] = region.u2;\n                uvs[5] = region.v;\n                uvs[6] = region.u2;\n                uvs[7] = region.v2;\n            }\n        }\n\n        computeWorldVertices(bone: Bone, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n            let vertexOffset = this.offset;\n            let mat = bone.matrix;\n            let x = mat.tx, y = mat.ty;\n            let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n            let offsetX = 0, offsetY = 0;\n\n            offsetX = vertexOffset[RegionAttachment.OX1];\n            offsetY = vertexOffset[RegionAttachment.OY1];\n            worldVertices[offset] = offsetX * a + offsetY * b + x; // br\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            offset += stride;\n\n            offsetX = vertexOffset[RegionAttachment.OX2];\n            offsetY = vertexOffset[RegionAttachment.OY2];\n            worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            offset += stride;\n\n            offsetX = vertexOffset[RegionAttachment.OX3];\n            offsetY = vertexOffset[RegionAttachment.OY3];\n            worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            offset += stride;\n\n            offsetX = vertexOffset[RegionAttachment.OX4];\n            offsetY = vertexOffset[RegionAttachment.OY4];\n            worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        }\n\n        copy (): Attachment {\n            let copy = new RegionAttachment(this.name);\n            copy.region = this.region;\n            copy.rendererObject = this.rendererObject;\n            copy.path = this.path;\n            copy.x = this.x;\n            copy.y = this.y;\n            copy.scaleX = this.scaleX;\n            copy.scaleY = this.scaleY;\n            copy.rotation = this.rotation;\n            copy.width = this.width;\n            copy.height = this.height;\n            Utils.arrayCopy(this.uvs, 0, copy.uvs, 0, 8);\n            Utils.arrayCopy(this.offset, 0, copy.offset, 0, 8);\n            copy.color.setFromColor(this.color);\n            return copy;\n        }\n    }\n}\n","/******************************************************************************\r\n * Spine Runtimes Software License v2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n\texport class JitterEffect implements VertexEffect {\r\n\t\tjitterX = 0;\r\n\t\tjitterY = 0;\r\n\r\n\t\tconstructor (jitterX: number, jitterY: number) {\r\n\t\t\tthis.jitterX = jitterX;\r\n\t\t\tthis.jitterY = jitterY;\r\n\t\t}\r\n\r\n\t\tbegin(skeleton: Skeleton): void {\r\n\t\t}\r\n\r\n\t\ttransform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\r\n\t\t\tposition.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n\t\t\tposition.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\r\n\t\t}\r\n\r\n\t\tend(): void {\r\n\t\t}\r\n\t}\r\n}\r\n","/******************************************************************************\r\n * Spine Runtimes Software License v2.5\r\n *\r\n * Copyright (c) 2013-2016, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\r\n * non-transferable license to use, install, execute, and perform the Spine\r\n * Runtimes software and derivative works solely for personal or internal\r\n * use. Without the written permission of Esoteric Software (see Section 2 of\r\n * the Spine Software License Agreement), you may not (a) modify, translate,\r\n * adapt, or develop new applications using the Spine Runtimes or otherwise\r\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\r\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\r\n * or other intellectual property or proprietary rights notices on or in the\r\n * Software, including any copy thereof. Redistributions in binary or source\r\n * form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\r\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\r\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n * POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\n\r\nnamespace pixi_spine.core {\r\n\texport class SwirlEffect implements VertexEffect {\r\n\t\tstatic interpolation = new PowOut(2);\r\n\t\tcenterX = 0;\r\n\t\tcenterY = 0;\r\n\t\tradius = 0;\r\n\t\tangle = 0;\r\n\t\tprivate worldX = 0;\r\n\t\tprivate worldY = 0;\r\n\r\n\t\tconstructor (radius: number) {\r\n\t\t\tthis.radius = radius;\r\n\t\t}\r\n\r\n\t\tbegin(skeleton: Skeleton): void {\r\n\t\t\tthis.worldX = skeleton.x + this.centerX;\r\n\t\t\tthis.worldY = skeleton.y + this.centerY;\r\n\t\t}\r\n\r\n\t\ttransform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\r\n\t\t\tlet radAngle = this.angle * MathUtils.degreesToRadians;\r\n\t\t\tlet x = position.x - this.worldX;\r\n\t\t\tlet y = position.y - this.worldY;\r\n\t\t\tlet dist = Math.sqrt(x * x + y * y);\r\n\t\t\tif (dist < this.radius) {\r\n\t\t\t\tlet theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\r\n\t\t\t\tlet cos = Math.cos(theta);\r\n\t\t\t\tlet sin = Math.sin(theta);\r\n\t\t\t\tposition.x = cos * x - sin * y + this.worldX;\r\n\t\t\t\tposition.y = sin * x + cos * y + this.worldY;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tend(): void {\r\n\t\t}\r\n\t}\r\n}\r\n","interface Math {\r\n    fround(n: number): number;\r\n}\r\n\r\n(() => {\r\n    if (!Math.fround) {\r\n        Math.fround = Math.fround = (function(array) {\r\n            return function(x: number) {\r\n                return array[0] = x, array[0];\r\n            };\r\n        })(new Float32Array(1));\r\n    }\r\n})();\r\n","/// <reference types=\"pixi.js\" />\r\n/// <reference path=\"polyfills.ts\" />\r\n/// <reference path=\"core/Bone.ts\" />\r\nnamespace pixi_spine {\r\n    /* Esoteric Software SPINE wrapper for pixi.js */\r\n    core.Bone.yDown = true;\r\n\r\n    let tempRgb = [0, 0, 0];\r\n\r\n    export interface ISpineDisplayObject extends PIXI.DisplayObject {\r\n        region?: core.TextureRegion;\r\n        attachment?: core.Attachment;\r\n    }\r\n\r\n    export class SpineSprite extends PIXI.Sprite implements ISpineDisplayObject {\r\n        region?: core.TextureRegion = null;\r\n        attachment?: core.Attachment = null;\r\n    }\r\n\r\n    const gp = PIXI.GraphicsGeometry.prototype as any;\r\n    if (!gp.invalidate) {\r\n        let tmp = [];\r\n        gp.invalidate = function() {\r\n            const t = this.graphicsData;\r\n            tmp.push(0);\r\n            this.graphicsData = tmp;\r\n            this.clear();\r\n            this.graphicsData = t;\r\n        }\r\n    }\r\n\r\n    export class SpineMesh extends PIXI.SimpleMesh implements ISpineDisplayObject {\r\n        region?: core.TextureRegion = null;\r\n        attachment?: core.Attachment = null;\r\n\r\n        constructor(texture: PIXI.Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\r\n            super(texture, vertices, uvs, indices, drawMode);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A class that enables the you to import and run your spine animations in pixi.\r\n     * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\r\n     * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\r\n     *\r\n     * ```js\r\n     * let spineAnimation = new spine(spineData);\r\n     * ```\r\n     *\r\n     * @class\r\n     * @extends Container\r\n     * @memberof spine\r\n     * @param spineData {object} The spine data loaded from a spine atlas.\r\n     */\r\n    export class Spine extends PIXI.Container {\r\n        static globalAutoUpdate: boolean = true;\r\n        static globalDelayLimit: number  = 0;\r\n\r\n        tintRgb: ArrayLike<number>;\r\n        spineData: core.SkeletonData;\r\n        skeleton: core.Skeleton;\r\n        stateData: core.AnimationStateData;\r\n        state: core.AnimationState;\r\n        slotContainers: Array<PIXI.Container>;\r\n        tempClipContainers: Array<PIXI.Container>;\r\n        localDelayLimit: number;\r\n        private _autoUpdate: boolean;\r\n        private _visible: boolean;\r\n\r\n        constructor(spineData: core.SkeletonData) {\r\n            super();\r\n\r\n            if (!spineData) {\r\n                throw new Error('The spineData param is required.');\r\n            }\r\n\r\n            if ((typeof spineData) === \"string\") {\r\n                throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\r\n            }\r\n\r\n            /**\r\n             * The spineData object\r\n             *\r\n             * @member {object}\r\n             */\r\n            this.spineData = spineData;\r\n\r\n            /**\r\n             * A spine Skeleton object\r\n             *\r\n             * @member {object}\r\n             */\r\n            this.skeleton = new core.Skeleton(spineData);\r\n            this.skeleton.updateWorldTransform();\r\n\r\n            /**\r\n             * A spine AnimationStateData object created from the spine data passed in the constructor\r\n             *\r\n             * @member {object}\r\n             */\r\n            this.stateData = new core.AnimationStateData(spineData);\r\n\r\n            /**\r\n             * A spine AnimationState object created from the spine AnimationStateData object\r\n             *\r\n             * @member {object}\r\n             */\r\n            this.state = new core.AnimationState(this.stateData);\r\n\r\n            /**\r\n             * An array of containers\r\n             *\r\n             * @member {Container[]}\r\n             */\r\n            this.slotContainers = [];\r\n\r\n            this.tempClipContainers = [];\r\n\r\n            for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n                let slot = this.skeleton.slots[i];\r\n                let attachment: any = slot.getAttachment();\r\n                let slotContainer = this.newContainer();\r\n                this.slotContainers.push(slotContainer);\r\n                this.addChild(slotContainer);\r\n                this.tempClipContainers.push(null);\r\n\r\n                if (attachment instanceof core.RegionAttachment) {\r\n                    let spriteName = (attachment.region as core.TextureAtlasRegion).name;\r\n                    let sprite = this.createSprite(slot, attachment, spriteName);\r\n                    slot.currentSprite = sprite;\r\n                    slot.currentSpriteName = spriteName;\r\n                    slotContainer.addChild(sprite);\r\n                }\r\n                else if (attachment instanceof core.MeshAttachment) {\r\n                    let mesh = this.createMesh(slot, attachment);\r\n                    slot.currentMesh = mesh;\r\n                    slot.currentMeshName = attachment.name;\r\n                    slotContainer.addChild(mesh);\r\n                }\r\n                else if (attachment instanceof core.ClippingAttachment) {\r\n                    this.createGraphics(slot, attachment);\r\n                    slotContainer.addChild(slot.clippingContainer);\r\n                    slotContainer.addChild(slot.currentGraphics);\r\n                }\r\n                else {\r\n                    continue;\r\n                }\r\n\r\n            }\r\n\r\n            /**\r\n             * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\r\n             *\r\n             * @member {number}\r\n             * @memberof spine.Spine#\r\n             */\r\n            this.tintRgb = new Float32Array([1, 1, 1]);\r\n\r\n            this.autoUpdate = true;\r\n            this.visible = true;\r\n        }\r\n\r\n        /**\r\n         * If this flag is set to true, the spine animation will be automatically updated every\r\n         * time the object id drawn. The down side of this approach is that the delta time is\r\n         * automatically calculated and you could miss out on cool effects like slow motion,\r\n         * pause, skip ahead and the sorts. Most of these effects can be achieved even with\r\n         * autoUpdate enabled but are harder to achieve.\r\n         *\r\n         * @member {boolean}\r\n         * @memberof spine.Spine#\r\n         * @default true\r\n         */\r\n        get autoUpdate(): boolean {\r\n            return this._autoUpdate;\r\n        }\r\n\r\n        set autoUpdate(value: boolean) {\r\n            if (value !== this._autoUpdate) {\r\n                this._autoUpdate = value;\r\n                this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The visibility of the spine object. If false the object will not be drawn,\r\n         * the updateTransform function will not be called, and the spine will not be automatically updated.\r\n         *\r\n         * @member {boolean}\r\n         * @memberof spine.Spine#\r\n         * @default true\r\n         */\r\n        get visible(): boolean {\r\n            return this._visible;\r\n        }\r\n\r\n        set visible(value: boolean) {\r\n            if (value !== this._visible) {\r\n                this._visible = value;\r\n                if (value) {\r\n                    this.lastTime = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\r\n         *\r\n         * @member {number}\r\n         * @memberof spine.Spine#\r\n         * @default 0xFFFFFF\r\n         */\r\n        get tint(): number {\r\n            return PIXI.utils.rgb2hex(this.tintRgb as any);\r\n        }\r\n\r\n        set tint(value: number) {\r\n            this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb as any);\r\n        }\r\n\r\n        /**\r\n         * Limit value for the update dt with Spine.globalDelayLimit\r\n         * that can be overridden with localDelayLimit\r\n         * @return {number} - Maximum processed dt value for the update\r\n         */\r\n        get delayLimit() : number {\r\n            let limit = typeof this.localDelayLimit !== \"undefined\"?\r\n                this.localDelayLimit: Spine.globalDelayLimit;\r\n\r\n            // If limit is 0, this means there is no limit for the delay\r\n            return limit || Number.MAX_VALUE\r\n        }\r\n\r\n        /**\r\n         * Update the spine skeleton and its animations by delta time (dt)\r\n         *\r\n         * @param dt {number} Delta time. Time by which the animation should be updated\r\n         */\r\n        update(dt: number) {\r\n            // Limit delta value to avoid animation jumps\r\n            let delayLimit = this.delayLimit;\r\n            if (dt > delayLimit) dt = delayLimit;\r\n\r\n            this.state.update(dt);\r\n            this.state.apply(this.skeleton);\r\n\r\n            //check we haven't been destroyed via a spine event callback in state update\r\n            if(!this.skeleton)\r\n                return;\r\n\r\n            this.skeleton.updateWorldTransform();\r\n\r\n            let slots = this.skeleton.slots;\r\n\r\n            // in case pixi has double tint\r\n            let globalClr = (this as any).color;\r\n            let light: ArrayLike<number> = null, dark: ArrayLike<number> = null;\r\n\r\n            if (globalClr) {\r\n                light = globalClr.light;\r\n                dark = globalClr.dark;\r\n            } else {\r\n                light = this.tintRgb;\r\n            }\r\n\r\n            let thack = false;\r\n\r\n            for (let i = 0, n = slots.length; i < n; i++) {\r\n                let slot = slots[i];\r\n                let attachment = slot.getAttachment();\r\n                let slotContainer = this.slotContainers[i];\r\n\r\n                if (!attachment) {\r\n                    slotContainer.visible = false;\r\n                    continue;\r\n                }\r\n\r\n                let spriteColor: any = null;\r\n\r\n                let attColor = (attachment as any).color;\r\n                if (attachment instanceof core.RegionAttachment) {\r\n                    let region = (attachment as core.RegionAttachment).region;\r\n                    if (region) {\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.visible = false;\r\n                            slot.currentMesh = null;\r\n                            slot.currentMeshName = undefined;\r\n                        }\r\n                        let ar = region as core.TextureAtlasRegion;\r\n                        if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\r\n                            let spriteName = ar.name;\r\n                            if (slot.currentSprite) {\r\n                                slot.currentSprite.visible = false;\r\n                            }\r\n                            slot.sprites = slot.sprites || {};\r\n                            if (slot.sprites[spriteName] !== undefined) {\r\n                                slot.sprites[spriteName].visible = true;\r\n                            }\r\n                            else {\r\n                                let sprite = this.createSprite(slot, attachment, spriteName);\r\n                                slotContainer.addChild(sprite);\r\n                            }\r\n                            slot.currentSprite = slot.sprites[spriteName];\r\n                            slot.currentSpriteName = spriteName;\r\n\r\n                        // force sprite update when attachment name is same.\r\n                        // issues https://github.com/pixijs/pixi-spine/issues/318\r\n                        } else if (slot.currentSpriteName === ar.name && !slot.hackRegion) {\r\n                            this.setSpriteRegion(attachment, slot.currentSprite, region);\r\n                        }\r\n                    }\r\n\r\n                    let transform = slotContainer.transform;\r\n                    transform.setFromMatrix(slot.bone.matrix);\r\n\r\n                    if (slot.currentSprite.color) {\r\n                        //YAY! double - tint!\r\n                        spriteColor = slot.currentSprite.color;\r\n                    } else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentSprite.blendMode = slot.blendMode;\r\n                }\r\n                else if (attachment instanceof core.MeshAttachment) {\r\n                    if (slot.currentSprite) {\r\n                        //TODO: refactor this thing, switch it on and off for container\r\n                        slot.currentSprite.visible = false;\r\n                        slot.currentSprite = null;\r\n                        slot.currentSpriteName = undefined;\r\n\r\n                        //TODO: refactor this shit\r\n                        const transform = new PIXI.Transform();\r\n                        (transform as any)._parentID = -1;\r\n                        (transform as any)._worldID = (slotContainer.transform as any)._worldID;\r\n                        slotContainer.transform = transform;\r\n                    }\r\n                    if (!slot.currentMeshName || slot.currentMeshName !== attachment.name) {\r\n                        let meshName = attachment.name;\r\n                        if (slot.currentMesh) {\r\n                            slot.currentMesh.visible = false;\r\n                        }\r\n\r\n                        slot.meshes = slot.meshes || {};\r\n\r\n                        if (slot.meshes[meshName] !== undefined) {\r\n                            slot.meshes[meshName].visible = true;\r\n                        }\r\n                        else {\r\n                            let mesh = this.createMesh(slot, attachment);\r\n                            slotContainer.addChild(mesh);\r\n                        }\r\n\r\n                        slot.currentMesh = slot.meshes[meshName];\r\n                        slot.currentMeshName = meshName;\r\n                    }\r\n                    (attachment as core.VertexAttachment).computeWorldVerticesOld(slot, slot.currentMesh.vertices);\r\n                    if (slot.currentMesh.color) {\r\n                        // pixi-heaven\r\n                        spriteColor = slot.currentMesh.color;\r\n                    } else {\r\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\r\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\r\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\r\n                        slot.currentMesh.tint = PIXI.utils.rgb2hex(tempRgb);\r\n                    }\r\n                    slot.currentMesh.blendMode = slot.blendMode;\r\n                }\r\n                else if (attachment instanceof core.ClippingAttachment) {\r\n                    if (!slot.currentGraphics) {\r\n                        this.createGraphics(slot, attachment);\r\n                        slotContainer.addChild(slot.clippingContainer);\r\n                        slotContainer.addChild(slot.currentGraphics);\r\n                    }\r\n                    this.updateGraphics(slot, attachment);\r\n                }\r\n                else {\r\n                    slotContainer.visible = false;\r\n                    continue;\r\n                }\r\n                slotContainer.visible = true;\r\n\r\n                // pixi has double tint\r\n                if (spriteColor) {\r\n                    let r0 = slot.color.r * attColor.r;\r\n                    let g0 = slot.color.g * attColor.g;\r\n                    let b0 = slot.color.b * attColor.b;\r\n\r\n                    //YAY! double-tint!\r\n                    spriteColor.setLight(\r\n                        light[0] * r0 + dark[0] * (1.0 - r0),\r\n                        light[1] * g0 + dark[1] * (1.0 - g0),\r\n                        light[2] * b0 + dark[2] * (1.0 - b0),\r\n                    );\r\n                    if (slot.darkColor) {\r\n                        r0 = slot.darkColor.r;\r\n                        g0 = slot.darkColor.g;\r\n                        b0 = slot.darkColor.b;\r\n                    } else {\r\n                        r0 = 0.0;\r\n                        g0 = 0.0;\r\n                        b0 = 0.0;\r\n                    }\r\n                    spriteColor.setDark(\r\n                        light[0] * r0 + dark[0] * (1 - r0),\r\n                        light[1] * g0 + dark[1] * (1 - g0),\r\n                        light[2] * b0 + dark[2] * (1 - b0),\r\n                    );\r\n                }\r\n\r\n                slotContainer.alpha = slot.color.a;\r\n            }\r\n\r\n            //== this is clipping implementation ===\r\n            //TODO: remove parent hacks when pixi masks allow it\r\n            let drawOrder = this.skeleton.drawOrder;\r\n            let clippingAttachment: core.ClippingAttachment = null;\r\n            let clippingContainer: PIXI.Container = null;\r\n\r\n            for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n                let slot = slots[drawOrder[i].data.index];\r\n                let slotContainer = this.slotContainers[drawOrder[i].data.index];\r\n\r\n                if (!clippingContainer) {\r\n\t\t\t\t\t//Adding null check as it is possible for slotContainer.parent to be null in the event of a spine being disposed off in its loop callback\r\n                    if (slotContainer.parent !== null && slotContainer.parent !== this) {\r\n                        slotContainer.parent.removeChild(slotContainer);\r\n                        //silend add hack\r\n                        (slotContainer as any).parent = this;\r\n                    }\r\n                }\r\n                if (slot.currentGraphics && slot.getAttachment()) {\r\n                    clippingContainer = slot.clippingContainer;\r\n                    clippingAttachment = slot.getAttachment() as core.ClippingAttachment;\r\n                    clippingContainer.children.length = 0;\r\n                    this.children[i] = slotContainer;\r\n\r\n                    if (clippingAttachment.endSlot == slot.data) {\r\n                        clippingAttachment.endSlot = null;\r\n                    }\r\n\r\n                } else {\r\n                    if (clippingContainer) {\r\n                        let c = this.tempClipContainers[i];\r\n                        if (!c) {\r\n                            c = this.tempClipContainers[i] = this.newContainer();\r\n                            c.visible = false;\r\n                        }\r\n                        this.children[i] = c;\r\n\r\n                        //silent remove hack\r\n                        (slotContainer as any).parent = null;\r\n                        clippingContainer.addChild(slotContainer);\r\n                        if (clippingAttachment.endSlot == slot.data) {\r\n                            clippingContainer.renderable = true;\r\n                            clippingContainer = null;\r\n                            clippingAttachment = null;\r\n                        }\r\n                    } else {\r\n                        this.children[i] = slotContainer;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        private setSpriteRegion(attachment: core.RegionAttachment, sprite: SpineSprite, region: core.TextureRegion) {\r\n            // prevent setters calling when attachment and region is same\r\n            if(sprite.attachment === attachment && sprite.region === region) {\r\n                return;\r\n            }\r\n\r\n            sprite.region = region;\r\n            sprite.attachment = attachment;\r\n\r\n            sprite.texture = region.texture;\r\n            sprite.rotation = attachment.rotation * core.MathUtils.degRad;\r\n            sprite.position.x = attachment.x;\r\n            sprite.position.y = attachment.y;\r\n            sprite.alpha = attachment.color.a;\r\n\r\n            if (!region.size) {\r\n                sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\r\n                sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\r\n            } else {\r\n                //hacked!\r\n                sprite.scale.x = region.size.width / region.originalWidth;\r\n                sprite.scale.y = -region.size.height / region.originalHeight;\r\n            }\r\n        }\r\n\r\n        private setMeshRegion(attachment: core.MeshAttachment, mesh: SpineMesh, region: core.TextureRegion) {\r\n\r\n            if(mesh.attachment === attachment && mesh.region === region) {\r\n                return;\r\n            }\r\n\r\n            mesh.region = region;\r\n            mesh.attachment = attachment;\r\n            mesh.texture = region.texture;\r\n            region.texture.updateUvs();\r\n            mesh.uvBuffer.update(attachment.regionUVs);\r\n        }\r\n\r\n        protected lastTime: number;\r\n\r\n        /**\r\n         * When autoupdate is set to yes this function is used as pixi's updateTransform function\r\n         *\r\n         * @private\r\n         */\r\n        autoUpdateTransform() {\r\n            if (Spine.globalAutoUpdate) {\r\n                this.lastTime = this.lastTime || Date.now();\r\n                let timeDelta = (Date.now() - this.lastTime) * 0.001;\r\n                this.lastTime = Date.now();\r\n                this.update(timeDelta);\r\n            } else {\r\n                this.lastTime = 0;\r\n            }\r\n\r\n            PIXI.Container.prototype.updateTransform.call(this);\r\n        };\r\n\r\n        /**\r\n         * Create a new sprite to be used with core.RegionAttachment\r\n         *\r\n         * @param slot {spine.Slot} The slot to which the attachment is parented\r\n         * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n         * @private\r\n         */\r\n        createSprite(slot: core.Slot, attachment: core.RegionAttachment, defName: string) {\r\n            let region = attachment.region;\r\n            if (slot.hackAttachment === attachment) {\r\n                region = slot.hackRegion;\r\n            }\r\n            let texture = region.texture;\r\n            let sprite = this.newSprite(texture);\r\n\r\n            sprite.anchor.set(0.5);\r\n            this.setSpriteRegion(attachment, sprite, attachment.region);\r\n\r\n            slot.sprites = slot.sprites || {};\r\n            slot.sprites[defName] = sprite;\r\n            return sprite;\r\n        };\r\n\r\n        /**\r\n         * Creates a Strip from the spine data\r\n         * @param slot {spine.Slot} The slot to which the attachment is parented\r\n         * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n         * @private\r\n         */\r\n        createMesh(slot: core.Slot, attachment: core.MeshAttachment) {\r\n            let region = attachment.region;\r\n            if (slot.hackAttachment === attachment) {\r\n                region = slot.hackRegion;\r\n                slot.hackAttachment = null;\r\n                slot.hackRegion = null;\r\n            }\r\n            let strip = this.newMesh(\r\n                region.texture,\r\n                new Float32Array(attachment.regionUVs.length),\r\n                attachment.regionUVs,\r\n                new Uint16Array(attachment.triangles),\r\n                PIXI.DRAW_MODES.TRIANGLES);\r\n\r\n            if (typeof (strip as any)._canvasPadding !== \"undefined\") {\r\n                (strip as any)._canvasPadding = 1.5;\r\n            }\r\n\r\n            strip.alpha = attachment.color.a;\r\n\r\n            strip.region = attachment.region;\r\n            this.setMeshRegion(attachment, strip, region);\r\n\r\n            slot.meshes = slot.meshes || {};\r\n            slot.meshes[attachment.name] = strip;\r\n            return strip;\r\n        };\r\n\r\n        static clippingPolygon: Array<number> = [];\r\n\r\n        createGraphics(slot: core.Slot, clip: core.ClippingAttachment) {\r\n            let graphics = this.newGraphics();\r\n            let poly = new PIXI.Polygon([]);\r\n            graphics.clear();\r\n            graphics.beginFill(0xffffff, 1);\r\n            graphics.drawPolygon(poly as any);\r\n            graphics.renderable = false;\r\n            slot.currentGraphics = graphics;\r\n            slot.clippingContainer = this.newContainer();\r\n            slot.clippingContainer.mask = slot.currentGraphics;\r\n\r\n            return graphics;\r\n        }\r\n\r\n        updateGraphics(slot: core.Slot, clip: core.ClippingAttachment) {\r\n            let geom = slot.currentGraphics.geometry;\r\n            let vertices = (geom.graphicsData[0].shape as PIXI.Polygon).points;\r\n            let n = clip.worldVerticesLength;\r\n            vertices.length = n;\r\n            clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\r\n            geom.invalidate();\r\n        }\r\n\r\n        /**\r\n         * Changes texture in attachment in specific slot.\r\n         *\r\n         * PIXI runtime feature, it was made to satisfy our users.\r\n         *\r\n         * @param slotIndex {number}\r\n         * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n         * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n         * @returns {boolean} Success flag\r\n         */\r\n        hackTextureBySlotIndex(slotIndex: number, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\r\n            let slot = this.skeleton.slots[slotIndex];\r\n            if (!slot) {\r\n                return false;\r\n            }\r\n            let attachment: any = slot.getAttachment();\r\n            let region: core.TextureRegion = attachment.region;\r\n            if (texture) {\r\n                region = new core.TextureRegion();\r\n                region.texture = texture;\r\n                region.size = size;\r\n                slot.hackRegion = region;\r\n                slot.hackAttachment = attachment;\r\n            } else {\r\n                slot.hackRegion = null;\r\n                slot.hackAttachment = null;\r\n            }\r\n            if (slot.currentSprite && slot.currentSprite.region != region) {\r\n                this.setSpriteRegion(attachment, slot.currentSprite, region);\r\n                slot.currentSprite.region = region;\r\n            } else if (slot.currentMesh && slot.currentMesh.region != region) {\r\n                this.setMeshRegion(attachment, slot.currentMesh, region);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * Changes texture in attachment in specific slot.\r\n         *\r\n         * PIXI runtime feature, it was made to satisfy our users.\r\n         *\r\n         * @param slotName {string}\r\n         * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n         * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n         * @returns {boolean} Success flag\r\n         */\r\n        hackTextureBySlotName(slotName: string, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\r\n            let index = this.skeleton.findSlotIndex(slotName);\r\n            if (index == -1) {\r\n                return false;\r\n            }\r\n            return this.hackTextureBySlotIndex(index, texture, size);\r\n        }\r\n\r\n        /**\r\n         * Changes texture of an attachment\r\n         *\r\n         * PIXI runtime feature, it was made to satisfy our users.\r\n         *\r\n         * @param slotName {string}\r\n         * @param attachmentName {string}\r\n         * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n         * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n         * @returns {boolean} Success flag\r\n         */\r\n        hackTextureAttachment(slotName: string, attachmentName: string, texture, size: PIXI.Rectangle = null) {\r\n            // changes the texture of an attachment at the skeleton level\r\n            const slotIndex = this.skeleton.findSlotIndex(slotName)\r\n            const attachment: any = this.skeleton.getAttachmentByName(slotName, attachmentName)\r\n            attachment.region.texture = texture\r\n\r\n            const slot = this.skeleton.slots[slotIndex]\r\n            if (!slot) {\r\n                return false\r\n            }\r\n\r\n            // gets the currently active attachment in this slot\r\n            const currentAttachment: any = slot.getAttachment()\r\n            if (attachmentName === currentAttachment.name) {\r\n                // if the attachment we are changing is currently active, change the the live texture\r\n                let region: core.TextureRegion = attachment.region\r\n                if (texture) {\r\n                    region = new core.TextureRegion()\r\n                    region.texture = texture\r\n                    region.size = size\r\n                    slot.hackRegion = region\r\n                    slot.hackAttachment = currentAttachment\r\n                } else {\r\n                    slot.hackRegion = null\r\n                    slot.hackAttachment = null\r\n                }\r\n                if (slot.currentSprite && slot.currentSprite.region != region) {\r\n                    this.setSpriteRegion(currentAttachment, slot.currentSprite, region)\r\n                    slot.currentSprite.region = region\r\n                } else if (slot.currentMesh && slot.currentMesh.region != region) {\r\n                    this.setMeshRegion(currentAttachment, slot.currentMesh, region)\r\n                }\r\n                return true\r\n            }\r\n            return false\r\n        }\r\n\r\n        //those methods can be overriden to spawn different classes\r\n        newContainer() {\r\n            return new PIXI.Container();\r\n        }\r\n\r\n        newSprite(tex: PIXI.Texture) {\r\n            return new SpineSprite(tex);\r\n        }\r\n\r\n        newGraphics() {\r\n            return new PIXI.Graphics();\r\n        }\r\n\r\n        newMesh(texture: PIXI.Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\r\n            return new SpineMesh(texture, vertices, uvs, indices, drawMode);\r\n        }\r\n\r\n        transformHack() {\r\n            return 1;\r\n        }\r\n\r\n        /**\r\n         * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer\r\n         * @param nameSuffix\r\n         * @param group\r\n         * @param outGroup\r\n         */\r\n        hackAttachmentGroups(nameSuffix: string, group: any, outGroup: any) {\r\n            if (!nameSuffix) {\r\n                return;\r\n            }\r\n            const list_d = [], list_n = [];\r\n            for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {\r\n                const slot = this.skeleton.slots[i];\r\n                const name = slot.currentSpriteName || slot.currentMeshName || \"\";\r\n                const target = slot.currentSprite || slot.currentMesh;\r\n                if(name.endsWith(nameSuffix)){\r\n                    target.parentGroup = group;\r\n                    list_n.push(target);\r\n                }else if(outGroup && target){\r\n                    target.parentGroup = outGroup;\r\n                    list_d.push(target);\r\n                }\r\n            }\r\n            return [list_d,list_n];\r\n        };\r\n\r\n        destroy(options?: any): void {\r\n            for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\r\n                let slot = this.skeleton.slots[i];\r\n                for (let name in slot.meshes) {\r\n                    slot.meshes[name].destroy(options);\r\n                }\r\n                slot.meshes = null;\r\n\r\n                for (let name in slot.sprites) {\r\n                    slot.sprites[name].destroy(options);\r\n                }\r\n                slot.sprites = null;\r\n            }\r\n\r\n            for (let i = 0, n = this.slotContainers.length; i < n; i++) {\r\n                this.slotContainers[i].destroy(options);\r\n            }\r\n            this.spineData = null;\r\n            this.skeleton = null;\r\n            this.slotContainers = null;\r\n            this.stateData = null;\r\n            this.state = null;\r\n            this.tempClipContainers = null;\r\n\r\n            super.destroy(options);\r\n        }\r\n    }\r\n\r\n    function SlotContainerUpdateTransformV3() {\r\n        let pt = this.parent.worldTransform;\r\n        let wt = this.worldTransform;\r\n        let lt = this.localTransform;\r\n        wt.a = lt.a * pt.a + lt.b * pt.c;\r\n        wt.b = lt.a * pt.b + lt.b * pt.d;\r\n        wt.c = lt.c * pt.a + lt.d * pt.c;\r\n        wt.d = lt.c * pt.b + lt.d * pt.d;\r\n        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\r\n        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\r\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\r\n        this._currentBounds = null;\r\n    }\r\n}\r\n","namespace pixi_spine {\r\n    (PIXI as any).spine = pixi_spine;\r\n\r\n    // texture patch for v5\r\n\r\n    const TextureProto = PIXI.Texture.prototype as any;\r\n\r\n    if (!TextureProto._updateUvs) {\r\n        TextureProto._updateUvs = TextureProto.updateUvs;\r\n    }\r\n}\r\n"],"sourceRoot":""}